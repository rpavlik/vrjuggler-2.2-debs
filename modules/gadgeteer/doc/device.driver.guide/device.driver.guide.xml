<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>Gadgeteer</title>

      <subtitle>Device Driver Authoring Guide</subtitle>

      <copyright>
         <year>2003â€“2007</year>

         <holder>Iowa State University</holder>
      </copyright>

      <legalnotice>
         <para>Permission is granted to copy, distribute and/or modify this
         document under the terms of the GNU Free Documentation License,
         Version 1.2 or any later version published by the Free Software
         Foundation; with the Invariant Sections being <xref
         linkend="appendix.gfdl" />, with no Front-Cover Texts, and with no
         Back-Cover Texts. A copy of the license is included in <xref
         linkend="appendix.gfdl" />.</para>
      </legalnotice>

      <releaseinfo>Version 1.1</releaseinfo>

      <pubdate>$Date$</pubdate>
   </bookinfo>

   <part id="intro.part">
      <title id="programming.part">Introduction</title>

      <partintro>
         <para>We begin this book with some basic background information about
         Gadgeteer and the device drivers it uses. This part is written
         primarily for programmers who are new to Gadgeteer and VR Juggler in
         general. Rather than including technical content in this part, we
         instead review concepts and goals to provide new developers with an
         understanding of our motivations and our long-term goals for
         Gadgeteer.</para>
      </partintro>

      <chapter id="overview.chapter">
         <title>Overview of Gadgeteer</title>

         <indexterm>
            <primary>Gadgeteer</primary>

            <secondary>overview</secondary>
         </indexterm>

         <para>Gadgeteer acts as a hardware device management system. It
         contains a dynamically extensible Input Manager<indexterm>
               <primary>Input Manager</primary>
            </indexterm> that treats devices in terms of abstract concepts
         such as <quote>positional,</quote> <quote>digital,</quote>
         <quote>gesture,</quote> etc. It also contains a Remote Input
         Manager<indexterm>
               <primary>Remote Input Manager</primary>
            </indexterm> that can share device samples between computers. Most
         importantly, Gadgeteer provides device input for use with VR Juggler
         applications. As such, Gadgeteer was designed from the beginning to
         be used with an ever-widening array of virtual reality hardware
         configurations.</para>

         <section>
            <title>Goals of Gadgeteer</title>

            <indexterm>
               <primary>Gadgeteer</primary>

               <secondary>goals</secondary>
            </indexterm>

            <para>Gadgeteer serves to hide input device hardware from
            programmers so that immersive software may be written that can
            take advantage of a wide variety of devices. This goal arises from
            previous experience with software toolkits that tied immersive
            applications to specific devices, thereby limiting the portability
            of the applications between immersive hardware configurations.
            With Gadgeteer, applications can be written that migrate
            transparently between different hardware configurations with no
            required knowledge on the part of the application author relating
            to vendors, models, drivers, etc.</para>

            <para>Gadgeteer categorizes input devices based on abstract input
            types. The categories are the following:</para>

            <itemizedlist>
               <listitem>
                  <para>Analog</para>
               </listitem>

               <listitem>
                  <para>Command</para>
               </listitem>

               <listitem>
                  <para>Digital</para>
               </listitem>

               <listitem>
                  <para>Glove</para>
               </listitem>

               <listitem>
                  <para>Gesture</para>
               </listitem>

               <listitem>
                  <para>Position</para>
               </listitem>

               <listitem>
                  <para>Simulator</para>
               </listitem>

               <listitem>
                  <para>String</para>
               </listitem>
            </itemizedlist>

            <para>Each of these is described in more detail below in <xref
            linkend="device.types.section" />.</para>

            <para>In this categorization, devices from different vendors may
            return data that maps to the same abstract form. A single piece of
            hardware may even map to multiple input types, and more device
            types can be added as new hardware becomes available. Application
            authors write their code in terms of abstract input types, so as
            long as a device is available that provides the needed input, the
            application can function.</para>
         </section>

         <section id="driver.goals.section">
            <title>Goals for Device Driver Authors</title>

            <para>In keeping with the general goals of Gadgeteer, device
            driver authors should strive to achieve certain goals for each
            device driver they write. In no particular order, we feel that the
            most important goals are the following:</para>

            <itemizedlist>
               <listitem>
                  <para>Portability</para>
               </listitem>

               <listitem>
                  <para>Maintainability</para>
               </listitem>

               <listitem>
                  <para>Efficiency</para>
               </listitem>

               <listitem>
                  <para>Modularity</para>
               </listitem>
            </itemizedlist>

            <para>For the most part, these goals are no different than those
            of any other software project. Nonetheless, we will explain why
            each is important in the following subsections.</para>

            <section>
               <title>Portability</title>

               <para>Gadgeteer is a cross-platform device management system,
               and as such, the devices it manages should be usable on all
               platforms supported by Gadgeteer. While this may not always be
               possible<footnote>
                     <para>There are various reasons why a given hardware
                     device may not be usable between computers. For example,
                     not all architectures have parallel ports, and thus, a
                     parallel port device could not be expected to be used
                     where no port is available. In general, however, the
                     software device driver should not be the limiting factor
                     in the use of a hardware device.</para>
                  </footnote>, device driver authors should still attempt to
               make their drivers as portable as possible. The <glossterm
               linkend="gloss.vpr">VR Juggler Portable Runtime</glossterm>
               (VPR), introduced later in <xref linkend="vpr.chapter" />,
               provides many features that simplify the work of writing
               portable software. This applies to device drivers as much as
               any other piece of software, and thus, programmers should make
               use of VPR whenever possible.</para>
            </section>

            <section>
               <title>Maintainability</title>

               <para>Hardware tends to evolve over time, and new versions of a
               given device may be released. With new hardware, the
               communication protocol may change, either through extensions or
               through extensive changes. In order for Gadgeteer device
               drivers to be used with new hardware, a driver must be written
               so that it can be maintained by other programmers. That means
               that a driver should be documented well, and it should not use
               complex techniques to communicate with the hardware.</para>

               <para>Based on our experience, we recommend that the following
               practices when writing a new driver:</para>

               <itemizedlist>
                  <listitem>
                     <para>Do not <quote>brute force</quote> the driver
                     implementation just to get something working. Implement
                     the protocol clearly and completely.</para>
                  </listitem>

                  <listitem>
                     <para>Do not hard-code maximum values to match a local
                     installation or the current limitations of the hardware.
                     For example, if a positional tracker at the local
                     facility only has two trackers attached to it, do not
                     assume that everyone else has the same
                     configuration.</para>
                  </listitem>

                  <listitem>
                     <para>Do not do tricks with memory buffers. C and C++
                     provide very nice features for accessing blocks of
                     memory, so there is usually no need to do pointer math by
                     hand. More often than not, a <literal>struct</literal> or
                     a <literal>union</literal> will do a much better job than
                     an array of bytes.</para>
                  </listitem>
               </itemizedlist>
            </section>

            <section>
               <title>Efficiency</title>

               <para>Input devices used with virtual reality systems tend to
               sample at a much higher rate than the graphics are rendered
               (1000 Hz versus 60 Hz). Thus, for a given frame, the driver may
               make tens or hundreds of samples. Gadgeteer provides some
               facilities for efficient collection of samples, but ultimately,
               the driver author must ensure that the driver will not
               overwhelm the local computer (or the network if the Remote
               Input Manager is being used). On the other hand, minimizing
               input latency is very important in achieving good suspension of
               disbelief on the part of the user. Thus, it is not advisable to
               discard samples.</para>

               <para>The key thing to keep in mind when writing a device
               driver for Gadgeteer is that the driver will be running
               asynchronously from the graphics. Usually, the sample rate will
               be limited by how fast the sample can be read from the
               hardware, be it a memory access, a serial port read, or a
               network buffer read. A balance between low latency, memory
               efficiency, and possibly network efficiency must be
               found.</para>
            </section>

            <section>
               <title>Modularity</title>

               <para>The current practices used in Gadgeteer encourage
               modularity of device drivers. Each driver should be able to
               stand on its own as a single unit within the Input Manager.
               This philosophy allows individual drivers to be loaded on
               demand at runtime, and it simplifies compilation of drivers
               that are not supported on all operating systems.</para>
            </section>
         </section>
      </chapter>

      <chapter id="vpr.chapter">
         <title>Using the VR Juggler Portable Runtime</title>

         <indexterm>
            <primary>VPR</primary>

            <secondary>using</secondary>
         </indexterm>

         <indexterm>
            <primary>VPR</primary>

            <secondary>overview</secondary>
         </indexterm>

         <para>In this chapter, we will review briefly key components of the
         <ulink url="http://www.vrjuggler.org/vapor/">VR Juggler Portable
         Runtime</ulink> (VPR) that will be used by Gadgeteer device driver
         authors. This chapter is not meant to be a comprehensive description
         of VPR but rather a small guide to be used by programmers new to
         Gadgeteer, VPR, and other modules used by VR Juggler. We assume that
         the reader has some familiarity with operating system programming, in
         particular with serial device I/O, socket I/O, and multi-threaded
         techniques. One or more of these will almost certainly come into play
         when writing a device driver for use with Gadgeteer.</para>

         <para>For those developers new to Gadgeteer and VPR, VPR provides an
         cross-platform, object-oriented abstraction layer to common operating
         system features. VPR is the key to the portability of Gadgeteer,
         Tweek, VR Juggler, and other middleware written at the Virtual
         Reality Applications Center. It has been in development since January
         1997, and it has grown to be a highly portable, robust tool. Software
         written on top of VPR can be compiled on IRIX, Linux, Windows,
         FreeBSD, and Solaris, usually without modification.</para>

         <para>Internally, VPR wraps platform-specific APIs such as BSD
         sockets, POSIX threads, and Win32 overlapped I/O. Depending upon how
         it is compiled, it may also wrap the <ulink
         url="http://www.mozilla.org/projects/nspr/index.html">Netscape
         Portable Runtime</ulink> (<glossterm
         linkend="gloss.nspr">NSPR</glossterm>), another cross-platform OS
         abstraction layer written in C. By wrapping NSPR, VPR provides
         developers with an object-oriented interface and gains even better
         portability. These details are all hidden behind the classes that
         make up VPR, and users of VPR do not need to worry about
         platform-specific details as a result.</para>

         <section>
            <title>Buffered I/O</title>

            <para>Before discussing features of VPR useful to device driver
            authors, we must first understand how I/O is handled in VPR. All
            I/O classes (file handles, serial ports, and sockets) share the
            base class <classname>vpr::BlockIO</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vpr::BlockIO</secondary>
               </indexterm>. Reads and writes are performed using blocks of
            memory (buffers). This design provides an API that more closely
            resembles that of the underlying operating system (with methods
            called <methodname>read()</methodname> and
            <methodname>write()</methodname>), but it is in contrast to
            stream-oriented I/O that is usually seen in C++. Streams could be
            written on top of the buffered I/O classes, but thus far, the need
            has not arisen. With this in mind, the design provides an API that
            is immediately familiar to programmers used to POSIX-based
            interfaces, but the API may seem clumsy to C++ programmers who are
            accustomed to using <type>std::ostream</type> and friends.</para>
         </section>

         <section id="vpr.serial-ports.section">
            <title>Serial Ports</title>

            <indexterm>
               <primary>VPR</primary>

               <secondary>serial port abstraction</secondary>
            </indexterm>

            <para>Most input devices used for virtual reality systems today
            make use of a computer's serial port for data communication. For
            that reason, it is important that device driver authors have at
            least a basic understanding of the concepts behind the VPR serial
            port abstraction. In our experience, serial port programming is
            not much different than other I/O programming. Implementing the
            communication protocol used by a given device tends to be the hard
            part, and that will likely be the case regardless of the
            underlying hardware.</para>

            <para>The VPR serial port abstraction is based on the concepts
            implemented by the standard termios serial interface used by most
            modern UNIX-based operating systems <xref
            linkend="ref.advanced.prog.unix" />. As such, the API allows
            enabling and disabling of a subset of the serial device features
            that can be manipulated using termios directly. To provide
            cross-platform semantics, however, some termios features are not
            included because there is no corresponding capability with Win32
            overlapped I/O. Furthermore, any termios settings that relate
            specifically to modems are not included in the VPR serial port
            abstraction.</para>
         </section>

         <section id="vpr.sockets.section">
            <title>Sockets</title>

            <indexterm>
               <primary>VPR</primary>

               <secondary>socket abstraction</secondary>
            </indexterm>

            <note>
               <para>Readers not familiar with socket programming should
               consult a reference manual (<xref
               linkend="ref.unix.network.programming" /> is recommended). We
               do not attempt to explain the ins and outs of socket
               programming. Instead, we assume that readers are familiar with
               socket-level I/O and the ideas involved with various types of
               network communication.</para>
            </note>

            <para>The socket abstraction follows the concepts set forth by the
            <glossterm linkend="gloss.bsd.sockets">BSD sockets</glossterm>
            API, which was also the model for the Winsock API used on Windows.
            In VPR, two types of sockets may be instantiated: stream-oriented
            (TCP, <classname>vpr::SocketStream</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vpr::SocketStream</secondary>
               </indexterm>) and datagram (UDP,
            <classname>vpr::SocketDatagram<indexterm>
                  <primary>classes</primary>

                  <secondary>vpr::SocketDatagram</secondary>
               </indexterm></classname>). The helper class
            <classname>vpr::InetAddr</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vpr::InetAddr</secondary>
               </indexterm> makes use of Internet Protocol (v4) addresses
            easier. Built on top of <classname>vpr::SocketStream</classname>
            are two classes that make writing client/server code easier:
            <classname>vpr::SocketConnector</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vpr::SocketConnector</secondary>
               </indexterm> and
            <classname>vpr::SocketAcceptor</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vpr::SocketAcceptor</secondary>
               </indexterm>. The <classname>vpr::System</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vpr::System</secondary>
               </indexterm> interface provides cross-platform data conversion
            functions to deal with endian issues.</para>

            <para>The utility of various socket classes will vary depending on
            the needs of a given driver protocol. It is usually safe to assume
            that the driver will connect to a server of some sort that will
            send out device samples. Unpacking information from the samples
            may or may not be necessary, depending on the protocol. Such
            concerns are left entirely to the driver authors.</para>
         </section>

         <section id="vpr.threads.chapter">
            <title>Threads</title>

            <indexterm>
               <primary>VPR</primary>

               <secondary>thread abstraction</secondary>
            </indexterm>

            <para>All device drivers written for Gadgeteer will process
            samples in a thread separate from the Input Manager. We have
            chosen this design to avoid the complications that often arise
            from using non-blocking I/O and to allow the drivers to act more
            as independent entities. Thus, it will be important to understand
            how to use the VPR thread interface.</para>

            <para>First and foremost, developers must always remember that
            Gadgeteer uses a shared-memory model for all threads, regardless
            of the underlying platform-specific thread interface. This follows
            the lightweight thread model set forth by the POSIX threads
            (pthreads) standard. With a shared-memory model, all threads have
            access the same memory, and thus it will almost certainly be
            necessary to control access to shared variables. In most cases,
            the class <classname>vpr::Mutex</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vpr::Mutex</secondary>
               </indexterm> will provide sufficient control over
            multi-threaded data access.</para>

            <caution>
               <para>Multi-threaded programming can be tricky, and it is not
               something that most people can jump into without some
               background. Those developers who have not done multi-threaded
               programming before should review a manual or other reference on
               the topic before beginning work on a new driver. VPR threads
               are semantically similar to pthreads, and the concepts inherent
               in multi-threaded programming (e.g., protecting critical
               sections) will be the same regardless of the specific
               implementation. To learn more about pthreads specifically, we
               recommend <xref linkend="ref.pthreads.programming" />.</para>
            </caution>

            <para>Device driver authors will probably not have to do much with
            shared data access control because the driver will operate almost
            entirely in the sample loop thread. Any other method invocations
            (starting the driver, stopping it, configuring it, etc.) will
            happen in the Input Manager thread, and common memory accesses
            have pre-defined helper methods to simplify the work of driver
            authors. These details will be explained further in later
            chapters.</para>
         </section>

         <section>
            <title>Programmer Reference</title>

            <indexterm>
               <primary>VPR</primary>

               <secondary>programmer reference</secondary>
            </indexterm>

            <para>The various VPR abstraction interfaces are documented
            extensively, and readers are encouraged to review the VPR
            Programmer Reference (refer to <ulink
            url="http://www.vrjuggler.org/vapor/">the VPR website</ulink> for
            more information).</para>

            <para>The VPR class names follow a standard convention, and
            understanding this can be helpful in navigating the API
            documentation. Classes that wrap platform-specific interfaces are
            named as follows:
            <classname>vpr::&lt;Type&gt;&lt;Platform&gt;</classname>. For
            example, the NSPR implementation of
            <classname>vpr::SocketStream</classname> is named
            <classname>vpr::SocketStreamNSPR</classname>. Here, &lt;Type&gt;
            is <quote>SocketStream</quote>, and &lt;Platform&gt; is
            <quote>NSPR</quote>. The full list of platform names (as spelled
            in the class names) is as follows:</para>

            <itemizedlist>
               <listitem>
                  <para>Posix: Used for general POSIX-specified
                  interfaces</para>
               </listitem>

               <listitem>
                  <para>BSD: Used for the BSD socket wrapper classes</para>
               </listitem>

               <listitem>
                  <para>Termios: Used for the termios serial port wrapper
                  classes</para>
               </listitem>

               <listitem>
                  <para>NSPR: Used for NSPR wrapper classes</para>
               </listitem>

               <listitem>
                  <para>SPROC: Used for the SPROC thread wrapper class</para>
               </listitem>

               <listitem>
                  <para>Win32: Used for Win32-specific wrapper classes</para>
               </listitem>
            </itemizedlist>
         </section>
      </chapter>
   </part>

   <part>
      <title>Programming</title>

      <partintro>
         <para>In this part of the book, we explain how to write device
         drivers and add them to Gadgeteer. We begin with a detailed
         description of device driver conventions in Gadgeteer and how the
         drivers fit into the Input Manager. We then explain how drivers are
         configured using JCCL. Throughout the following chapters, example
         code will be provided.</para>
      </partintro>

      <chapter>
         <title>Drivers and the Input Manager</title>

         <para>As its name suggests, the Input Manager is in charge of
         managing the active input devices and the samples those devices
         return. Each device driver will hand off a freshly read sample (also
         known as a sample buffer) to the Input Manager.</para>

         <section>
            <title>Drivers as Input Manager Plug-Ins</title>

            <indexterm>
               <primary>device drivers</primary>

               <secondary>plug-ins</secondary>
            </indexterm>

            <para>The Input Manager itself never cares about the true type of
            a device. Instead, it looks at each driver as an implementation of
            the <interfacename>gadget::Input</interfacename><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::Input</secondary>
               </indexterm> interface. This design lends itself well to a
            plug-in architecture wherein drivers can be loaded at runtime
            without being compiled into Gadgeteer. Using the Gadgeteer driver
            plug-in system, users can write their own device drivers without
            modifying Gadgeteer at all. Indeed, they need not even compile
            Gadgeteer from its source. All that is needed is a binary
            installation of Gadgeteer against which the user-written driver
            can be compiled.</para>
         </section>

         <section id="device.types.section">
            <title>Device Types</title>

            <indexterm>
               <primary>device types</primary>
            </indexterm>

            <para>As of this writing, there are five key device types handled
            by the Input Manager:</para>

            <orderedlist>
               <listitem>
                  <para>Analog:
                  <classname>gadget::Analog</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::Position</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para>Command:
                  <classname>gadget::Command</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::Command</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para>Digital:
                  <classname>gadget::Digital</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::Digital</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para>Glove: <classname>gadget::Glove</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::Glove</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para>Position:
                  <classname>gadget::Position</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::Position</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para>String:
                  <classname>gadget::String</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::String</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para>Simulator:
                  <classname>gadget::SimInput</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::SimInput</secondary>
                     </indexterm>,
                  <classname>gadget::SimPosition</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::SimPosition</secondary>
                     </indexterm>,
                  <classname>gadget::SimDigital</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::SimDigital</secondary>
                     </indexterm>,
                  <classname>gadget::SimAnalog</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::SimAnalog</secondary>
                     </indexterm>,
                  <classname>gadget::SimGlove</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::SimGlove</secondary>
                     </indexterm></para>
               </listitem>
            </orderedlist>

            <section>
               <title>Analog</title>

               <indexterm>
                  <primary>device types</primary>

                  <secondary>analog</secondary>
               </indexterm>

               <para>Analog input represents a continuous range of values. Of
               course, with digital computers, analog values can only be
               simulated. In Gadgeteer, this simulation is performed using
               floating-point values.</para>

               <para>At the application level, programmers get values from an
               analog device in the range 0.0 to 1.0 inclusive. In other
               words, values returned by an analog device are normalized
               before they are returned to the application. This allows
               applications to get analog input from a variety of analog
               devices without depending on a specific range of values
               returned by any given device.</para>
            </section>

            <section>
               <title>Command</title>

               <indexterm>
                  <primary>device types</primary>

                  <secondary>command</secondary>
               </indexterm>

               <para></para>
            </section>

            <section>
               <title>Digital</title>

               <indexterm>
                  <primary>device types</primary>

                  <secondary>digital</secondary>
               </indexterm>

               <para>Digital input comes in discrete forms, as its name
               suggests. However, a digital device in Gadgeteer terms
               corresponds most closely with a button device that has an
               <quote>on</quote> state and an <quote>off</quote> state. In
               that regard, a more appropriate name for a digital device
               within Gadgeteer would be a Boolean device, except that
               Gadgeteer provides more than just two values for input from a
               digital device. Due to its frame-based nature, Gadgeteer can
               tell users when the state of a digital device has changed since
               the last frame, thereby allowing for up to four values to be
               returned from a digital device:</para>

               <orderedlist>
                  <listitem>
                     <para>On: The device is in the on state.</para>
                  </listitem>

                  <listitem>
                     <para>Off: The device is in the off state.</para>
                  </listitem>

                  <listitem>
                     <para>Toggle on: The device was in the off state during
                     the last frame and changed to the on state this
                     frame.</para>
                  </listitem>

                  <listitem>
                     <para>Toggle off: The device was in the on state during
                     the last frame and changed to the off state this
                     frame.</para>
                  </listitem>
               </orderedlist>

               <para>The management of the toggle states is handled by
               Gadgeteer; devices simply need to collect the raw on and off
               values.</para>
            </section>

            <section>
               <title>Gesture</title>

               <indexterm>
                  <primary>device types</primary>

                  <secondary>gesture</secondary>
               </indexterm>

               <para></para>
            </section>

            <section>
               <title>Glove</title>

               <indexterm>
                  <primary>device types</primary>

                  <secondary>glove</secondary>
               </indexterm>

               <para></para>
            </section>

            <section>
               <title>Position</title>

               <indexterm>
                  <primary>device types</primary>

                  <secondary>position</secondary>
               </indexterm>

               <para>Positional input is usually collected from a
               six-degree-of-freedom (6DOF) tracker such as a Polhemus Fastrak
               or an Ascension MotionStar. Thus, position devices in Gadgeteer
               return samples as standard 4Ã—4 transformation matrices
               representing the position and orientation of a specific
               tracker. A tracker may not be able to track all six degrees of
               freedom, and this is allowed with the Gadgeteer position input
               type.</para>
            </section>

            <section>
               <title>Simulator</title>

               <indexterm>
                  <primary>device types</primary>

                  <secondary>simulator</secondary>
               </indexterm>

               <para>For each of the above, there is at least one
               corresponding simulator device type<footnote>
                     <para>Gadgeteer is designed so that users may write new
                     simulator devices. In fact, we encourage this so that we
                     can expand on the ways that various input types may be
                     <quote>simulated</quote> for desktop use.</para>
                  </footnote>. Such a device stands in for the corresponding
               <quote>real</quote> device when one is not available. For
               example, when using a VR application on the desktop, a 6DOF
               position tracker is not usually available. Instead, the mouse
               and keyboard could be used to stand in for the 6DOF tracker.
               Alternatively, a 3D graphical user interface (GUI) could be
               written using GLUT to provide a more visually expressive
               desktop tracker stand-in.</para>

               <para>The word <quote>simulator</quote> is a bit of a misnomer.
               As noted above, these devices act more as stand-ins when
               another device is not available. To a VR application, the data
               returned will look exactly the same, but the input mechanism
               employed by the user will vary.</para>
            </section>

            <section>
               <title>String</title>

               <indexterm>
                  <primary>device types</primary>

                  <secondary>string</secondary>
               </indexterm>

               <para></para>
            </section>
         </section>

         <section>
            <title>The Input Mixer</title>

            <indexterm>
               <primary>input mixer</primary>
            </indexterm>

            <indexterm>
               <primary>classes</primary>

               <secondary>gadget::InputMixer&lt;S,T&gt;</secondary>
            </indexterm>

            <para>The second version of the Remote Input Manager<indexterm>
                  <primary>Remote Input Manager</primary>
               </indexterm>, introduced in mid-2002, implemented input
            distribution by sharing devices rather than proxies, as done in
            the original version <xref linkend="ref.eolson.thesis" />. This
            refactoring has changed the class hierarchy for device drivers.
            Previously, classes such as
            <classname>gadget::Digital</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::Digital</secondary>
               </indexterm> and
            <classname>gadget::Position</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::Position</secondary>
               </indexterm> derived from
            <classname>gadget::Input</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::Input</secondary>
               </indexterm>, and device drivers used multiple inheritance to
            derive from one or more of
            <classname>gadget::Analog</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::Analog</secondary>
               </indexterm>, <classname>gadget::Digital</classname>,
            etc.</para>

            <para>With the introduction of
            <classname>gadget::InputMixer&lt;S,T&gt;</classname>, device
            drivers now derive from this single template class. More
            information will be given in <xref
            linkend="add.dev.driver.chapter" />, but as an example, consider a
            driver for a positional device. In VR Juggler 1.0 and in early
            versions of Gadgeteer, such a driver class would have derived from
            <classname>gadget::Position</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::Position</secondary>
               </indexterm>. Now, it would derive from
            <classname>gadget::InputMixer&lt;gadget::Input,
            gadget::Position&gt;</classname>. Use of
            <classname>gadget::InputMixer&lt;S,T&gt;</classname> is required
            if a device is to be used with the Remote Input Manager. If the
            old class hierarchy is used (which is still allowed), the device
            cannot be shared between computers.</para>

            <para>When deriving from
            <classname>gadget::InputMixer&lt;S,T&gt;</classname>, it is highly
            recommended that one of the predefined instantiations be used to
            ensure that a known type is used as a base class for the device
            driver. The order that the classes are listed in the
            <classname>gadget::InputMixer&lt;S,T&gt;</classname> is critical
            because the Remote Input Manager only knows about certain
            instantiations. If an unexpected instantiation is encountered,
            problems will occur. In the best case, the device data will not be
            shared in a cluster configuration. In the worst case, the
            application will crash. The known instantiations are all listed in
            the file <filename>gadget/Type/InputBaseTypes.h</filename>.</para>

            <caution>
               <para>The Input Mixer may not be a long-term solution, though
               it has been in place for quite a while. A future version of
               Gadgeteer may do away with
               <classname>gadget::InputMixer&lt;S,T&gt;</classname>, and as
               such, driver authors should be aware of potential API changes
               in the future.</para>
            </caution>
         </section>
      </chapter>

      <chapter id="driver.conventions.chapter">
         <title>Device Driver Conventions</title>

         <para>Before we get into the actual coding process, we must first
         explain the conventions we have used in writing device drivers for
         Gadgeteer. We strongly recommend that all new drivers follow these
         conventions as they have proven successful for us for many
         years.</para>

         <section>
            <title>Separation of Code</title>

            <para>The most obvious convention that can be seen upon review of
            existing device drivers is a separation of the driver code into
            two pieces: a standalone, <quote>low-level</quote> driver and a
            Gadgeteer wrapper around the standalone driver.</para>

            <para>In this design, the standalone driver implements the
            complete hardware communication protocol without using any
            features of Gadgeteer. As such, it stands completely on its own
            and does not need Gadgeteer to be used. The result is that the
            driver can be tested and debugged without worrying that some part
            of Gadgeteer could be causing the driver to malfunction. Driver
            authors can focus entirely on implementing the hardware
            communication protocol so as to feel confident that the low-level
            driver is implemented correctly.</para>

            <note>
               <para>The standalone driver should use VPR to ensure
               portability. For example, a driver that will communicate with
               the hardware via the serial port should use the VPR serial port
               abstraction. For more information, refer to <xref
               linkend="vpr.chapter" /> and to <xref
               linkend="driver.goals.section" />.</para>
            </note>

            <tip>
               <para>The low-level driver should have an easy-to-use interface
               that allows effective manipulation of the driver state
               (starting, stopping, requesting a sample, etc.). To develop a
               good interface and to test the standalone driver, write an
               application that creates an instance of the standalone driver,
               starts the driver running, and collects samples. In writing the
               test application, the interface can be matured for use by the
               Gadgeteer wrapper.</para>
            </tip>

            <para>Around the low-level driver, a Gadgeteer wrapper is added.
            This wrapper makes use of the standalone driver interface to
            activate the driver and read samples. The wrapper class will
            derive from one or more of the Gadgeteer device types described in
            <xref linkend="device.types.section" />. Instances of the wrapper
            class will be handled by the Input Manager.</para>

            <tip>
               <para>Do not put a sample loop in the low-level driver.
               Instead, provide a <methodname>sample()</methodname> method in
               the standalone driver API that the wrapper can call repeatedly.
               This allows the sample thread to be managed by the Gadgeteer
               wrapper class.</para>
            </tip>
         </section>
      </chapter>

      <chapter id="add.dev.driver.chapter">
         <title>Writing Device Drivers</title>

         <indexterm>
            <primary>device drivers</primary>

            <secondary>writing</secondary>
         </indexterm>

         <para>At long last, we have covered enough background information to
         explain how to add device drivers to Gadgeteer. In this chapter, we
         will examine a very simple device that has an on state and an off
         state. The general flow of this chapter will model the process that
         driver programmers would normally follow when writing a new driver
         from scratch.</para>

         <section>
            <title>Identifying the Device Type</title>

            <indexterm>
               <primary>device drivers</primary>

               <secondary>implementing</secondary>

               <tertiary>identifying device type</tertiary>
            </indexterm>

            <para>As discussed in <xref linkend="device.types.section" />,
            there are a set of abstract device types supported by Gadgeteer.
            Based on its capabilities, a new device will fall into at least
            one of the device type categories. It is perfectly valid for a
            single device to provide more than one type of input. For example,
            an Immersion Tech IBox returns both analog and digital data.
            Determining the device type for a new piece of hardware should be
            the easiest part of the driver authoring process.</para>
         </section>

         <section>
            <title>Implementing the Standalone Device Driver</title>

            <indexterm>
               <primary>device drivers</primary>

               <secondary>implementing</secondary>

               <tertiary>standalone driver</tertiary>
            </indexterm>

            <para>The standalone device driver makes use of
            <emphasis>nothing</emphasis> in Gadgeteer. It can utilize
            dependencies of Gadgeteer including VPR and GMTL, however. Reusing
            code from those projects is encouraged. In particular, writing the
            driver on top of VPR allows it to be much more portable than it
            would be if all the cross-platform code were written from scratch.
            The reason that the standalone driver does not use Gadgeteer is so
            that it can be tested without needing any of the complexity of the
            Input Manager, thereby allowing easier, more direct
            debugging.</para>

            <para>In most cases the standalone driver should be an
            implementation of the hardware communication protocol and nothing
            more. The standalone driver is written as a single C++ class that
            provides an interface that the Gadgeteer wrapper class can call.
            The interface normally has methods such as
            <methodname>open()</methodname>,
            <methodname>sample()</methodname>, and
            <methodname>close()</methodname> for opening the connection to the
            hardware, collecting a single sample, and closing the connection
            to the hardware respectively.</para>

            <para>The standalone driver class should return data it is most
            raw form in the majority of cases, but the data should be
            meaningful. For example, if logic is needed to convert four bytes
            read from the hardware into a single floating-point value (a
            <type>float</type>), that should be performed in the standalone
            driver. That sort of data processing is part of implementing the
            communication protocol. However, processing such as unit
            conversion should not be done in the standalone driver in most
            cases. Instead, such conversions should be handled by the
            Gadgeteer wrapper class since that is where the unit configuration
            is done.</para>

            <para>Typically, the standalone driver will not be multi-threaded.
            Instead, a method with a name such as
            <methodname>sample()</methodname> should be provided that returns
            a single sample. Then, test code and the Gadgeteer wrapper class
            can call the sampling method in a loop which may or may not be run
            in a thread.</para>

            <para>With this design, the standalone driver class can be tested
            by writing a simple console application that makes an instance of
            the class and invokes each of the methods. The application can be
            interactive so that users can configure aspects of the driver and
            take samples. This makes debugging and data validation
            easy.</para>
         </section>

         <section>
            <title>Implementing the Gadgeteer Wrapper Class</title>

            <indexterm>
               <primary>device drivers</primary>

               <secondary>implementing</secondary>

               <tertiary>Gadgeteer wrapper class</tertiary>
            </indexterm>

            <para>The Gadgeteer wrapper class has the job of passing samples
            read from the standalone driver off to the Input Manager.
            Depending on the device type, a given sample must be of a certain
            form. This is where sample buffers come into play. We will discuss
            sample buffers later in this section, but the possible sample
            buffer types are the following:</para>

            <itemizedlist>
               <listitem>
                  <para><classname>gadget::AnalogData</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::AnalogData</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para><classname>gadget::CommandData</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::CommandData</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para><classname>gadget::DigitalData</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::DigitalData</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para><classname>gadget::GloveData</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::GloveData</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para><classname>gadget::PositionData</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::PositionData</secondary>
                     </indexterm></para>
               </listitem>

               <listitem>
                  <para><classname>gadget::StringData</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::StringData</secondary>
                     </indexterm></para>
               </listitem>
            </itemizedlist>

            <section>
               <title>Choose the Base Class(es)</title>

               <para>As discussed earlier in <xref
               linkend="device.types.section" />, all device drivers in
               Gadgeteer must derive from one or more classes based on the
               device type. If a driver is to be used with the Remote Input
               Manager (i.e., there exists a desire to share a device between
               two or more computers), then the base class must be
               <classname>gadget::InputMixer&lt;S,T&gt;</classname> with
               appropriate device type classes given as the template
               parameters. If, for whatever reason, the device will not be
               used with the Remote Input Manager, it may derive from one or
               more of the device type classes directly using multiple
               inheritance.</para>

               <para>For example, to make a driver that registers button
               presses, derive from
               <classname>gadget::input_digital_t</classname> (the
               <classname>gadget::InputMixer&lt;S,T&gt;</classname>
               instantiation that includes only
               <classname>gadget::Digital</classname>):</para>

               <programlisting>class ButtonDevice
   : public gadget::input_digital_t</programlisting>

               <para>Suppose that a game controller driver supporting buttons
               and joystick axes is needed. In this case, an additional
               component is needed for the for analog input from the X and Y
               axes. Since the device is both digital and analog, its class
               must derive from both <classname>gadget::Digital</classname>
               and <classname>gadget::Analog</classname> using the appropriate
               <classname>gadget::InputMixer&lt;S,T&gt;</classname>
               instantiation:</para>

               <programlisting>class JoystickDevice
   : public gadget::input_digital_analog_t</programlisting>

               <para>Using the type <classname>ButtonDevice</classname> as
               declared above, we will proceed with the implementation of the
               driver class. There are six member functions that must be
               implemented by every driver class:</para>

               <orderedlist>
                  <listitem>
                     <para><methodname>startSampling()</methodname>: A pure
                     virtual member function declared by
                     <classname>gadget::Input</classname></para>
                  </listitem>

                  <listitem>
                     <para><methodname>stopSampling()</methodname>: A pure
                     virtual member function declared by
                     <classname>gadget::Input</classname></para>
                  </listitem>

                  <listitem>
                     <para><methodname>sample()</methodname>: A pure virtual
                     member function declared by
                     <classname>gadget::Input</classname></para>
                  </listitem>

                  <listitem>
                     <para><methodname>updateData()</methodname>: A pure
                     virtual member function declared by
                     <classname>gadget::Input</classname></para>
                  </listitem>

                  <listitem>
                     <para><methodname>getElementType()</methodname>: A static
                     member function</para>
                  </listitem>

                  <listitem>
                     <para><methodname>config()</methodname>: A virtual member
                     function declared by
                     <classname>gadget::Input</classname>,
                     <classname>gadget::Analog</classname>,
                     <classname>gadget::Digital</classname>, etc., that must
                     be overridden</para>
                  </listitem>
               </orderedlist>

               <para>In this section, we will examine the first four of these.
               The remaining two will be addressed in <xref
               linkend="section.driver.config.methods" />.</para>

               <section>
                  <title><methodname>startSampling()</methodname></title>

                  <highlights>
                     <itemizedlist>
                        <listitem>
                           <para>Method synopsis: <methodsynopsis>
                                 <modifier>virtual</modifier>

                                 <type>bool</type>

                                 <methodname>startSampling</methodname>

                                 <void />
                              </methodsynopsis></para>
                        </listitem>

                        <listitem>
                           <para>Overrides the pure virtual function
                           <methodname>gadget::Input::startSampling()</methodname>
                           declared in
                           <filename>gadget/Type/Input.h</filename></para>
                        </listitem>
                     </itemizedlist>
                  </highlights>

                  <para>Within this function, a new thread is started. This
                  thread is used to sample the data from the device. There are
                  two ways to create threads using
                  <classname>vpr::Thread</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>vpr::Thread</secondary>
                     </indexterm>. The first uses a non-member function or a
                  static member function. The second uses a non-static member
                  function. To spawn a thread that executes a non-member
                  function or a static member function, the code would be
                  similar to that shown in <xref
                  linkend="example.thread.nonmember.func" /> and <xref
                  linkend="example.thread.static.member.func" /> respectively.
                  To spawn a thread that executes a member function, the code
                  would be similar to that shown in <xref
                  linkend="example.thread.member.func" />. The thread can be
                  tested for validity using the method
                  <methodname>vpr::Thread::valid()</methodname>. For a
                  complete description of how to use the cross-platform
                  multi-threading capabilities of the VR Juggler Portable
                  Runtime, refer to the <ulink
                  url="http://www.vrjuggler.org/vapor/docs.php">VPR
                  <emphasis>Programmer's Guide</emphasis></ulink>.</para>

                  <example id="example.thread.nonmember.func">
                     <title>Spawning a Non-Member Function Thread</title>

                     <programlisting>namespace
{

void nonMemberSampleFunction(ButtonDevice* devPtr)
{
   // Keep working until isRunning() returns false.
   while ( devPtr-&gt;isRunning() )
   {
      devPtr-&gt;sample();
   }
}

}

bool ButtonDevice::startSampling()
{
   mRunning = true;
   mThread = new vpr::Thread(boost::bind(nonMemberSampleFunction, this));
   return true;
}</programlisting>
                  </example>

                  <example id="example.thread.static.member.func">
                     <title>Spawning a Static Member Function Thread</title>

                     <programlisting>class ButtonDevice : public ...
{
public:
   ...
   bool startSampling();
   bool sample();

private:
   static void staticMemberSampleFunction(ButtonDevice* devPtr);
   ...
};

bool ButtonDevice::startSampling()
{
   mRunning = true;
   mThread =
      new vpr::Thread(boost::bind(ButtonDevice::staticMemberSampleFunction,
                                  this));
   return true;
}

void ButtonDevice::staticMemberSampleFunction(void* arg)
{
   ButtonDevice* dev_ptr = static_cast&lt;ButtonDevice*&gt;(arg);

   // Keep working until mRunning becomes false.
   while ( dev_ptr-&gt;mRunning )
   {
      dev_ptr-&gt;sample();
   }
}</programlisting>
                  </example>

                  <example id="example.thread.member.func">
                     <title>Spawning a Member Function Thread</title>

                     <programlisting>bool ButtonDevice::startSampling()
{
   mRunning = true;
   mThread =
      new vpr::Thread(boost::bind(&amp;ButtonDevice::memberSampleFunction, this);
   return true;
}

void ButtonDevice::memberSampleFunction()
{
   // Keep working until mRunning becomes false.
   while ( mRunning )
   {
      this-&gt;sample();
   }
}</programlisting>
                  </example>

                  <tip>
                     <para>Using a thread for the sample loop is not always
                     necessary or appropriate. It is most useful for the case
                     of a device protocol implementation that relies on
                     blocking I/O. Such a device could cause the Input Manager
                     to block when querying the latest sample, and this would
                     impact the application frame rate. For drivers that can
                     read data at any time without blocking, simply taking a
                     sample in the implementation of
                     <methodname>updateData()</methodname> is sufficient. The
                     decision to use a thread or not depends very much on the
                     specific hardware communication protocol, and driver
                     authors must take this into consideration on a per-driver
                     basis.</para>
                  </tip>

                  <caution>
                     <para>In certain cases, it is highly desirable to avoid
                     using a thread. For example, devices that return sample
                     data immediately would collect many, many samples that
                     would have to be shared among cluster nodes every frame.
                     The burden on the network could have a negative impact on
                     the performance of the cluster. The driver we are
                     examining in this section is a good example of a driver
                     that should <emphasis>not</emphasis> use a thread because
                     it does not block while waiting for hardware to return a
                     sample. Nevertheless, we illustrate the use of a thread
                     so that readers can see how it works.</para>
                  </caution>
               </section>

               <section>
                  <title><methodname>stopSampling()</methodname></title>

                  <highlights>
                     <itemizedlist>
                        <listitem>
                           <para>Method synopsis: <methodsynopsis>
                                 <modifier>virtual</modifier>

                                 <type>bool</type>

                                 <methodname>stopSampling</methodname>

                                 <void />
                              </methodsynopsis></para>
                        </listitem>

                        <listitem>
                           <para>Overrides the pure virtual function
                           <methodname>gadget::Input::stopSampling()</methodname>
                           declared in
                           <filename>gadget/Type/Input.h</filename></para>
                        </listitem>
                     </itemizedlist>
                  </highlights>

                  <para>The job of this function is to kill the thread created
                  in <methodname>startSampling()</methodname> and release
                  resources such as open file handles. If no thread was
                  created, then this method only needs to release any open
                  resources. Remember that
                  <methodname>startSampling()</methodname> could be called
                  again later, so drivers must be written to handle the case
                  where they are shut down and restarted.</para>
               </section>

               <section>
                  <title><methodname>sample()</methodname></title>

                  <highlights>
                     <itemizedlist>
                        <listitem>
                           <para>Method synopsis: <methodsynopsis>
                                 <modifier>virtual</modifier>

                                 <type>bool</type>

                                 <methodname>sample</methodname>

                                 <void />
                              </methodsynopsis></para>
                        </listitem>

                        <listitem>
                           <para>Overrides the pure virtual function
                           <methodname>gadget::Input::sample()</methodname>
                           declared in
                           <filename>gadget/Type/Input.h</filename></para>
                        </listitem>
                     </itemizedlist>
                  </highlights>

                  <para>This method reads data from the device and stores it
                  for later use by
                  <methodname>gadget::Digital::getDigitalData()</methodname>.
                  Note that
                  <methodname>ButtonDevice::sampleFunction()</methodname>,
                  defined above, invokes this method. It is the responsibility
                  of the driver itself to call
                  <methodname>sample()</methodname>, and therefore, its
                  implementation may be empty depending on how the driver is
                  designed.</para>

                  <para>Gadgeteer devices typically use triple-buffered data
                  management. This is done to ensure that data is not being
                  written into a buffer when the Input Manager is trying to
                  read the most recent value. The various base classes for
                  device types provide helper methods for handling
                  triple-buffered data. This is a big help over VR Juggler 1.0
                  and early versions of VR Juggler 1.1 where the
                  triple-buffering had to be managed manually in every
                  driver.</para>

                  <para>We are not actually implementing a hardware protocol,
                  so we simply use dummy values as the sample buffers. For
                  this, we use the protected base class method
                  <methodname>gadget::Digital::addDigitalSample()</methodname>.
                  Note that this method expects a
                  <classname>std::vector&lt;T&gt;</classname> containing
                  sample buffers as its parameter. In our case, we will have
                  one sample buffer in the vector, as shown below:</para>

                  <example>
                     <title>Implementation of
                     <methodname>sample()</methodname> Member Function</title>

                     <programlisting>bool ButtonDevice::sample()
{
   bool status(false);

   if ( mRunning )
   {
      // Here you would add your code to sample the hardware for a
      // button press:
      std::vector&lt;gadget::DigitalData&gt; digital_samples(1);
      digital_samples[0] = 1;
      addDigitalSample(digital_samples);

      // Successful sample.
      status = true;
   }

   return status;
}</programlisting>
                  </example>

                  <para>For a device driver that supports multiple data types,
                  there are additional inherited helper methods such as
                  <methodname>gadget::Position::addPositionSample()</methodname>,
                  <methodname>gadget::Analog::addAnalogSample()</methodname>,
                  etc. Refer to the Gadgeteer Programmer Reference for
                  complete details about the class declarations.</para>
               </section>

               <section>
                  <title><methodname>updateData()</methodname></title>

                  <highlights>
                     <itemizedlist>
                        <listitem>
                           <para>Method synopsis: <methodsynopsis>
                                 <modifier>virtual</modifier>

                                 <void />

                                 <methodname>updateData</methodname>

                                 <void />
                              </methodsynopsis></para>
                        </listitem>

                        <listitem>
                           <para>Overrides the pure virtual function
                           <methodname>gadget::Input::updateData()</methodname>
                           declared in
                           <filename>gadget/Type/Input.h</filename></para>
                        </listitem>
                     </itemizedlist>
                  </highlights>

                  <para>This method is invoked by the Input Manager once per
                  frame for each active device to prepare the latest input
                  data for use by higher level code such as a VR Juggler
                  application object. Again, we can use a helper function
                  inherited from
                  <classname>gadget::Digital</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::Digital</secondary>
                     </indexterm> to perform this operation. As usual, there
                  are similar helper functions that would be inherited from
                  the other device types if our driver supported multiple
                  types of input data.</para>

                  <example>
                     <title>Implementation of
                     <methodname>updateData()</methodname> Member
                     Function</title>

                     <programlisting>void ButtonDevice::updateData()
{
   if ( mRunning )
   {
      swapDigitalBuffers();
   }
}</programlisting>
                  </example>

                  <note>
                     <para>As mentioned above, some drivers may perform their
                     entire sample operation in their override of
                     <methodname>gadget::Input::updateData()</methodname>.
                     This driver would be a good candidate for that use of the
                     <methodname>updateData()</methodname> method. Instead of
                     building up a large number of sample buffers in a
                     separate thread, our sample could be taken here. This
                     would be accomplished by combining the implementations of
                     <methodname>ButtonDevice::sample()</methodname> and
                     <methodname>ButtonDevice::updateData()</methodname> into
                     this method, thereby leaving
                     <methodname>ButtonDevice::sample()</methodname>
                     empty.</para>
                  </note>
               </section>
            </section>

            <section>
               <title>Driver Plug-in Entry Points</title>

               <para>All the device drivers that can be loaded at run time by
               the Input Manager have what are known as <firstterm>entry point
               functions</firstterm>. These are free functions with C-style
               signatures that may be looked up at run time using operating
               system features. In Gadgeteer 1.0, every driver plug-in must
               include two exported functions:
               <function>getGadgeteerVersion()</function> and
               <function>initDevice()</function>. The first is used for simple
               version checking, and the second registers the driver with the
               Input Manager.</para>

               <sidebar>
                  <para>For Windows programmers, these are the only two
                  symbols that must be exported from the driver DLL. The
                  device driver class or classes do not have to exported from
                  the DLL.</para>
               </sidebar>

               <section>
                  <title>Driver Version Checking</title>

                  <para>As of the release of Gadgeteer 1.0 Beta 1, all driver
                  plug-ins must have an entry point function that allows the
                  Input Manager to perform version checking. This is done to
                  ensure that the driver is compatible with the Input Manager.
                  The implementation of this function will be the same for all
                  drivers, and it is shown in <xref
                  linkend="example.getGadgeteerVersion" />. Because we are
                  dealing with C++ code, we must indicate to the compiler that
                  this is a C-style function, so no name mangling should occur
                  when its symbol table entry is created. We do this by
                  wrapping the function body in an <literal>extern
                  "C"</literal> block. For cross-platform plug-in
                  capabilities, we use the
                  <symbol>GADGET_DRIVER_EXPORT()</symbol> macro. On Win32
                  systems, this will add the appropriate type modifiers to
                  declare <function>initDevice()</function> as a function
                  exported by the DLL that will be compiled. For other
                  platforms, the macro simply evaluates to the
                  <type>void</type> type. (These details are handled within
                  the <filename>gadget/Devices/DriverConfig.h</filename>
                  header.)</para>

                  <example id="example.getGadgeteerVersion">
                     <title>Implementation of
                     <function>getGadgeteerVersion()</function> Entry Point
                     Function</title>

                     <programlisting>#include &lt;gadget/Devices/DriverConfig.h&gt;
#include &lt;vpr/vpr.h&gt;
#include &lt;gadget/gadgetParam.h&gt;

extern "C"
{

GADGET_DRIVER_EXPORT(vpr::Uint32) getGadgeteerVersion()
{
   return __GADGET_version;
}

}</programlisting>
                  </example>

                  <para>The result of this implementation is that the
                  Gadgeteer version number is compiled into the driver
                  plug-in. At run time, the Input Manager compares this value
                  with the version of the Gadgeteer library. If the two match
                  exactly, the driver loading process continues. If not, the
                  driver plug-in is ignored.</para>

                  <sidebar>
                     <para>This form of version compatibility testing is
                     rudimentary, but because the Juggler libraries do not
                     guarantee binary compatibility between releases, it is
                     necessary. In the future, a more sophisticated version
                     comparison system may be devised for driver plug-ins.
                     Presently, it is already possible to get the individual
                     version numbers of the Gadgeteer library (major, minor,
                     and patch), and these could be used as the foundation for
                     a more advanced compatibility management system.</para>
                  </sidebar>
               </section>

               <section>
                  <title>Register the Driver with the Input Manager</title>

                  <indexterm>
                     <primary>device drivers</primary>

                     <secondary>registering</secondary>
                  </indexterm>

                  <para>Device driver registration is done through a template
                  type called
                  <classname>gadget::DeviceConstructor&lt;T&gt;</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::DeviceConstructor&lt;T&gt;</secondary>
                     </indexterm>. When this type is used with a special
                  <quote>factory function</quote> called
                  <function>initDevice()</function>, the driver can be used as
                  a plug-in to the Input Manager. While there are some drivers
                  that cannot currently be loaded dynamically, those that can
                  include an entry point function named
                  <function>initDevice()</function>.</para>

                  <para>With all of that, we can now write the body for
                  <function>initDevice()</function>. No declaration in a
                  header file is needed because this function will be looked
                  up dynamically at run time. The implementation of
                  <function>initDevice()</function> will appear in
                  <filename>ButtonDevice.cpp</filename> as follows:</para>

                  <example>
                     <title>Implementation of
                     <function>initDevice()</function> Entry Point
                     Function</title>

                     <programlisting>#include &lt;gadget/Devices/DriverConfig.h&gt;
#include &lt;gadget/Type/DeviceConstructor.h&gt;
#include "ButtonDevice.h"

extern "C"
{

GADGET_DRIVER_EXPORT(void) initDevice(gadget::InputManager* inputMgr)
{
   new gadget::DeviceConstructor&lt;ButtonDevice&gt;(inputMgr);
}

}</programlisting>
                  </example>
               </section>
            </section>
         </section>
      </chapter>

      <chapter>
         <title>Compiling the Driver Plug-in</title>

         <para>At this point, our device driver is not yet complete because it
         cannot be configured. Nevertheless, there will be nothing for the
         Input Manager to loadâ€”and hence no driver to configureâ€”until we are
         able to compile the driver plug-in. In this chapter, we explain how
         to compile the driver as a dynamically loadable component. We present
         this from the perspective of a driver that exists outside the
         Gadgeteer driver source tree. For drivers that are integrated into
         the Gadgeteer driver source tree, refer to <xref
         linkend="makefile.templates.section" />.</para>

         <para>The device driver must be compiled into a standalone
         dynamically loadable component. The usual file extension names for
         plug-ins are<filename>.so</filename>, <filename>.dll</filename>, or
         <filename>.dylib</filename> depending on the host operating system.
         This component will act as the Input Manager plug-in. In this way,
         there is no need to modify the Gadgeteer source code to add a new
         driver. Thus, the driver code is collected into a cohesive unit that
         can be distributed as a plug-in for Gadgeteer.</para>

         <para>Compiling device driver plug-ins for use with Gadgeteer is a
         relatively simple process that can use either GNU Make or a Visual
         C++ project file. To compile a driver plug-in on Windows, a Visual
         C++ project file must be used; using GNU Make on Windows is not
         supported by Gadgeteer 1.0.</para>

         <para>In either case, the name of the compiled driver plug-in must
         follow certain conventions. A debug version of the driver must be
         named as <filename>&lt;device&gt;_drv_d.&lt;ext&gt;</filename>. Here,
         <filename>&lt;device&gt;</filename> provides a meaningful, unique
         name for the driver plug-in, and <filename>&lt;ext&gt;</filename> is
         the platform-specific file extension for plug-ins. The
         <filename>_d</filename> part indicates that the driver is
         debug-enabled and on Windows that it is linked against the Visual C++
         debug runtime. Examples are <filename>IS900_drv_d.so</filename> and
         <filename>MotionStar_drv_d.dll</filename>. On Mac OS X, the extension
         <filename>.dylib</filename> is used rather than
         <filename>.bundle</filename>. An optimized (<quote>release</quote> in
         Visual C++ terminology) version of the driver uses the same
         convention but drops the <filename>_d</filename> part.</para>

         <para>When using GNU Make, a very short makefile is all that is
         required. An example for our button driver is shown in <xref
         linkend="example.driver.makefile" />. The makefile allows either a
         debug or an optimized version of the driver to be compiled depending
         on the value assigned to the <varname>$(BUILD_TYPE)</varname>
         variable. The <varname>$(SRCS)</varname> variable must contain the
         complete list of source files for the driver plug-in. The file
         extensions <filename>.c</filename>, <filename>.C</filename>,
         <filename>.CC</filename>, <filename>.cc</filename>,
         <filename>.cxx</filename>, <filename>.cpp</filename>, and
         <filename>.c++</filename> are recognized. The environment variable
         <envar>GADGET_BASE_DIR</envar> must be set for use by this makefile.
         It would usually be set to the same value as
         <envar>VJ_BASE_DIR</envar>.</para>

         <example id="example.driver.makefile">
            <title>Example Makefile for Device Driver Plug-in</title>

            <programlisting>srcdir=         .
BUILD_TYPE=     dbg
#BUILD_TYPE=    opt

DRIVER_NAME=    button
SRCS=           buttondevice.cpp

include $(GADGET_BASE_DIR)/share/gadgeteer/gadget.driver.mk</programlisting>
         </example>

         <para>To use a Visual C++ project file, the example provided in
         <filename>$GADGET_BASE_DIR/share/gadgeteer/samples/tutorials/device.driver</filename>
         can be used as a starting point. It sets all the compiler and linker
         options. Users must change the list of source and header files and
         the names of the output files. It is also recommended that users edit
         the <filename>.vcproj</filename> file with a text editor to remove
         the <literal>ProjectGUID</literal> setting on line 6 before loading
         the project file into Visual Studio. This will ensure that the new
         Visual C++ project file has a unique identifier.</para>
      </chapter>

      <chapter>
         <title>Driver Configuration</title>

         <indexterm>
            <primary>device drivers</primary>

            <secondary>configuring</secondary>
         </indexterm>

         <para>In Gadgeteer, device drivers should be parameterized. This
         means that aspects of the driver that can vary should be configurable
         rather than hard-coded values. This is in line with the general
         Juggler philosophy of making software components flexible to provide
         a high degree of adaptability. In this chapter, we explain how to
         configure the Input Manager to load a device driver plug-in and how
         to make a device driver configurable. For a more detailed explanation
         of the Juggler configuration system, refer to the VR Juggler
         <emphasis>Configuration Guide</emphasis>.</para>

         <section>
            <title>Configuring the Input Manager</title>

            <para>Run-time driver registration depends on the Input Manager
            configuration. For our button device driver, the Input Manager
            would be configured to load our driver plug-in using the
            configuration file shown in <xref
            linkend="example.input.mgr.config" />. Here, the driver plug-in is
            named <filename>button_drv.so</filename> (or some other
            platform-specific name), and it is found in the user's home
            directory. Never include the <filename>_d</filename> part of the
            driver plug-in name or the platform-specific file extension. The
            Input Manager determines these details automatically, thus making
            the configuration files highly portable across different operating
            systems. For more details about how to configure the Input
            Manager, refer to the VR Juggler <emphasis>Configuration
            Guide</emphasis>.</para>

            <example id="example.input.mgr.config">
               <title>Example Input Manager Configuration</title>

               <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings configuration.version="3.0"?&gt;
&lt;configuration
  xmlns="http://www.vrjuggler.org/jccl/xsd/3.0/configuration"
  name="Configuration"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.0/configuration http://www.vrjuggler.org/jccl/xsd/3.0/configuration.xsd"&gt;
   &lt;elements&gt;
      &lt;input_manager name="Button Device Input Manager" version="2"&gt;
         &lt;driver_path&gt;${HOME}&lt;/driver_path&gt;
         &lt;driver&gt;button_drv&lt;/driver&gt;
      &lt;/input_manager&gt;
   &lt;/elements&gt;
&lt;/configuration&gt;</programlisting>
            </example>
         </section>

         <section condition="" id="section.driver.config.def">
            <title>Driver Configuration Definition File</title>

            <para>Every Gadgeteer device needs a unique <firstterm>element
            type</firstterm> associated with it. An element type is similar to
            a struct in C or C++. The data structure is defined in an
            configuration definition file (which usually has the extension
            <filename>.jdef</filename>). Once defined, the type for a new
            driver can be used in JCCL configuration files.</para>

            <para>Therefore, a new driver-specific configuration definition
            must be created before a driver can be configured. We recommend
            that this be done using the <application>VRJConfig</application>
            Config Definition Editor. For the button device, the definition
            file is shown in <xref
            linkend="example.buttondevice.jdef" />.</para>

            <example id="example.buttondevice.jdef">
               <title><filename>button_device.jdef</filename>: Configuration
               Definition File for Simple Button Device</title>

               <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings definition.version="3.1"?&gt;
&lt;definition xmlns="http://www.vrjuggler.org/jccl/xsd/3.1/definition"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.1/definition http://www.vrjuggler.org/jccl/xsd/3.1/definition.xsd"
            name="button_device"&gt;                               <co
                     id="buttondevice.jdef.token.decl"
                     linkends="buttondevice.jdef.token.decl.co" />
   &lt;definition_version version="1" label="My Button Device"&gt;
      &lt;help&gt;Configuration for simple one-button device.&lt;/help&gt;
      &lt;parent&gt;digital_device&lt;/parent&gt;                           <co
                     id="buttondevice.jdef.parent.decl"
                     linkends="buttondevice.jdef.parent.decl.co" />
      &lt;category&gt;/Devices/Digital&lt;/category&gt;
      &lt;property valuetype="string" variable="false"
                name="port"&gt;                                    <co
                     id="buttondevice.jdef.port.decl"
                     linkends="buttondevice.jdef.port.decl.co" />
         &lt;help&gt;Serial port the device is connected to.&lt;/help&gt;
         &lt;value label="Port" defaultvalue="/dev/ttyd1"/&gt;
      &lt;/property&gt;
      &lt;property valuetype="integer" variable="false"
                name="baud"&gt;                                    <co
                     id="buttondevice.jdef.baud.decl"
                     linkends="buttondevice.jdef.baud.decl.co" />
         &lt;help&gt;Serial port speed.&lt;/help&gt;
         &lt;value label="Baud" defaultvalue="38400"/&gt;
      &lt;/property&gt;
      &lt;upgrade_transform/&gt;
   &lt;/definition_version&gt;
&lt;/definition&gt;</programlisting>

               <calloutlist>
                  <callout arearefs="buttondevice.jdef.token.decl"
                           id="buttondevice.jdef.token.decl.co">
                     <para>This begins the definition for our device type. The
                     <literal>name</literal> attribute must be named as a
                     valid XML tag (a CNAME in XML terminology) because it
                     will be used as such in a configuration file. A
                     free-form, human-friendly string may be specified in the
                     <literal>label</literal> attribute of the
                     <sgmltag>definition_version</sgmltag> element. This
                     string will be presented to the user of
                     <application>VRJConfig</application>, and as such, it
                     should be a meaningful identifier.</para>
                  </callout>

                  <callout arearefs="buttondevice.jdef.parent.decl"
                           id="buttondevice.jdef.parent.decl.co">
                     <para>The parent (or base type) for this config
                     definition. Zero or more of these are allowed. In this
                     case, we must indicate that
                     <literal>digital_device</literal> is a parent type so
                     that <application>VRJConfig</application> will know that
                     digital proxies can be pointed at config elements for our
                     driver. We also inherit property definitions from
                     <literal>digital_device</literal> including
                     <quote>device_host</quote>, which is needed for cluster
                     configurations.</para>
                  </callout>

                  <callout arearefs="buttondevice.jdef.port.decl"
                           id="buttondevice.jdef.port.decl.co">
                     <para>This declares the <quote>port</quote> property that
                     will provide the name of the serial port to which the
                     hardware is connected. The serial port name will be
                     interpreted as a string, and it has the default value of
                     <quote>/dev/ttyd1</quote>. In the case of our simple
                     button driver, there is no serial port, but we include
                     this property definition to demonstrate how the whole
                     configuration definition works.</para>
                  </callout>

                  <callout arearefs="buttondevice.jdef.baud.decl"
                           id="buttondevice.jdef.baud.decl.co">
                     <para>This declares the <quote>baud</quote> property that
                     will provide the baud setting for the serial port to
                     which the hardware is connected. The baud value will be
                     interpreted as an integer, and it has the default value
                     of 38400 (kilobits per second). In the case of our simple
                     button driver, there is no serial port, but we include
                     this property definition to demonstrate how the whole
                     configuration definition works.</para>
                  </callout>
               </calloutlist>
            </example>

            <note>
               <para>In the above configuration definition, we do not declare
               a <quote>device_host</quote> property, which is used in
               conjunction with the Remote Input Manager. This is not
               necessary because we have declared our parent type to be
               <quote>digital_device</quote>, and we inherit its property
               definitions. All drivers that may be used with the Remote Input
               Manager must have the <quote>device_host</quote> property, and
               configuration definition inheritance ensures that this will be
               the case. Refer to the VR Juggler <emphasis>Configuration
               Guide</emphasis> for more information about this
               property.</para>
            </note>

            <para>For a more complex device, a more complex configuration
            definition may be needed. Again, the
            <application>VRJConfig</application> Configuration Definition
            Editor simplifies the creation of this definition.</para>
         </section>

         <section id="section.driver.config.file">
            <title>Driver Configuration File</title>

            <para>Once the configuration definition is in place, a new
            configuration element can be created. Once again,
            <application>VRJConfig</application> makes the step easier. In
            <xref linkend="example.buttondevice.jconf" />, we see a
            configuration file that configures the one-button device we have
            been using thus far.</para>

            <important>
               <para>In order for <application>VRJConfig</application> and the
               JCCL Configuration Manager to find the driver-specific
               <filename>.jdef</filename> file at run time, it may be
               necessary to extend the <filename>.jdef</filename> search path
               using the environment variable
               <envar>JCCL_DEFINITION_PATH</envar>. This environment variable
               is set in the same manner as the <envar>PATH</envar>
               environment variable, meaning that it uses platform-specific
               conventions. On UNIX-based platforms, the directories to search
               are separated with the colon (:) character; on Windows, the
               path separator character is the semi-colon (;). If the .jdef
               file is installed in the default search path
               (<filename>$VJ_BASE_DIR/share/vrjuggler/data/definitions</filename>),
               there is no need to set
               <envar>JCCL_DEFINITION_PATH</envar>.</para>
            </important>

            <example id="example.buttondevice.jconf">
               <title><filename>button_device.jconf</filename>: Configuration
               File for Simple Button Device</title>

               <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings configuration.version="3.0"?&gt;
&lt;configuration xmlns="http://www.vrjuggler.org/jccl/xsd/3.0/configuration"
               name="Configuration"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.0/configuration http://www.vrjuggler.org/jccl/xsd/3.0/configuration.xsd"&gt;
   &lt;elements&gt;
      &lt;input_manager name="Button Device Input Manager"
                     version="2"&gt;                             <co
                     id="buttondevice.jconf.InputManager"
                     linkends="buttondevice.jconf.driver.co" />
         &lt;driver_path&gt;${HOME}&lt;/driver_path&gt;
         &lt;driver&gt;button_drv&lt;/driver&gt;
      &lt;/input_manager&gt;
      &lt;button_device name="Button Device" version="1"&gt;        <co
                     id="buttondevice.jconf.ButtonDevice"
                     linkends="buttondevice.jconf.ButtonDevice.co" />
         &lt;port&gt;/dev/ttyd4&lt;/port&gt;                              <co
                     id="buttondevice.jconf.port.value"
                     linkends="buttondevice.jconf.port.value.co" />
         &lt;baud&gt;9600&lt;/baud&gt;                                    <co
                     id="buttondevice.jconf.baud.value"
                     linkends="buttondevice.jconf.baud.value.co" />
         &lt;device_host /&gt;                                      <co
                     id="buttondevice.jconf.hostelement.value"
                     linkends="buttondevice.jconf.hostelement.value.co" />
      &lt;/button_device&gt;
      &lt;digital_proxy name="Button Proxy 0" version="1"&gt;       <co
                     id="buttondevice.jconf.proxy"
                     linkends="buttondevice.jconf.proxy.co" />
         &lt;device&gt;Button Device&lt;/device&gt;
         &lt;unit&gt;0&lt;/unit&gt;
      &lt;/digital_proxy&gt;
      &lt;alias name="VJButton0" version="1"&gt;
         &lt;proxy&gt;Button Proxy 0&lt;/proxy&gt;
      &lt;/alias&gt;
   &lt;/elements&gt;
&lt;/configuration&gt;</programlisting>
            </example>

            <calloutlist>
               <callout arearefs="buttondevice.jconf.InputManager"
                        id="buttondevice.jconf.driver.co">
                  <para>The <sgmltag>input_manager</sgmltag> element
                  configures the Gadgeteer Input Manager. In this case, we are
                  telling the Input Manager about a driver plug-in, found at
                  <filename>${HOME}/button_drv.so</filename>, that should be
                  loaded at run time.</para>

                  <tip>
                     <para>Earlier, we introduced the Input Manager
                     configuration in a separate configuration file. In
                     general, we recommend configuring a given device entirely
                     within one <filename>.jconf</filename> fileâ€”including the
                     <literal>input_manager</literal> config element that
                     loads the driver plug-in. That is precisely what we are
                     showing in this example.</para>
                  </tip>
               </callout>

               <callout arearefs="buttondevice.jconf.ButtonDevice"
                        id="buttondevice.jconf.ButtonDevice.co">
                  <para>Next, we have an instance of the configuration
                  definition shown in <xref
                  linkend="example.buttondevice.jdef" />. As described above,
                  <sgmltag>&lt;button_device&gt;</sgmltag> is named based on
                  the <literal>name</literal> attribute of the
                  <sgmltag>definition</sgmltag> element in our configuration
                  definition file. The <literal>name</literal> attribute here
                  gives this <emphasis>instance</emphasis> a unique
                  identifier.</para>
               </callout>

               <callout arearefs="buttondevice.jconf.port.value"
                        id="buttondevice.jconf.port.value.co">
                  <para>Now, we set the value for the serial port name. As
                  noted above, our simple button device does not actually use
                  the serial port, but this demonstrates how the property
                  value is used in a configuration file. If no value were
                  given here, the default value set in
                  b<filename>utton_device.jdef</filename> would be
                  used.</para>
               </callout>

               <callout arearefs="buttondevice.jconf.baud.value"
                        id="buttondevice.jconf.baud.value.co">
                  <para>This provides a value for the serial port baud
                  setting. Again, this will not actually be used by our simple
                  device, but we show it here to give a complete
                  example.</para>
               </callout>

               <callout arearefs="buttondevice.jconf.hostelement.value"
                        id="buttondevice.jconf.hostelement.value.co">
                  <para>For our example, we will not fill in a value for
                  <literal>device_host</literal> because we are not dealing
                  with the Remote Input Manager. Refer to the VR Juggler
                  <emphasis>Configuration Guide</emphasis> for more
                  information about this.</para>
               </callout>

               <callout arearefs="buttondevice.jconf.proxy"
                        id="buttondevice.jconf.proxy.co">
                  <para>Finally, we point a digital proxy at our device. Since
                  the device has only one input source, we have to use 0 for
                  the unit value.</para>
               </callout>
            </calloutlist>
         </section>

         <section id="section.driver.config.methods">
            <title>Writing Code that Accepts the Configuration</title>

            <para>In the driver, recall that there are two methods that must
            be implemented in order to handle config elements:</para>

            <orderedlist>
               <listitem>
                  <para><methodname>getElementType()</methodname></para>
               </listitem>

               <listitem>
                  <para><methodname>config()</methodname></para>
               </listitem>
            </orderedlist>

            <para>We now present these two methods, thereby completing the
            interface of the driver as far as the Input Manager is
            concerned.</para>

            <section>
               <title><methodname>getElementType()</methodname></title>

               <highlights>
                  <itemizedlist>
                     <listitem>
                        <para>Method synopsis: <methodsynopsis>
                              <modifier>static</modifier>

                              <type>std::string</type>

                              <methodname>getElementType</methodname>

                              <void />
                           </methodsynopsis></para>
                     </listitem>

                     <listitem>
                        <para>Overrides the pure virtual function
                        <methodname>gadget::Input::updateData()</methodname>
                        declared in
                        <filename>gadget/Type/Input.h</filename></para>
                     </listitem>
                  </itemizedlist>
               </highlights>

               <para>When the configuration changes, the JCCL Configuration
               Manager asks every registered configuration handler for their
               respective configuration element types. If the type matches the
               type of the newly received configuration element, then the
               handler's <methodname>config()</methodname> method is invoked.
               All device drivers are configuration handlers and thus need to
               indicate the configuration element type they accept<footnote>
                     <para>A comprehensive explanation of the full
                     functionality of the Juggler run-time (re-)configuration
                     system is beyond the scope of this document. Here, we
                     present only the basic information about config
                     definitions and config elements that is needed for
                     writing a complete device driver. For more details, see
                     the VR Juggler <emphasis>Configuration
                     Guide</emphasis>.</para>
                  </footnote>. The type value is returned by the member
               function <methodname>getElementType()</methodname>.</para>

               <para>In this function, the element type of the device must be
               returned. The string returned by
               <methodname>getElementType()</methodname> must be
               <emphasis>exactly</emphasis> the same as the
               <literal>name</literal> attribute for the driver configuration
               definition that we saw above in <xref
               linkend="section.driver.config.def" />. For example, the
               implementation for the simple button driver would appear as
               shown in <xref linkend="example.getElementType.impl" />.</para>

               <example id="example.getElementType.impl">
                  <title>Implementation of
                  <function>getElementType()</function> Member
                  Function</title>

                  <programlisting>std::string ButtonDevice::getElementType()
{
   return std:string("button_device");
}</programlisting>
               </example>

               <important>
                  <para>Returning the correct string from
                  <methodname>getElementType()</methodname> is very important.
                  Failing to do so will result in the config element for the
                  device driver ending up in the JCCL Configuration Manager's
                  pending list at run time. For device driver authors, this
                  can be a serious point of confusion. The driver plug-in will
                  load correctly, but if the string returned by
                  <methodname>getElementType()</methodname> is incorrect, the
                  driver will never be configured or started.</para>
               </important>
            </section>

            <section>
               <title><methodname>config()</methodname></title>

               <highlights>
                  <itemizedlist>
                     <listitem>
                        <para>Method synopsis: <methodsynopsis>
                              <modifier>virtual</modifier>

                              <type>bool</type>

                              <methodname>updateData</methodname>

                              <methodparam>
                                 <type>jccl::ConfigElementPtr</type>

                                 <parameter>element</parameter>
                              </methodparam>
                           </methodsynopsis></para>
                     </listitem>

                     <listitem>
                        <para>Overrides the virtual function
                        <methodname>gadget::Input::config()</methodname>
                        declared in <filename>gadget/Type/Input.h</filename>
                        as well as the virtual functions
                        <methodname>gadget::Analog::config()</methodname>,
                        <methodname>gadget::Position::config()</methodname>,
                        etc., depending on the type parameters used in the
                        base class declaration</para>
                     </listitem>
                  </itemizedlist>
               </highlights>

               <para>When the Configuration Manager detects a configuration
               change for a given driver, it will pass the new
               <classname>jccl::ConfigElementPtr</classname> object as the
               parameter to this method. This is when the driver must handle
               its configuration and store the information for use when the
               Input Manager tells the device to start up. For more
               information about how to use instances of
               <classname>jccl::ConfigElementPtr</classname>, refer to the
               <emphasis>JCCL C++ Programmer's Reference</emphasis>. The
               implementation of <methodname>config()</methodname> for our
               simple button device driver is shown in <xref
               linkend="example.config.impl" />.</para>

               <important>
                  <para>The override of
                  <methodname>gadget::Input::config()</methodname> must invoke
                  the implementations of <methodname>config()</methodname>
                  that it overrides from its base classes. All the base
                  classes defined by Gadgeteer for different input device
                  types have a <methodname>config()</methodname> method,
                  though some of them have an empty method body. Nevertheless,
                  <emphasis>all</emphasis> inherited
                  <methodname>config()</methodname> methods must be invoked by
                  the driver in order to ensure that the driver is fully
                  configured. In general, this should be done first before
                  reading any of the device-specific properties from the
                  config element. This is demonstrated in the example
                  below.</para>
               </important>

               <example id="example.config.impl">
                  <title>Implementation of <methodname>config()</methodname>
                  Member Function</title>

                  <programlisting>bool ButtonDevice::config(jccl::ConfigElementPtr e)
{
   // Configure all our base classes first.  If any of those fail,
   // we cannot finish configuring ourself.
   if ( ! gadget::Input::config(e) &amp;&amp; ! gadget::Digital::config(e) )
   {
      return false;
   }

   mPortName = e-&gt;getProperty&lt;std::string&gt;("port");
   mBaudRate = e-&gt;getProperty&lt;int&gt;("baud");

   return true;
}</programlisting>
               </example>
            </section>
         </section>
      </chapter>
   </part>

   <part>
      <title>Appendices</title>

      <appendix id="driver.code.appendix">
         <title>Complete Device Driver Code</title>

         <para></para>

         <section id="standalone.driver.section">
            <title>Standalone Driver</title>

            <para></para>
         </section>

         <section id="gadgeteer.wrapper.section">
            <title>Gadgeteer Wrapper</title>

            <indexterm>
               <primary>device drivers</primary>

               <secondary>example</secondary>
            </indexterm>

            <para>Now that we have explained the concepts involved in adding a
            device driver to Gadgeteer, we can show some code. The following
            example is for a fictitious piece of hardware that has only one
            button.</para>

            <important>
               <para>This implementation is trivial by design. A more
               appropriate implementation for this case would not use a thread
               for sampling and would instead call
               <methodname>sample()</methodname> from
               <methodname>updateData()</methodname> so that only one sample
               is recorded per frame. The reason for doing this is because
               this <quote>driver</quote> is not I/O-bound and instead just
               adds a value to the digital sample buffer every time
               <methodname>sample()</methodname> is invoked.</para>
            </important>

            <example id="example.ButtonDevice.h">
               <title><filename>buttondevice.h</filename></title>

               <programlisting linenumbering="numbered">#ifndef _EXAMPLE_BUTTON_DEVICE_H_
#define _EXAMPLE_BUTTON_DEVICE_H_

#include &lt;gadget/Devices/DriverConfig.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;string&gt;

#include &lt;vpr/vpr.h&gt;

#include &lt;jccl/Config/ConfigElementPtr.h&gt;
#include &lt;gadget/Type/Input.h&gt;
#include &lt;gadget/Type/Digital.h&gt;
#include &lt;gadget/Type/InputMixer.h&gt;


using namespace gadget;

/** The device driver class. */
class ButtonDevice : public InputMixer&lt;Input, Digital&gt;
{
public:
   ButtonDevice()
      : mSampleThread(NULL)
      , mRunning(false)
   {
      /* Do nothing. */ ;
   }

   virtual ~ButtonDevice()
   {
      if ( mRunning )
      {
         this-&gt;stopSampling();
      }
   }

   /**
    * When the system detects a configuration change for your
    * driver, it will pass the jccl::ConfigElementPtr into
    * this function.  See the documentation on config elements,
    * for information on how to access them.
    */
   virtual bool config(jccl::ConfigElementPtr e);

   /**
    * Spawns the sample thread, which calls ButtonDevice::sample()
    * repeatedly.
    */
   virtual bool startSampling();

   /**
    * Records (or samples) the current data.  This is called
    * repeatedly by the sample thread created by startSampling().
    */
   virtual bool sample();

   /** Kills the sample thread. */
   virtual bool stopSampling();

   virtual void updateData();

   /**
    * Returns a string that matches this device's configuration
    * element type.
    */
   static std::string getElementType();

   /**
    * Invokes the global scope delete operator.  This is required
    * for proper releasing of memory in DLLs on Win32.
    */
   void operator delete(void* p)
   {
      ::operator delete(p);
   }

protected:
   /**
    * Deletes this object.  This is an implementation of the pure
    * virtual gadget::Input::destroy() method.
    */
   virtual void destroy()
   {
      delete this;
   }

private:
   /**
    * Our sampling function that is executed by the spawned
    * sample thread.  This function simply calls
    * ButtonDevice::sample() over and over.
    */
   void threadedSampleFunction();

   vpr::Thread*  mSampleThread;
   bool          mRunning;

   // configuration data set by config()
   std::string   mPort;
   int           mBaud;
};

#endif /* _EXAMPLE_BUTTON_DEVICE_H_ */</programlisting>
            </example>

            <example>
               <title><filename>buttondevice.cpp</filename></title>

               <programlisting linenumbering="numbered">#include &lt;gadget/Devices/DriverConfig.h&gt;

#include &lt;vector&gt;
#include &lt;boost/bind.hpp&gt;

#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/System.h&gt;

#include &lt;jccl/Config/ConfigElement.h&gt;
#include &lt;gadget/gadgetParam.h&gt;
#include &lt;gadget/InputManager.h&gt;
#include &lt;gadget/Type/DeviceConstructor.h&gt;

#include "buttondevice.h"

extern "C"
{

/** Entry point function for the device driver plug-in. */
GADGET_DRIVER_EXPORT(vpr::Uint32) getGadgeteerVersion()
{
   return __GADGET_version;
}

/** Entry point function for the device driver plug-in. */
GADGET_DRIVER_EXPORT(void) initDevice(InputManager* inputMgr)
{
   new DeviceConstructor&lt;ButtonDevice&gt;(inputMgr);
}

}

// Returns a string that matches this device's configuration
// element type.
std::string ButtonDevice::getElementType()
{
   return std::string("button_device");
}

// When the system detects a configuration change for your driver,
// it will pass the jccl::ConfigElementPtr into this function.
// See the documentation on config elements, for information on
// how to access them.
bool ButtonDevice::config(jccl::ConfigElementPtr e)
{
  if ( ! Input::config(e) &amp;&amp; ! Digital::config(e) )
  {
     return false;
  }

  mPort = e-&gt;getProperty&lt;std::string&gt;("port");
  mBaud = e-&gt;getProperty&lt;int&gt;("baud");

  return true;
}

// Spanws the sample thread, which calls ButtonDevice::sample()
// repeatedly.
bool ButtonDevice::startSampling()
{
   mRunning = false;

   try
   {
      mSampleThread =
         new vpr::Thread(boost::bind(&amp;ButtonDevice::threadedSampleFunction,
                                     this));
      mRunning = true;
   }
   catch (vpr::Exception&amp; ex)
   {
      std::cerr &lt;&lt; "Failed to spawn sample thread!\n" &lt;&lt; ex.what()
                &lt;&lt; std::endl;
   }

   return mRunning;
}

// Records (or samples) the current data.  This is called
// repeatedly by the sample thread created by startSampling().
bool ButtonDevice::sample()
{
   bool status(false);

   if ( mRunning )
   {
      // Here you would add your code to sample the hardware for
      // a button press:
      std::vector&lt;DigitalData&gt; samples(1);
      samples[0] = 1;
      addDigitalSample(samples);

      // Successful sample.
      status = true;
   }

   return status;
}

// Kills the sample thread.
bool ButtonDevice::stopSampling()
{
   mRunning = false;

   if (mSampleThread != NULL)
   {
      mSampleThread-&gt;kill();
      mSampleThread-&gt;join();
      delete mSampleThread;
      mSampleThread = NULL;
   }
   return true;
}

void ButtonDevice::updateData()
{
   if ( mRunning )
   {
      swapDigitalBuffers();
   }
}

// Our sampling function that is executed by the spawned sample
// thread.
void ButtonDevice::threadedSampleFunction()
{
   // spin until someone kills "mSampleThread"
   while ( mRunning )
   {
      sample();
   }
}</programlisting>
            </example>
         </section>

         <section id="makefile.templates.section">
            <title>Makefile Templates</title>

            <para>The following is an example <filename>Makefile.in</filename>
            that could be added to the Gadgeteer build system.</para>

            <example id="example.Makefile.in">
               <title><filename>Makefile.in</filename> for Gadgeteer Build
               System</title>

               <programlisting linenumbering="unnumbered">default: all

# Include common definitions.
include @topdir@/make.defs.mk

DRIVER_NAME=    ButtonDevice

srcdir=         @srcdir@
top_srcdir=     @top_srcdir@
INSTALL=        @INSTALL@
INSTALL_FILES=
SUBOBJDIR=      $(DRIVER_NAME)
C_AFTERBUILD=   driver-dso

SRCS=           ButtonDevice.cpp \
                DriverStandalone.cpp

include $(MKPATH)/dpp.obj.mk
include @topdir@/driver.defs.mk

# Include dependencies generated automatically.
ifndef DO_CLEANDEPEND
ifndef DO_BEFOREBUILD
   -include $(DEPEND_FILES)
endif
endif</programlisting>
            </example>

            <para>The following is a makefile for a driver that is built
            outside of the Gadgeteer source tree. This cannot be used on
            Windows with Gadgeteer 1.0.</para>

            <example>
               <title>Makefile for Use Outside Gadgeteer Source Tree</title>

               <programlisting linenumbering="unnumbered">srcdir=         .
BUILD_TYPE=     dbg
#BUILD_TYPE=    opt

DRIVER_NAME=    button
SRCS=           buttondevice.cpp

GADGET_BASE_DIR=$(shell flagpoll gadgeteer --get-prefix)
GADGET_VERSION= $(shell flagpoll gadgeteer --modversion)

include $(GADGET_BASE_DIR)/share/gadgeteer-$(GADGET_VERSION)/gadget.driver.mk</programlisting>
            </example>

            <para>The following is a Visual C++ project file for a driver that
            is built outside of the Gadgeteer source tree. A Visual C++
            project file must be used for compiling driver plug-ins on
            Windows.</para>

            <example>
               <title>Visual C++ Project for Use Outside Gadgeteer Source
               Tree</title>

               <programlisting linenumbering="unnumbered">&lt;?xml version="1.0" encoding = "Windows-1252"?&gt;
&lt;VisualStudioProject
        ProjectType="Visual C++"
        Version="7.00"
        Name="Driver - Button Device"
        Keyword="Win32Proj"&gt;
        &lt;Platforms&gt;
                &lt;Platform
                        Name="Win32"/&gt;
        &lt;/Platforms&gt;
        &lt;Configurations&gt;
                &lt;Configuration
                        Name="Debug|Win32"
                        OutputDirectory="DebugDLL"
                        IntermediateDirectory="DebugDLL"
                        ConfigurationType="2"
                        CharacterSet="2"&gt;
                        &lt;Tool
                                Name="VCCLCompilerTool"
                                Optimization="0"
                                AdditionalIncludeDirectories="&amp;quot;$(VJ_BASE_DIR)\include&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\include&amp;quot;"
                                PreprocessorDefinitions="WIN32;JUGGLER_DEBUG;_CONSOLE;_USRDLL;_GADGET_DRIVER_BUILD_"
                                MinimalRebuild="FALSE"
                                RuntimeLibrary="2"
                                BufferSecurityCheck="FALSE"
                                RuntimeTypeInfo="TRUE"
                                UsePrecompiledHeader="0"
                                WarningLevel="3"
                                Detect64BitPortabilityProblems="TRUE"
                                DebugInformationFormat="1"
                                DisableSpecificWarnings="4244;4251;4267;4275;4290;4312;4800"/&gt;
                        &lt;Tool
                                Name="VCCustomBuildTool"/&gt;
                        &lt;Tool
                                Name="VCLinkerTool"
                                AdditionalDependencies="libnspr4.lib libplc4.lib ws2_32.lib $(NOINHERIT)"
                                OutputFile="$(OutDir)/button_drv_g.dll"
                                LinkIncremental="1"
                                AdditionalLibraryDirectories="&amp;quot;$(VJ_BASE_DIR)\lib&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\lib&amp;quot;"
                                GenerateDebugInformation="FALSE"
                                ProgramDatabaseFile="$(OutDir)/button_drv_g.pdb"
                                SubSystem="1"
                                ImportLibrary="$(OutDir)/button_drv_g.lib"
                                TargetMachine="1"/&gt;
                        &lt;Tool
                                Name="VCMIDLTool"/&gt;
                        &lt;Tool
                                Name="VCPostBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreLinkEventTool"/&gt;
                        &lt;Tool
                                Name="VCResourceCompilerTool"/&gt;
                        &lt;Tool
                                Name="VCWebServiceProxyGeneratorTool"/&gt;
                        &lt;Tool
                                Name="VCWebDeploymentTool"/&gt;
                &lt;/Configuration&gt;
                &lt;Configuration
                        Name="DebugRt|Win32"
                        OutputDirectory="DebugDLL"
                        IntermediateDirectory="DebugDLL"
                        ConfigurationType="2"
                        CharacterSet="2"&gt;
                        &lt;Tool
                                Name="VCCLCompilerTool"
                                Optimization="0"
                                AdditionalIncludeDirectories="&amp;quot;$(VJ_BASE_DIR)\include&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\include&amp;quot;"
                                PreprocessorDefinitions="WIN32;JUGGLER_DEBUG;_CONSOLE;_USRDLL;_GADGET_DRIVER_BUILD_"
                                MinimalRebuild="FALSE"
                                BasicRuntimeChecks="3"
                                RuntimeLibrary="3"
                                BufferSecurityCheck="FALSE"
                                RuntimeTypeInfo="TRUE"
                                UsePrecompiledHeader="0"
                                WarningLevel="3"
                                Detect64BitPortabilityProblems="TRUE"
                                DebugInformationFormat="1"
                                DisableSpecificWarnings="4244;4251;4267;4275;4290;4312;4800"/&gt;
                        &lt;Tool
                                Name="VCCustomBuildTool"/&gt;
                        &lt;Tool
                                Name="VCLinkerTool"
                                AdditionalDependencies="libnspr4.lib libplc4.lib ws2_32.lib $(NOINHERIT)"
                                OutputFile="$(OutDir)/button_drv_d.dll"
                                LinkIncremental="1"
                                AdditionalLibraryDirectories="&amp;quot;$(VJ_BASE_DIR)\lib&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\lib&amp;quot;"
                                GenerateDebugInformation="TRUE"
                                ProgramDatabaseFile="$(OutDir)/button_drv_d.pdb"
                                SubSystem="1"
                                ImportLibrary="$(OutDir)/button_drv_d.lib"
                                TargetMachine="1"/&gt;
                        &lt;Tool
                                Name="VCMIDLTool"/&gt;
                        &lt;Tool
                                Name="VCPostBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreLinkEventTool"/&gt;
                        &lt;Tool
                                Name="VCResourceCompilerTool"/&gt;
                        &lt;Tool
                                Name="VCWebServiceProxyGeneratorTool"/&gt;
                        &lt;Tool
                                Name="VCWebDeploymentTool"/&gt;
                &lt;/Configuration&gt;
                &lt;Configuration
                        Name="Release|Win32"
                        OutputDirectory="ReleaseDLL"
                        IntermediateDirectory="ReleaseDLL"
                        ConfigurationType="2"
                        CharacterSet="2"&gt;
                        &lt;Tool
                                Name="VCCLCompilerTool"
                                Optimization="2"
                                InlineFunctionExpansion="1"
                                OmitFramePointers="TRUE"
                                AdditionalIncludeDirectories="&amp;quot;$(VJ_BASE_DIR)\include&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\include&amp;quot;"
                                PreprocessorDefinitions="WIN32;JUGGLER_OPT;NDEBUG;_CONSOLE;_USRDLL;_GADGET_DRIVER_BUILD_"
                                StringPooling="TRUE"
                                MinimalRebuild="FALSE"
                                RuntimeLibrary="2"
                                BufferSecurityCheck="FALSE"
                                EnableFunctionLevelLinking="TRUE"
                                RuntimeTypeInfo="TRUE"
                                UsePrecompiledHeader="0"
                                WarningLevel="3"
                                Detect64BitPortabilityProblems="TRUE"
                                DebugInformationFormat="3"
                                DisableSpecificWarnings="4244;4251;4267;4275;4290;4312;4800"/&gt;
                        &lt;Tool
                                Name="VCCustomBuildTool"/&gt;
                        &lt;Tool
                                Name="VCLinkerTool"
                                AdditionalDependencies="libnspr4.lib libplc4.lib ws2_32.lib $(NOINHERIT)"
                                OutputFile="$(OutDir)/button_drv.dll"
                                LinkIncremental="1"
                                AdditionalLibraryDirectories="&amp;quot;$(VJ_BASE_DIR)\lib&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\lib&amp;quot;"
                                GenerateDebugInformation="TRUE"
                                ProgramDatabaseFile="$(OutDir)/button_drv.pdb"
                                SubSystem="1"
                                OptimizeReferences="2"
                                EnableCOMDATFolding="2"
                                ImportLibrary="$(OutDir)/button_drv.lib"
                                TargetMachine="1"/&gt;
                        &lt;Tool
                                Name="VCMIDLTool"/&gt;
                        &lt;Tool
                                Name="VCPostBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreLinkEventTool"/&gt;
                        &lt;Tool
                                Name="VCResourceCompilerTool"/&gt;
                        &lt;Tool
                                Name="VCWebServiceProxyGeneratorTool"/&gt;
                        &lt;Tool
                                Name="VCWebDeploymentTool"/&gt;
                &lt;/Configuration&gt;
        &lt;/Configurations&gt;
        &lt;Files&gt;
                &lt;Filter
                        Name="Source Files"
                        Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"&gt;
                        &lt;File
                                RelativePath="buttondevice.cpp"&gt;
                        &lt;/File&gt;
                &lt;/Filter&gt;
                &lt;Filter
                        Name="Header Files"
                        Filter="h;hpp;hxx;hm;inl;inc"&gt;
                        &lt;File
                                RelativePath="buttondevice.h"&gt;
                        &lt;/File&gt;
                &lt;/Filter&gt;
                &lt;Filter
                        Name="Resource Files"
                        Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"&gt;
                &lt;/Filter&gt;
        &lt;/Files&gt;
        &lt;Globals&gt;
        &lt;/Globals&gt;
&lt;/VisualStudioProject&gt;</programlisting>
            </example>
         </section>
      </appendix>

      <appendix id="appendix.gfdl">
         <title>GNU Free Documentation License</title>

         <subtitle>Version 1.2, November 2002</subtitle>

         <blockquote id="fsf-copyright">
            <title>FSF Copyright note</title>

            <para>Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
            59 Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is
            permitted to copy and distribute verbatim copies of this license
            document, but changing it is not allowed.</para>
         </blockquote>

         <section id="gfdl-0">
            <title>PREAMBLE</title>

            <para>The purpose of this License is to make a manual, textbook,
            or other functional and useful document "free" in the sense of
            freedom: to assure everyone the effective freedom to copy and
            redistribute it, with or without modifying it, either commercially
            or noncommercially. Secondarily, this License preserves for the
            author and publisher a way to get credit for their work, while not
            being considered responsible for modifications made by
            others.</para>

            <para>This License is a kind of "copyleft", which means that
            derivative works of the document must themselves be free in the
            same sense. It complements the GNU General Public License, which
            is a copyleft license designed for free software.</para>

            <para>We have designed this License in order to use it for manuals
            for free software, because free software needs free documentation:
            a free program should come with manuals providing the same
            freedoms that the software does. But this License is not limited
            to software manuals; it can be used for any textual work,
            regardless of subject matter or whether it is published as a
            printed book. We recommend this License principally for works
            whose purpose is instruction or reference.</para>
         </section>

         <section id="gfdl-1">
            <title>APPLICABILITY AND DEFINITIONS</title>

            <para id="gfdl-doc">This License applies to any manual or other
            work, in any medium, that contains a notice placed by the
            copyright holder saying it can be distributed under the terms of
            this License. Such a notice grants a world-wide, royalty-free
            license, unlimited in duration, to use that work under the
            conditions stated herein. The "Document", below, refers to any
            such manual or work. Any member of the public is a licensee, and
            is addressed as "you". You accept the license if you copy, modify
            or distribute the work in a way requiring permission under
            copyright law.</para>

            <para id="gfdl-mod-ver">A "Modified Version" of the Document means
            any work containing the Document or a portion of it, either copied
            verbatim, or with modifications and/or translated into another
            language.</para>

            <para id="gfdl-secnd-sect">A "Secondary Section" is a named
            appendix or a front-matter section of the Document that deals
            exclusively with the relationship of the publishers or authors of
            the Document to the Document's overall subject (or to related
            matters) and contains nothing that could fall directly within that
            overall subject. (Thus, if the Document is in part a textbook of
            mathematics, a Secondary Section may not explain any mathematics.)
            The relationship could be a matter of historical connection with
            the subject or with related matters, or of legal, commercial,
            philosophical, ethical or political position regarding
            them.</para>

            <para id="gfdl-inv-sect">The "Invariant Sections" are certain
            Secondary Sections whose titles are designated, as being those of
            Invariant Sections, in the notice that says that the Document is
            released under this License. If a section does not fit the above
            definition of Secondary then it is not allowed to be designated as
            Invariant. The Document may contain zero Invariant Sections. If
            the Document does not identify any Invariant Sections then there
            are none.</para>

            <para id="gfdl-cov-text">The "Cover Texts" are certain short
            passages of text that are listed, as Front-Cover Texts or
            Back-Cover Texts, in the notice that says that the Document is
            released under this License. A Front-Cover Text may be at most 5
            words, and a Back-Cover Text may be at most 25 words.</para>

            <para id="gfdl-transparent">A "Transparent" copy of the Document
            means a machine-readable copy, represented in a format whose
            specification is available to the general public, that is suitable
            for revising the document straightforwardly with generic text
            editors or (for images composed of pixels) generic paint programs
            or (for drawings) some widely available drawing editor, and that
            is suitable for input to text formatters or for automatic
            translation to a variety of formats suitable for input to text
            formatters. A copy made in an otherwise Transparent file format
            whose markup, or absence of markup, has been arranged to thwart or
            discourage subsequent modification by readers is not Transparent.
            An image format is not Transparent if used for any substantial
            amount of text. A copy that is not "Transparent" is called
            "Opaque".</para>

            <para>Examples of suitable formats for Transparent copies include
            plain ASCII without markup, Texinfo input format, LaTeX input
            format, SGML or XML using a publicly available DTD, and
            standard-conforming simple HTML, PostScript or PDF designed for
            human modification. Examples of transparent image formats include
            PNG, XCF and JPG. Opaque formats include proprietary formats that
            can be read and edited only by proprietary word processors, SGML
            or XML for which the DTD and/or processing tools are not generally
            available, and the machine-generated HTML, PostScript or PDF
            produced by some word processors for output purposes only.</para>

            <para id="gfdl-title-page">The "Title Page" means, for a printed
            book, the title page itself, plus such following pages as are
            needed to hold, legibly, the material this License requires to
            appear in the title page. For works in formats which do not have
            any title page as such, "Title Page" means the text near the most
            prominent appearance of the work's title, preceding the beginning
            of the body of the text.</para>

            <para id="gfdl-entitled">A section "Entitled XYZ" means a named
            subunit of the Document whose title either is precisely XYZ or
            contains XYZ in parentheses following text that translates XYZ in
            another language. (Here XYZ stands for a specific section name
            mentioned below, such as "Acknowledgements", "Dedications",
            "Endorsements", or "History".) To "Preserve the Title" of such a
            section when you modify the Document means that it remains a
            section "Entitled XYZ" according to this definition.</para>

            <para>The Document may include Warranty Disclaimers next to the
            notice which states that this License applies to the Document.
            These Warranty Disclaimers are considered to be included by
            reference in this License, but only as regards disclaiming
            warranties: any other implication that these Warranty Disclaimers
            may have is void and has no effect on the meaning of this
            License.</para>
         </section>

         <section id="gfdl-2">
            <title>VERBATIM COPYING</title>

            <para>You may copy and distribute the Document in any medium,
            either commercially or noncommercially, provided that this
            License, the copyright notices, and the license notice saying this
            License applies to the Document are reproduced in all copies, and
            that you add no other conditions whatsoever to those of this
            License. You may not use technical measures to obstruct or control
            the reading or further copying of the copies you make or
            distribute. However, you may accept compensation in exchange for
            copies. If you distribute a large enough number of copies you must
            also follow the conditions in section 3.</para>

            <para>You may also lend copies, under the same conditions stated
            above, and you may publicly display copies.</para>
         </section>

         <section id="gfdl-3">
            <title>COPYING IN QUANTITY</title>

            <para>If you publish printed copies (or copies in media that
            commonly have printed covers) of the Document, numbering more than
            100, and the Document's license notice requires Cover Texts, you
            must enclose the copies in covers that carry, clearly and legibly,
            all these Cover Texts: Front-Cover Texts on the front cover, and
            Back-Cover Texts on the back cover. Both covers must also clearly
            and legibly identify you as the publisher of these copies. The
            front cover must present the full title with all words of the
            title equally prominent and visible. You may add other material on
            the covers in addition. Copying with changes limited to the
            covers, as long as they preserve the title of the Document and
            satisfy these conditions, can be treated as verbatim copying in
            other respects.</para>

            <para>If the required texts for either cover are too voluminous to
            fit legibly, you should put the first ones listed (as many as fit
            reasonably) on the actual cover, and continue the rest onto
            adjacent pages.</para>

            <para>If you publish or distribute Opaque copies of the Document
            numbering more than 100, you must either include a
            machine-readable Transparent copy along with each Opaque copy, or
            state in or with each Opaque copy a computer-network location from
            which the general network-using public has access to download
            using public-standard network protocols a complete Transparent
            copy of the Document, free of added material. If you use the
            latter option, you must take reasonably prudent steps, when you
            begin distribution of Opaque copies in quantity, to ensure that
            this Transparent copy will remain thus accessible at the stated
            location until at least one year after the last time you
            distribute an Opaque copy (directly or through your agents or
            retailers) of that edition to the public.</para>

            <para>It is requested, but not required, that you contact the
            authors of the Document well before redistributing any large
            number of copies, to give them a chance to provide you with an
            updated version of the Document.</para>
         </section>

         <section id="gfdl-4">
            <title>MODIFICATIONS</title>

            <para>You may copy and distribute a Modified Version of the
            Document under the conditions of sections 2 and 3 above, provided
            that you release the Modified Version under precisely this
            License, with the Modified Version filling the role of the
            Document, thus licensing distribution and modification of the
            Modified Version to whoever possesses a copy of it. In addition,
            you must do these things in the Modified Version:</para>

            <orderedlist id="gfdl-modif-cond" numeration="upperalpha">
               <title>GNU FDL Modification Conditions</title>

               <listitem>
                  <simpara>Use in the Title Page (and on the covers, if any) a
                  title distinct from that of the Document, and from those of
                  previous versions (which should, if there were any, be
                  listed in the History section of the Document). You may use
                  the same title as a previous version if the original
                  publisher of that version gives permission.</simpara>
               </listitem>

               <listitem>
                  <simpara>List on the Title Page, as authors, one or more
                  persons or entities responsible for authorship of the
                  modifications in the Modified Version, together with at
                  least five of the principal authors of the Document (all of
                  its principal authors, if it has fewer than five), unless
                  they release you from this requirement.</simpara>
               </listitem>

               <listitem>
                  <simpara>State on the Title page the name of the publisher
                  of the Modified Version, as the publisher.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve all the copyright notices of the
                  Document.</simpara>
               </listitem>

               <listitem>
                  <simpara>Add an appropriate copyright notice for your
                  modifications adjacent to the other copyright
                  notices.</simpara>
               </listitem>

               <listitem>
                  <simpara>Include, immediately after the copyright notices, a
                  license notice giving the public permission to use the
                  Modified Version under the terms of this License, in the
                  form shown in the <link
                  linkend="gfdl-addendum">Addendum</link> below.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve in that license notice the full lists of
                  Invariant Sections and required Cover Texts given in the
                  Document's license notice.</simpara>
               </listitem>

               <listitem>
                  <simpara>Include an unaltered copy of this
                  License.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve the section Entitled "History", Preserve
                  its Title, and add to it an item stating at least the title,
                  year, new authors, and publisher of the Modified Version as
                  given on the Title Page. If there is no section Entitled
                  "History" in the Document, create one stating the title,
                  year, authors, and publisher of the Document as given on its
                  Title Page, then add an item describing the Modified Version
                  as stated in the previous sentence.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve the network location, if any, given in the
                  Document for public access to a Transparent copy of the
                  Document, and likewise the network locations given in the
                  Document for previous versions it was based on. These may be
                  placed in the "History" section. You may omit a network
                  location for a work that was published at least four years
                  before the Document itself, or if the original publisher of
                  the version it refers to gives permission.</simpara>
               </listitem>

               <listitem>
                  <simpara>For any section Entitled "Acknowledgements" or
                  "Dedications", Preserve the Title of the section, and
                  preserve in the section all the substance and tone of each
                  of the contributor acknowledgements and/or dedications given
                  therein.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve all the Invariant Sections of the
                  Document, unaltered in their text and in their titles.
                  Section numbers or the equivalent are not considered part of
                  the section titles.</simpara>
               </listitem>

               <listitem>
                  <simpara>Delete any section Entitled "Endorsements". Such a
                  section may not be included in the Modified
                  Version.</simpara>
               </listitem>

               <listitem>
                  <simpara>Do not retitle any existing section to be Entitled
                  "Endorsements" or to conflict in title with any Invariant
                  Section.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve any Warranty Disclaimers.</simpara>
               </listitem>
            </orderedlist>

            <para>If the Modified Version includes new front-matter sections
            or appendices that qualify as Secondary Sections and contain no
            material copied from the Document, you may at your option
            designate some or all of these sections as invariant. To do this,
            add their titles to the list of Invariant Sections in the Modified
            Version's license notice. These titles must be distinct from any
            other section titles.</para>

            <para>You may add a section Entitled "Endorsements", provided it
            contains nothing but endorsements of your Modified Version by
            various parties--for example, statements of peer review or that
            the text has been approved by an organization as the authoritative
            definition of a standard.</para>

            <para>You may add a passage of up to five words as a Front-Cover
            Text, and a passage of up to 25 words as a Back-Cover Text, to the
            end of the list of Cover Texts in the Modified Version. Only one
            passage of Front-Cover Text and one of Back-Cover Text may be
            added by (or through arrangements made by) any one entity. If the
            Document already includes a cover text for the same cover,
            previously added by you or by arrangement made by the same entity
            you are acting on behalf of, you may not add another; but you may
            replace the old one, on explicit permission from the previous
            publisher that added the old one.</para>

            <para>The author(s) and publisher(s) of the Document do not by
            this License give permission to use their names for publicity for
            or to assert or imply endorsement of any Modified Version.</para>
         </section>

         <section id="gfdl-5">
            <title>COMBINING DOCUMENTS</title>

            <para>You may combine the Document with other documents released
            under this License, under the terms defined in <link
            linkend="gfdl-4">section 4</link> above for modified versions,
            provided that you include in the combination all of the Invariant
            Sections of all of the original documents, unmodified, and list
            them all as Invariant Sections of your combined work in its
            license notice, and that you preserve all their Warranty
            Disclaimers.</para>

            <para>The combined work need only contain one copy of this
            License, and multiple identical Invariant Sections may be replaced
            with a single copy. If there are multiple Invariant Sections with
            the same name but different contents, make the title of each such
            section unique by adding at the end of it, in parentheses, the
            name of the original author or publisher of that section if known,
            or else a unique number. Make the same adjustment to the section
            titles in the list of Invariant Sections in the license notice of
            the combined work.</para>

            <para>In the combination, you must combine any sections Entitled
            "History" in the various original documents, forming one section
            Entitled "History"; likewise combine any sections Entitled
            "Acknowledgements", and any sections Entitled "Dedications". You
            must delete all sections Entitled "Endorsements".</para>
         </section>

         <section id="gfdl-6">
            <title>COLLECTIONS OF DOCUMENTS</title>

            <para>You may make a collection consisting of the Document and
            other documents released under this License, and replace the
            individual copies of this License in the various documents with a
            single copy that is included in the collection, provided that you
            follow the rules of this License for verbatim copying of each of
            the documents in all other respects.</para>

            <para>You may extract a single document from such a collection,
            and distribute it individually under this License, provided you
            insert a copy of this License into the extracted document, and
            follow this License in all other respects regarding verbatim
            copying of that document.</para>
         </section>

         <section id="gfdl-7">
            <title>AGGREGATION WITH INDEPENDENT WORKS</title>

            <para>A compilation of the Document or its derivatives with other
            separate and independent documents or works, in or on a volume of
            a storage or distribution medium, is called an "aggregate" if the
            copyright resulting from the compilation is not used to limit the
            legal rights of the compilation's users beyond what the individual
            works permit. When the Document is included in an aggregate, this
            License does not apply to the other works in the aggregate which
            are not themselves derivative works of the Document.</para>

            <para>If the Cover Text requirement of section 3 is applicable to
            these copies of the Document, then if the Document is less than
            one half of the entire aggregate, the Document's Cover Texts may
            be placed on covers that bracket the Document within the
            aggregate, or the electronic equivalent of covers if the Document
            is in electronic form. Otherwise they must appear on printed
            covers that bracket the whole aggregate.</para>
         </section>

         <section id="gfdl-8">
            <title>TRANSLATION</title>

            <para>Translation is considered a kind of modification, so you may
            distribute translations of the Document under the terms of section
            4. Replacing Invariant Sections with translations requires special
            permission from their copyright holders, but you may include
            translations of some or all Invariant Sections in addition to the
            original versions of these Invariant Sections. You may include a
            translation of this License, and all the license notices in the
            Document, and any Warranty Disclaimers, provided that you also
            include the original English version of this License and the
            original versions of those notices and disclaimers. In case of a
            disagreement between the translation and the original version of
            this License or a notice or disclaimer, the original version will
            prevail.</para>

            <para>If a section in the Document is Entitled "Acknowledgements",
            "Dedications", or "History", the requirement (section 4) to
            Preserve its Title (section 1) will typically require changing the
            actual title.</para>
         </section>

         <section id="gfdl-9">
            <title>TERMINATION</title>

            <para>You may not copy, modify, sublicense, or distribute the
            Document except as expressly provided for under this License. Any
            other attempt to copy, modify, sublicense or distribute the
            Document is void, and will automatically terminate your rights
            under this License. However, parties who have received copies, or
            rights, from you under this License will not have their licenses
            terminated so long as such parties remain in full
            compliance.</para>
         </section>

         <section id="gfdl-10">
            <title>FUTURE REVISIONS OF THIS LICENSE</title>

            <para>The Free Software Foundation may publish new, revised
            versions of the GNU Free Documentation License from time to time.
            Such new versions will be similar in spirit to the present
            version, but may differ in detail to address new problems or
            concerns. See http://www.gnu.org/copyleft/.</para>

            <para>Each version of the License is given a distinguishing
            version number. If the Document specifies that a particular
            numbered version of this License "or any later version" applies to
            it, you have the option of following the terms and conditions
            either of that specified version or of any later version that has
            been published (not as a draft) by the Free Software Foundation.
            If the Document does not specify a version number of this License,
            you may choose any version ever published (not as a draft) by the
            Free Software Foundation.</para>
         </section>

         <section id="gfdl-addendum">
            <title>ADDENDUM: How to use this License for your
            documents</title>

            <para>To use this License in a document you have written, include
            a copy of the License in the document and put the following
            copyright and license notices just after the title page:</para>

            <blockquote id="copyright-sample">
               <title>Sample Invariant Sections list</title>

               <para>Copyright (c) YEAR YOUR NAME. Permission is granted to
               copy, distribute and/or modify this document under the terms of
               the GNU Free Documentation License, Version 1.2 or any later
               version published by the Free Software Foundation; with no
               Invariant Sections, no Front-Cover Texts, and no Back-Cover
               Texts. A copy of the license is included in the section
               entitled "GNU Free Documentation License".</para>
            </blockquote>

            <para>If you have Invariant Sections, Front-Cover Texts and
            Back-Cover Texts, replace the "with...Texts." line with
            this:</para>

            <blockquote id="inv-cover-sample">
               <title>Sample Invariant Sections list</title>

               <para>with the Invariant Sections being LIST THEIR TITLES, with
               the Front-Cover Texts being LIST, and with the Back-Cover Texts
               being LIST.</para>
            </blockquote>

            <para>If you have Invariant Sections without Cover Texts, or some
            other combination of the three, merge those two alternatives to
            suit the situation.</para>

            <para>If your document contains nontrivial examples of program
            code, we recommend releasing these examples in parallel under your
            choice of free software license, such as the GNU General Public
            License, to permit their use in free software.</para>
         </section>
      </appendix>
   </part>

   <bibliography>
      <biblioentry id="ref.pthreads.programming">
         <abbrev>Nic96</abbrev>

         <authorgroup>
            <author>
               <firstname>Bradford</firstname>

               <surname>Nichols</surname>
            </author>

            <author>
               <firstname>Dick</firstname>

               <surname>Buttlar</surname>
            </author>

            <author>
               <firstname>Jacqueline</firstname>

               <othername>Proulx</othername>

               <surname>Farrell</surname>
            </author>
         </authorgroup>

         <title>Pthreads Programming</title>

         <subtitle>A POSIX Standard for Better Multiprocessing</subtitle>

         <publisher>
            <publishername>O'Reilly &amp; Associates</publishername>
         </publisher>

         <pubdate>1996</pubdate>
      </biblioentry>

      <biblioentry id="ref.eolson.thesis">
         <abbrev>Ols92</abbrev>

         <author>
            <firstname>Eric</firstname>

            <surname>Olson</surname>
         </author>

         <title>Cluster Juggler: PC cluster virtual reality</title>

         <publisher>
            <publishername>Iowa State University</publishername>
         </publisher>

         <orgname>Dept. of Electrical and Computer Engineering</orgname>

         <pubdate>2002</pubdate>
      </biblioentry>

      <biblioentry id="ref.advanced.prog.unix">
         <abbrev>Ste92</abbrev>

         <author>
            <firstname>W. Richard</firstname>

            <surname>Stevens</surname>
         </author>

         <title>Advanced Programming in the UNIX Environment</title>

         <publisher>
            <publishername>Addison-Wesley</publishername>
         </publisher>

         <pubdate>1992</pubdate>
      </biblioentry>

      <biblioentry id="ref.unix.network.programming">
         <abbrev>Ste98</abbrev>

         <author>
            <firstname>W. Richard</firstname>

            <surname>Stevens</surname>
         </author>

         <title>UNIX Network Programming</title>

         <volumenum>Volume 1</volumenum>

         <subtitle>Network APIS: Sockets and XTI</subtitle>

         <edition>Second Edition</edition>

         <publisher>
            <publishername>Prentice-Hall PTR</publishername>
         </publisher>

         <pubdate>1998</pubdate>
      </biblioentry>
   </bibliography>

   <glossary>
      <title>Glossary of Terms</title>

      <glossdiv>
         <title>B</title>

         <glossentry id="gloss.bsd.sockets">
            <glossterm>BSD sockets</glossterm>

            <glossdef>
               <para>The socket programming interface introduced with the
               Berkeley Software Distribution version of the UNIX operating
               system. It is made up of a collection of system calls that
               allow highly flexible socket programming. Most UNIX variants in
               use today use the BSD sockets API. Moreover, the Winsock API
               used on Windows is based on this API.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>N</title>

         <glossentry id="gloss.nspr">
            <glossterm>Netscape Portable Runtime</glossterm>

            <acronym>NSPR</acronym>

            <glossdef>
               <para>More information can be found at <ulink
               url="http://www.mozilla.org/projects/nspr/index.html">http://www.mozilla.org/projects/nspr/index.html</ulink></para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>V</title>

         <glossentry id="gloss.vpr">
            <glossterm>VR Juggler Portable Runtime</glossterm>

            <acronym>VPR</acronym>

            <glossdef>
               <para>More information can be found at <ulink
               url="http://www.vrjuggler.org/vapor/">http://www.vrjuggler.org/vapor/</ulink></para>
            </glossdef>
         </glossentry>
      </glossdiv>
   </glossary>

   <index></index>
</book>