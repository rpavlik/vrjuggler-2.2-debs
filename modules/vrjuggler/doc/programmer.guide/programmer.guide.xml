<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>VR Juggler</title>

      <subtitle>The Programmer's Guide</subtitle>

      <copyright>
         <year>2001–2007</year>

         <holder>Iowa State University</holder>
      </copyright>

      <legalnotice>
         <para>Permission is granted to copy, distribute and/or modify this
         document under the terms of the GNU Free Documentation License,
         Version 1.2 or any later version published by the Free Software
         Foundation; with the Invariant Sections being <xref
         linkend="appendix.gfdl" />, with no Front-Cover Texts, and with no
         Back-Cover Texts. A copy of the license is included in <xref
         linkend="appendix.gfdl" />.</para>
      </legalnotice>

      <releaseinfo>Version 2.2</releaseinfo>

      <pubdate>$Date$</pubdate>
   </bookinfo>

   <part id="part.intro">
      <title>Introduction</title>

      <chapter id="chapter.getting.started">
         <title>Getting Started</title>

         <para>In this book, we present a <quote>how-to</quote> for writing VR
         Juggler applications. We will explain concepts used in VR Juggler and
         present carefully annotated example code whenever appropriate. There
         are two groups of people who should read this book:</para>

         <orderedlist>
            <listitem>
               <para>Those who are required to read it in order to do a
               project for work or school. To those in this category, fear
               not—VR Juggler is very simple to use after getting through the
               initial learning stages. It is a powerful tool that will allow
               the creation of interesting and powerful applications very
               quickly.</para>
            </listitem>

            <listitem>
               <para>Those who are just interested in creating compelling,
               interesting VR applications. VR Juggler facilitates the
               construction of extremely powerful applications that will run
               on nearly any combination of hardware architecture and software
               platform.</para>
            </listitem>
         </orderedlist>

         <section>
            <title>Necessary Experience</title>

            <para>To help readers get the most from this book, recommendations
            follow to provide an idea of what previous experience is
            necessary. Various programming skills are needed, of course, but
            programming for VR requires more than just knowledge of a given
            programming language. VR Juggler takes advantage of many
            programming design patterns and advanced concepts to make it more
            powerful, more flexible, and more extensible. A good background in
            mathematics is helpful for performing the myriad transformations
            that must be applied to three-dimensional (3D) geometry.</para>

            <section>
               <title>Required Background</title>

               <para>To get the most from this chapter, there are a few
               prerequisites:</para>

               <itemizedlist>
                  <listitem>
                     <para>C++ programming experience</para>
                  </listitem>

                  <listitem>
                     <para>Some graphics programming background (e.g., OpenGL,
                     OpenGL Performer, etc.)</para>
                  </listitem>

                  <listitem>
                     <para>Reasonable mathematical background (linear algebra
                     knowledge is very useful)</para>
                  </listitem>
               </itemizedlist>

               <para>For some of the advanced sections of this book, it is
               recommended that readers review the VR Juggler architecture
               book. This is optional, though it may be helpful in gaining a
               quicker understanding of some topics and concepts.</para>
            </section>

            <section>
               <title>Other VR Software Tools</title>

               <para>Readers who already have experience with other VR
               software development environments can easily skim through this
               book and find the relevant new information. The book is
               designed for easy skimming. Simply look at the headings to get
               a good determination of what should be read and what may be
               skipped.</para>
            </section>

            <section>
               <title>Organization</title>

               <para>This book is organized into three main parts:</para>

               <orderedlist>
                  <listitem>
                     <para>Introduction: The introduction to the key VR
                     Juggler application development concept, application
                     objects. We also describe common helper classes that
                     simplify the process of writing applications.</para>
                  </listitem>

                  <listitem>
                     <para>Writing applications: The presentation of
                     application development including how to get input from
                     devices and how to write applications for each of the
                     supported graphics application programmer interfaces
                     (APIs).</para>
                  </listitem>

                  <listitem>
                     <para>Advanced topics: An extension of the previous
                     chapters showing how to incorporate run-time
                     reconfiguration into applications and how to write
                     multi-threaded applications.</para>
                  </listitem>
               </orderedlist>
            </section>
         </section>
      </chapter>

      <chapter id="chapter.app.basics">
         <title>Application Basics</title>

         <indexterm zone="chapter.app.basics">
            <primary>applications</primary>

            <secondary>basics</secondary>
         </indexterm>

         <para>In VR Juggler, all applications are written as objects that are
         handled by the kernel. The objects are known as <glossterm
         linkend="gloss.app.object">application objects</glossterm><indexterm>
               <primary>application object</primary>
            </indexterm>, and we will use that term frequently throughout this
         text. Application objects are introduced and explained in this
         chapter.</para>

         <section id="section.app.object.overview">
            <title>Application Object Overview</title>

            <indexterm zone="section.app.object.overview">
               <primary>applications</primary>

               <secondary>application object overview</secondary>
            </indexterm>

            <indexterm zone="section.app.object.overview">
               <primary>application object</primary>

               <secondary>overview</secondary>
            </indexterm>

            <para>VR Juggler uses the application object<indexterm>
                  <primary>application object</primary>
               </indexterm> to create the VR environment with which the users
            interact. The application object implements <glossterm
            linkend="gloss.interface">interfaces</glossterm> needed by the VR
            Juggler <glossterm linkend="gloss.virtual.platform">virtual
            platform</glossterm><indexterm>
                  <primary>virtual platform</primary>
               </indexterm>.</para>

            <section id="section.main.func">
               <title>No <function>main()</function>—<quote>Don't call me,
               I'll call you</quote></title>

               <indexterm zone="section.main.func">
                  <primary>main function</primary>
               </indexterm>

               <para>Since VR Juggler applications are objects, developers do
               not write the traditional <function>main()</function> function.
               Instead, developers create an application object that
               implements a set of pre-defined interfaces. The VR Juggler
               kernel controls the application's processing time by calling
               the object's interface implementation methods.</para>

               <para>In traditional programs, the <function>main()</function>
               function defines the point where the <glossterm
               linkend="gloss.thread.of.control">thread of control</glossterm>
               enters the application. After the <function>main()</function>
               function is called, the application starts performing any
               necessary processing. When the operating system (OS) starts the
               program, it gives the <function>main()</function> function some
               unit of processing time. After the time unit (quantum) for the
               process expires, the OS performs what is called a
               <quote>context switch</quote> to change control to another
               process. VR Juggler achieves similar functionality but in a
               slightly different manner.</para>

               <para>The application objects correspond to processes in a
               normal OS. The kernel is the scheduler, and it allocates time
               to an application by invoking the methods of the application
               object. Because the kernel has additional information about the
               resources needed by the applications, it maintains a very
               strict schedule to define when the application is granted
               processing time. This is the basis to maintain coherence across
               the system.</para>
            </section>

            <section>
               <title>Application Objects Derive from Base Classes for
               Specific Graphics APIs</title>

               <para>The first step in defining an application
               object<indexterm>
                     <primary>application object</primary>
                  </indexterm> is to implement the basic interfaces defined by
               the kernel and the Draw Managers<indexterm>
                     <primary>Draw Manager</primary>
                  </indexterm>. There is a base class for the interface that
               the kernel expects (<classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::App</secondary>
                  </indexterm>) and a base class handled by each Draw Manager
               interface (<classname>vrj::PfApp</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::PfApp</secondary>

                     <seealso>vrj::PfApp</seealso>
                  </indexterm>, <classname>vrj::GlApp</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::GlApp</secondary>

                     <seealso>vrj::GlApp</seealso>
                  </indexterm>, etc.). See <xref
               linkend="figure.vrj.App.hierarchy" /> for a visual
               representation of the complete application interface hierarchy.
               The interface defined in
               <classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::App</secondary>
                  </indexterm> specifies methods for initialization, shutdown,
               and execution of the application. This is the abstract type
               that is seen by the VR Juggler kernel. The Draw Manager
               interfaces specified in the <classname>vrj::*App</classname>
               classes define the API-specific functions necessary to render
               the virtual environment. For example, an interface used by a
               Draw Manager could have functions for drawing the scene and for
               initializing context-specific information.</para>

               <figure id="figure.vrj.App.hierarchy">
                  <title><classname>vrj::App</classname> hierarchy</title>

                  <mediaobject>
                     <imageobject>
                        <imagedata align="center"
                                   fileref="figures/AppHierarchy.png"
                                   format="PNG" />
                     </imageobject>
                  </mediaobject>
               </figure>
            </section>

            <section>
               <title>Writing an Application Means Filling in the
               Blanks</title>

               <para>To implement an application in VR Juggler, developers
               simply need to <quote>fill in the blanks</quote> of the
               appropriate interfaces. To simplify this process, there are
               default implementations of most methods in the interfaces.
               Hence, the user must only provide implementations for the
               aspects they want to customize. If an implementation is not
               provided in the user application object, the default is used,
               but it is important to know that in most cases, the default
               implementation does nothing.</para>

               <tip>
                  <para>When overriding a virtual method defined by a VR
                  Juggler application class, it is best to call the parent
                  class method implementation before performing any
                  application-specific processing. For example, if a
                  user-defined application object overrides
                  <methodname>vrj::App::init()</methodname> in the class
                  <classname>userApp</classname>, the method
                  <methodname>userApp::init()</methodname> should invoke
                  <methodname>vrj::App::init()</methodname> before performing
                  its own initialization steps.</para>
               </tip>
            </section>
         </section>

         <section>
            <title>Benefits of Application Objects</title>

            <indexterm>
               <primary>application object</primary>

               <secondary>benefits of</secondary>
            </indexterm>

            <para>As stated earlier, the most common approach for VR
            application development is one where the application defines the
            <function>main()</function> function. That
            <function>main()</function> function in turn calls library
            functions when needed. (This is the model followed by software
            packages such as the <productname>CAVElibs</productname> and the
            Diverse Toolkit.) The library in this model only executes code
            when directed to do so by the application. As a result, the
            application developer is responsible for coordinating the
            execution of the different VR system components. This can lead to
            complex applications.</para>

            <section>
               <title>Allow for Run-Time Changes</title>

               <para>As a <glossterm linkend="gloss.virtual.platform">virtual
               platform</glossterm>, VR Juggler does not use the model
               described above because VR Juggler needs to maintain control of
               the system components. This control is necessary to make
               changes to the virtual platform at run time. As the controller
               of the execution, the kernel always knows the current state of
               the applications, and therefore, it can manage the run-time
               reconfigurations of the virtual environment safely. With
               run-time reconfiguration, it is possible to switch
               applications, start new devices, reconfigure running devices,
               and send reconfiguration information to the application
               object.</para>
            </section>

            <section>
               <title>Low Coupling</title>

               <para>Application objects lead to a robust architecture as a
               result of low coupling and well-defined inter-object
               dependencies. The application interface defines the only
               communication path between the application and the virtual
               platform, and this allows restriction of inter-object
               dependencies. This decreased coupling allows changes in the
               system to be localized, and thus, changes to one object will
               not affect another unless the interface itself is changed. The
               result is code that is more robust and more extensible.</para>

               <para>Because the application is simply an object, it is
               possibly to load and unload applications dynamically. When the
               virtual platform initializes, it waits for an application to be
               passed to it. When the application is given to the VR Juggler
               kernel at run time, the kernel performs a few initialization
               steps and then executes the application.</para>
            </section>

            <section>
               <title>Allows Implementation Changes</title>

               <para>Since applications use a distinct interface to
               communicate with the virtual platform, changes to the
               implementation of the virtual platform do not affect the
               application. Changes could include bug fixes, performance
               tuning, or new device support.</para>
            </section>

            <section>
               <title>Multi-Language Interaction</title>

               <para>By treating applications as objects, we can mix
               programming languages in the VR Juggler kernel. For example, an
               application object could be written in Python, C#, or even
               VB.NET, but the VR Juggler kernel (written in standard C++)
               will still see it as an instance of the abstract interface
               <classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::App</secondary>
                  </indexterm>. The use of application objects has allowed
               such extensions to VR Juggler to be written without requiring
               any changes to VR Juggler.</para>
            </section>
         </section>

         <section id="section.app.startup">
            <title>VR Juggler Startup</title>

            <indexterm zone="section.app.startup">
               <primary>applications</primary>

               <secondary>starting</secondary>
            </indexterm>

            <para>In this section, we describe one way to start VR Juggler. We
            will use the traditional <function>main()</function> function in
            C++, but this is not the only way to do it. We have written Python
            applications that start the VR Juggler kernel, and it is possible
            to write a VR Juggler <glossterm
            linkend="gloss.daemon">daemon</glossterm> that loads applications
            on demand at runtime. In other words, the VR Juggler startup
            procedure is quite flexible, and we choose to focus on the
            simplest method here.</para>

            <section id="section.app.startup.no.main">
               <title>No <function>main()</function>—Sort Of</title>

               <indexterm zone="section.app.startup.no.main">
                  <primary>applications</primary>

                  <secondary>main function</secondary>

                  <tertiary>use</tertiary>
               </indexterm>

               <para>Previously, we explained how VR Juggler applications do
               not have a <function>main()</function> function, but further
               explanation is required. While it is true that user
               <emphasis>applications</emphasis> do not have a
               <function>main()</function> function because they are objects,
               there must still be a <function>main()</function> somewhere
               that starts the system. This is because the operating system
               uses <function>main()</function> as the starting point for all
               applications. In typical VR Juggler applications, there is a
               <function>main()</function>, but it only starts the VR Juggler
               kernel and gives the kernel the application to run. It then
               waits for the kernel to shut down before exiting.</para>
            </section>

            <section id="section.app.main.structure">
               <title>Structure of a <function>main()</function>
               Function</title>

               <indexterm zone="section.app.main.structure">
                  <primary>applications</primary>

                  <secondary>main function</secondary>

                  <tertiary>structure</tertiary>
               </indexterm>

               <para>The following is a typical example of a
               <function>main()</function> function that will start the VR
               Juggler kernel and hand it an instance of a user application
               object. The specifics of what is happening in this code are
               described below.</para>

               <programlistingco>
                  <areaspec>
                     <area coords="5 75"
                           id="simpleApp.main.body.create-kernel" />

                     <area coords="6 75"
                           id="simpleApp.main.body.app-instantiate" />

                     <area coords="8 75"
                           id="simpleApp.main.body.loadConfigFile" />

                     <area coords="9 75" id="simpleApp.main.body.start" />

                     <area coords="10 75" id="simpleApp.main.body.setApp" />
                  </areaspec>

                  <programlisting linenumbering="numbered">#include &lt;vrj/Kernel/Kernel.h&gt;
#include &lt;simpleApp.h&gt;

int main(int argc, char* argv[])
{
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   simpleApp* app      = new simpleApp();         // Create the app object

   kernel-&gt;loadConfigFile(...);             // Configure the kernel
   kernel-&gt;start();                         // Start the kernel thread
   kernel-&gt;setApplication(app);             // Give application to kernel
   kernel-&gt;waitForKernelStop();             // Block until kernel stops

   return 0;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="simpleApp.main.body.create-kernel">
                        <para>This line finds (and may create) the VR Juggler
                        kernel. The kernel reference is stored in the handle
                        so that we can use it later.</para>
                     </callout>

                     <callout arearefs="simpleApp.main.body.app-instantiate">
                        <para>We instantiate a copy of the user application
                        object (<classname>simpleApp</classname>) here. Notice
                        that we include the header file that defines the
                        <classname>simpleApp</classname> class.</para>
                     </callout>

                     <callout arearefs="simpleApp.main.body.loadConfigFile">
                        <para>This statement represents the code that will be
                        in the <function>main()</function> function for
                        passing configuration files to the kernel's
                        <methodname>loadConfigFile()</methodname> method.
                        These configuration files may come from the command
                        line or from some other source. If reading the files
                        from the command line, it can be as simple as looping
                        through all the arguments and passing each one to the
                        kernel.</para>
                     </callout>

                     <callout arearefs="simpleApp.main.body.start">
                        <para>As a result of this statement, the VR Juggler
                        kernel begins running. It creates a new thread of
                        execution for the kernel, and the kernel begins its
                        internal processing. From this point on, any changes
                        made reconfigure the kernel. These changes can come in
                        the form of more configuration files or in the form of
                        an application object to execute. At this point, it is
                        important to notice that the kernel knows nothing
                        about the application. Moreover, there is no need for
                        it to know about configuration files yet. This
                        demonstrates how the VR Juggler kernel executes
                        independently from the user application. The kernel
                        will simply work on its own controlling and
                        configuring the system even without an application to
                        run.</para>
                     </callout>

                     <callout arearefs="simpleApp.main.body.setApp">
                        <para>This statement finally tells the kernel what
                        application it should run. The method call
                        reconfigures the kernel so that it will now start
                        invoking the application object's member functions. It
                        is at this time that the application is now running in
                        the VR system.</para>
                     </callout>
                  </calloutlist>
               </programlistingco>
            </section>

            <section>
               <title>Mac OS X Considerations</title>

               <indexterm zone="section.app.main.structure">
                  <primary>applications</primary>

                  <secondary>main function</secondary>

                  <tertiary>Mac OS X</tertiary>
               </indexterm>

               <para>VR Juggler 2.2 introduces support for Cocoa on Mac OS X.
               Cocoa itself is quite different than the X11 or Win32 APIs as
               far as restrictions on threading and the implementation of the
               <function>main()</function> function. The fundamental issue,
               however, is that both the <classname>NSApplication</classname>
               singleton object and the <classname>vrj::Kernel</classname>
               singleton object want to be in charge of application execution.
               A balance has been struck that generally allows VR Juggler
               applications to look and act the same on Mac OS X as on any
               other platform while still taking advantage of unique features
               that Cocoa and Mac OS X have to offer.</para>

               <section>
                  <title>Application Bundles</title>

                  <para>First and foremost, when using a Cocoa-aware version
                  of VR Juggler, applications have to be constructed as
                  bundles. The details of OS X application bundles are far
                  beyond the scope of this document. However, VR Juggler
                  provides just about everything that is required to make an
                  application bundle. This makes sense because VR Juggler is
                  an application framework that dictates how applications are
                  written and executed. Thus, it also provides the core
                  information required for proper application construction and
                  execution on Mac OS X.</para>

                  <para>To get started, it is helpful to understand what the
                  application bundle will look like when we have everything in
                  place. An application bundle is a directory structure with a
                  special name. For example, <filename>MPApp.app</filename>
                  will show up in the <application>Finder</application> as an
                  application named <quote>MPApp</quote> that can be
                  double-clicked. The name can contain spaces if so
                  desired.</para>

                  <para>Under the base directory is the
                  <filename>Contents</filename> subdirectory. It will contain
                  the files <filename>Info.plist</filename> and
                  <filename>PkgInfo</filename>.</para>

                  <para>Next, there are two subdirectories
                  <filename>MacOS</filename> and
                  <filename>Resources</filename>. Compiled binaries should
                  normally go into the <filename>MacOS</filename>
                  subdirectory. If nothing else, the bundle executable (the
                  compiled application binary) <emphasis>must</emphasis> go in
                  the <filename>MacOS</filename> directory. Shared libraries
                  can go into the <filename>Resources</filename> directory if
                  desired. Generally, though, the
                  <filename>Resources</filename> directory will contain
                  platform-independent data files.</para>

                  <para>In the resources directory, there will be another
                  subdirectory <filename>en.lproj</filename><footnote>
                        <para>This is the English language project data.
                        Translations of <filename>MainMenu.nib</filename>
                        would go into the appropriate language-specific
                        subdirectory.</para>
                     </footnote> which in turn contains
                  <filename>MainMenu.nib</filename> from
                  <filename>$VJ_BASE_DIR/share/vrjuggler/data/bundle</filename>.
                  This is a critical part of the application bundle, and it is
                  very important that this NIB behave correctly. The NIB
                  defines the user interface for the VR Juggler application,
                  and what is provided with VR Juggler is set up and ready to
                  go for the most common cases. It is possible to use a
                  different <filename>MainMenu.nib</filename>, but customizing
                  it will require care.</para>

                  <sidebar>
                     <para>The ability to customize the user interface of the
                     VR Juggler application by using a different
                     <filename>MainMenu.nib</filename> and a different
                     application delegate (see <xref
                     linkend="section.custom.delegate" />) makes VR Juggler on
                     Mac OS X unique with respect to other platforms. Whereas
                     the user interface used with <productname
                     class="registered">Microsoft Windows</productname> and
                     the X Window System is essentially hard coded, the Mac OS
                     X Cocoa interface has been designed with flexibility in
                     mind. Simply put, the Cocoa support in VR Juggler
                     leverages the dynamic nature of Cocoa to provide features
                     that are not so easily available on other
                     platforms.</para>
                  </sidebar>

                  <section>
                     <title><filename>Info.plist</filename></title>

                     <para>The files and directories needed for application
                     bundle creation can be found in the directory
                     <filename>$VJ_BASE_DIR/share/vrjuggler/data/bundle</filename>.
                     The first of these is
                     <filename>Contents/Info.plist</filename>, the basic
                     property list for an application bundle. Open it with the
                     Property List Editor application and change the
                     <literal>@APP_NAME@</literal> strings accordingly for the
                     name of the application being constructed. For the
                     <literal>CFBundleExecutable</literal> property, be sure
                     to change <literal>@APP_NAME@</literal> to be the name of
                     the executable that will be in the Contents/MacOS
                     directory. Other properties to change are those that
                     include copyright and version information.</para>
                  </section>

                  <section>
                     <title><filename>PkgInfo</filename></title>

                     <para>The contents of
                     <filename>Contents/PkgInfo</filename> define the
                     application bundle as an application bundle. The contents
                     of the file will often be <literal>APPL????</literal>,
                     though other characters are allowed in place of the
                     <literal>????</literal> part.</para>
                  </section>

                  <section>
                     <title><filename>Resources</filename> Directory</title>

                     <para>The <filename>Contents/Resources</filename>
                     directory contains data files related to application
                     execution. The file <filename>vrjuggler.plist</filename>,
                     the use of which is highly recommended, must be put in
                     this directory. The application bundle icon file (a file
                     with the extension <filename>.icns</filename>) is also
                     stored in this directory. A default icon file,
                     <filename>vrjuggler.icns</filename>, can be used, or a
                     custom one can be made. The file to use must be named in
                     <filename>Contents/Info.plist</filename>.</para>
                  </section>

                  <section>
                     <title><filename>vrjuggler.plist</filename></title>

                     <para>For VR Juggler application bundles, a useful file
                     is <filename>vrjuggler.plist</filename>. The default
                     version of this file from
                     <filename>$VJ_BASE_DIR/share/vrjuggler/data/bundle</filename>
                     disables VR Juggler configuration file loading through
                     <classname>NSApplication</classname> channels and
                     identifies the <classname>NSApplication</classname>
                     delegate class type that will be used (see <xref
                     linkend="section.custom.delegate" />). These are set
                     using the properties <literal>VRJConfigHandling</literal>
                     and <literal>VRJDelegateClass</literal>
                     respectively.</para>

                     <para>The <quote>configuration file loading through
                     <classname>NSApplication</classname> channels</quote> bit
                     has to do with associating VR Juggler configuration files
                     with application bundles. There are different means by
                     which data can be delivered to applications on Mac OS X.
                     For example, double-clicking on a file in the
                     <application>Finder</application> (or selecting
                     <guimenuitem>Open With</guimenuitem> in the context menu
                     for the file) causes a registered handler application to
                     be opened. The file is given to the application once it
                     has opened through the
                     <classname>NSApplication</classname> event system. By
                     setting the <literal>VRJConfigHandling</literal> property
                     to <literal>false</literal> in
                     <filename>Contents/Resources/vrjuggler.plist</filename>,
                     this capability is disabled for the application bundle in
                     question. That is, the application bundle will ignore the
                     <classname>NSApplication</classname> events pertaining to
                     configuration files to be loaded as a result of
                     double-clicking on the said files. Configuration files
                     can still be opened on the fly using the
                     <guimenu>File</guimenu> menu defined in the default NIB
                     (see below).</para>
                  </section>

                  <section>
                     <title><filename>en.lproj</filename> Directory</title>

                     <para>The <filename>en.lproj</filename> subdirectory of
                     <filename>Contents/Resources</filename> contains
                     information translated in the English language. The most
                     important item in this directory is MainMenu.nib
                     (discussed next), but the optional file
                     <filename>$VJ_BASE_DIR/share/vrjuggler/data/bundle/InfoPlist.strings</filename>,
                     or some other version of same, can be copied into this
                     directory. Other language-specific directories can be
                     created as subdirectories of
                     <filename>Contents/Resources</filename> as necessary.
                     They, too, must contain a
                     <filename>MainMenu.nib</filename>.</para>
                  </section>

                  <section>
                     <title><filename>MainMenu.nib</filename></title>

                     <para>This is the NIB for the VR juggler application
                     bundle. It has been designed using Interface Builder with
                     a simple user interface that knows how to interact with a
                     VR Juggler application. The interface includes the
                     <guimenu>File</guimenu> menu with the item for opening VR
                     Juggler configuration files on the fly. Other menus and
                     menu items can be added by making a custom MainMenu.nib.
                     Using the version from
                     <filename>$VJ_BASE_DIR/share/vrjuggler/data/bundle</filename>
                     as a starting point is a good idea. Note that
                     <filename>MainMenu.nib</filename> is a directory, and it
                     should be copied recursively to
                     <filename>Contents/Resources/en.lproj</filename>.</para>
                  </section>
               </section>

               <section id="section.cocoa.app.execution">
                  <title>Application Execution</title>

                  <para>The <function>main()</function> function
                  implementation show in <xref
                  linkend="section.app.main.structure" /> will work without
                  any problems on Mac OS X. However, many of the VR Juggler
                  sample and test applications have a slightly more
                  complicated <function>main()</function> function. In
                  particular, these applications usually determine whether the
                  user has passed in any arguments through the command line
                  and exit with an error message explaining how to run the
                  application if none were given. The example below shows how
                  this is commonly done with an <literal>if</literal>
                  statement before anything else:</para>

                  <programlisting linenumbering="numbered">@include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;vrj/Kernel/Kernel.h&gt;
#include &lt;simpleApp.h&gt;

int main(int argc, char* argv[])
{
   if ( argc &lt;= 1 )
   {
      std::cout &lt;&lt; "Usage: " &lt;&lt; argv[0]
                &lt;&lt; "cfgfile[0] cfgfile[1] ... cfgfile[n]"
                &lt;&lt; std::endl;
      std::exit(EXIT_FAILURE);
   }

   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   simpleApp* app      = new simpleApp();         // Create the app object

   kernel-&gt;loadConfigFile(...);             // Configure the kernel
   kernel-&gt;start();                         // Start the kernel thread
   kernel-&gt;setApplication(app);             // Give application to kernel
   kernel-&gt;waitForKernelStop();             // Block until kernel stops

   return 0;
}</programlisting>

                  <para>This approach will not necessarily work on Mac OS X
                  because users normally expect to be able to launch an
                  application by double-clicking on its icon in the
                  <application>Finder</application> and then loading data into
                  it through a GUI. If a user launched the above application
                  that way, the application would exit immediately, and the
                  user would have to open the
                  <application>Console</application> application to find out
                  what went wrong. Launching from the command line, while
                  perfectly valid on Mac OS X, is simply not what users
                  expect. At the same time, remote launching of VR juggler
                  applications in a cluster will almost certainly require
                  launching without the use of the
                  <application>Finder</application> and passing in arguments
                  through <varname>argv</varname>. This is definitely the case
                  when using <ulink
                  url="https://realityforge.vrsource.org/trac/maestro/">Maestro</ulink>.</para>

                  <para>If a VR Juggler application will be run on Mac OS X,
                  the programmer has to decide whether command line processing
                  is critical to the execution of the application. There are
                  three options available to VR Juggler programmers on Mac OS
                  X: rely exclusively on command line arguments to launch,
                  handle no command line arguments, or allow the use of
                  command line arguments but do not require them. Given that
                  VR Juggler applications written on all other platforms are
                  highly likely to rely exclusively on command line arguments
                  to launch, the first choice is expected to be the most
                  commonly chosen approach. Nevertheless, we will explain all
                  three.</para>

                  <section>
                     <title>Relying Exclusively on Command Line Arguments to
                     Launch</title>

                     <para>If a VR Juggler application used on Mac OS X will
                     rely solely on command line arguments to launch, it is
                     operating in exactly the same manner as on all other
                     platforms. The <function>main()</function> function can
                     be written as is shown in this document to exit if no
                     command line arguments are supplied. There is still one
                     more thing to do, though. In the
                     <filename>Resources</filename> directory of the
                     application bundle, there must be a property list file in
                     the bundle called
                     <filename>Contents/Resources/vrjuggler.plist</filename>.
                     This property list must have the property
                     <literal>VRJConfigHandling</literal> set to
                     <literal>false</literal>. This is the default setting for
                     this property if the <filename>vrjuggler.plist</filename>
                     file that comes with VR Juggler was used in constructing
                     the application bundle.</para>

                     <para>To execute the application, run the program in
                     <filename>&lt;appname&gt;.app/Contents/MacOS</filename>
                     from a command prompt and pass in the command line
                     arguments. The appropriate event handling will be set up
                     so that the application will behave just as any other Mac
                     OS X application.</para>
                  </section>

                  <section>
                     <title>Handling No Command Line Arguments at Launch
                     Time</title>

                     <para>If no command line arguments are to be handled
                     (i.e., the application is to behave the same as typical
                     Mac OS X applications), then the
                     <function>main()</function> function shown above needs to
                     change. Specifically, it cannot exit with an error
                     message if no command line arguments are passed in. To
                     keep the application portable, a preprocessor conditional
                     can be used, as shown in <xref
                     linkend="example.cocoa.no.cmd.flags" />. Then, in
                     <filename>Contents/Resources/vrjuggler.plist</filename>,
                     set the <literal>VRJConfigHandling</literal> property to
                     <literal>true</literal>. To execute the application,
                     double-click the application bundle icon in the
                     <application>Finder</application> or use the
                     <command>open</command> command from a command
                     prompt.</para>

                     <example id="example.cocoa.no.cmd.flags">
                        <title>Ignoring Command Line Arguments on Mac OS
                        X</title>

                        <programlisting linenumbering="numbered">@include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;vrj/Kernel/Kernel.h&gt;
#include &lt;simpleApp.h&gt;

int main(int argc, char* argv[])
{
#if ! defined(VRJ_USE_COCOA)
   if ( argc &lt;= 1 )
   {
      std::cout &lt;&lt; "Usage: " &lt;&lt; argv[0]
                &lt;&lt; "cfgfile[0] cfgfile[1] ... cfgfile[n]"
                &lt;&lt; std::endl;
      std::exit(EXIT_FAILURE);
   }
#endif

   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   simpleApp* app      = new simpleApp();         // Create the app object

#if ! defined(VRJ_USE_COCOA)
   kernel-&gt;loadConfigFile(...);             // Configure the kernel
#endif
   kernel-&gt;start();                         // Start the kernel thread
   kernel-&gt;setApplication(app);             // Give application to kernel
   kernel-&gt;waitForKernelStop();             // Block until kernel stops

   return 0;
}</programlisting>
                     </example>
                  </section>

                  <section>
                     <title>Allowing Optional Use of Command Line
                     Arguments</title>

                     <para>A compromise can be struck between the previous two
                     options by allowing optional use of command line
                     arguments. The compromise is simple: do not require
                     command line arguments but still handle them if they are
                     given. The form of the main() function that allows this
                     is shown in <xref
                     linkend="example.cocoa.optional.cmd.flags" />. Note that
                     the <literal>#if</literal> around the call to
                     <methodname>vrj::Kernel::loadConfigFile()</methodname>
                     has been removed.</para>

                     <example id="example.cocoa.optional.cmd.flags">
                        <title>Handling Optional Command Line Arguments on Mac
                        OS X</title>

                        <programlisting linenumbering="numbered">@include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;vrj/Kernel/Kernel.h&gt;
#include &lt;simpleApp.h&gt;

int main(int argc, char* argv[])
{
#if ! defined(VRJ_USE_COCOA)
   if ( argc &lt;= 1 )
   {
      std::cout &lt;&lt; "Usage: " &lt;&lt; argv[0]
                &lt;&lt; "cfgfile[0] cfgfile[1] ... cfgfile[n]"
                &lt;&lt; std::endl;
      std::exit(EXIT_FAILURE);
   }
#endif

   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   simpleApp* app      = new simpleApp();         // Create the app object

   kernel-&gt;loadConfigFile(...);             // Configure the kernel
   kernel-&gt;start();                         // Start the kernel thread
   kernel-&gt;setApplication(app);             // Give application to kernel
   kernel-&gt;waitForKernelStop();             // Block until kernel stops

   return 0;
}</programlisting>
                     </example>

                     <para>The only decision left to make is what value to use
                     for the <literal>VRJConfigHandling</literal> property in
                     <filename>Contents/Resources/vrjuggler.plist</filename>.
                     If we set it to <filename>false</filename> (recall that
                     that is the default in the
                     <filename>$VJ_BASE_DIR/share/vrjuggler/data/bundle/vrjuggler.plist</filename>
                     version), the application cannot be used as a handler for
                     VR Juggler configuration files. If we set it to true, we
                     have to be prepared for configuration files to come in
                     other than through the command line or through the use of
                     the <guimenu>File</guimenu> menu. The default
                     <classname>NSApplication</classname> delegate
                     (<classname>VRJBasicDelegate</classname>) can deal with
                     either case. The default behavior for VR Juggler sample
                     applications is to allow configuration files to be
                     specified on the command line through the use of a
                     <function>main()</function> function similar to that
                     shown in <xref
                     linkend="example.cocoa.optional.cmd.flags" /> and to
                     leave the property <literal>VRJConfigHandling</literal>
                     in
                     <filename>Contents/Resources/vrjuggler.plist</filename>
                     set to <literal>false</literal>.</para>
                  </section>
               </section>
            </section>
         </section>

         <section>
            <title>Kernel Loop</title>

            <para>Before proceeding into application object details, we must
            understand how VR Juggler calls the application, and we must know
            what a <glossterm
            linkend="gloss.frame">frame</glossterm><indexterm>
                  <primary>frame</primary>
               </indexterm> is. In the code above, the statement on line 9
            tells the kernel thread to start running. When the kernel begins
            its execution, it follows the sequence shown in <xref
            linkend="figure.kernel.loop.sequence" />. The specific methods
            called are described in more detail in the following section. This
            diagram will be useful in understanding the order in which the
            application object methods are invoked.</para>

            <figure id="figure.kernel.loop.sequence">
               <title>Kernel loop sequence</title>

               <mediaobject>
                  <imageobject>
                     <imagedata align="center"
                                fileref="figures/Kernel_Loop_Call_Sequence.png"
                                format="PNG" scalefit="1" />
                  </imageobject>
               </mediaobject>
            </figure>

            <section id="section.frame.definition">
               <title>Definition of a Frame</title>

               <indexterm zone="section.frame.definition">
                  <primary>frame</primary>

                  <secondary>definition of</secondary>
               </indexterm>

               <para>The VR Juggler kernel calls each of the methods in the
               application object based on a strictly scheduled
               <firstterm>frame of execution</firstterm><indexterm>
                     <primary>frame of execution</primary>
                  </indexterm>. The frame of execution is shown in <xref
               linkend="figure.kernel.loop.sequence" />; it makes up all the
               lines within the <quote>while(!quit)</quote> clause.</para>

               <para>During the frame of execution, the kernel calls the
               application methods and performs internal updates (the
               <methodname>updateAllData()</methodname> method call). Because
               the kernel has complete control over the frame, it can make
               changes at pre-defined <quote>safe</quote> times when the
               application is not doing any processing. At these times, the
               kernel can change the virtual platform configuration as long as
               the interface remains the same.</para>

               <para>The frame of execution also serves as a framework for the
               application. That is, the application can expect that when
               <methodname>preFrame()</methodname> is called, the devices have
               just been updated. Applications can rely upon the system being
               in well-defined stages of the frame when the kernel invokes the
               application object's methods.</para>
            </section>
         </section>

         <section id="section.base.app.obj.interface">
            <title>Base Application Object Interface</title>

            <indexterm zone="section.base.app.obj.interface">
               <primary>application object</primary>

               <secondary>base interface of</secondary>
            </indexterm>

            <para>Within this section, we provide a brief overview of the
            member functions from the base VR Juggler application interface.
            This interface is defined by
            <classname>vrj::App</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vrj::App</secondary>
               </indexterm>, and the member functions are shown in <xref
            linkend="figure.app.obj.interface" />. Refer to <xref
            linkend="figure.kernel.loop.sequence" /> for a visual presentation
            of the order in which the methods are invoked.</para>

            <para>The base interface of the application object defines the
            following functions:</para>

            <itemizedlist>
               <listitem>
                  <para><methodname>init()</methodname></para>
               </listitem>

               <listitem>
                  <para><methodname>apiInit()</methodname></para>
               </listitem>

               <listitem>
                  <para><methodname>preFrame()</methodname></para>
               </listitem>

               <listitem>
                  <para><methodname>intraFrame()</methodname></para>
               </listitem>

               <listitem>
                  <para><methodname>postFrame()</methodname></para>
               </listitem>
            </itemizedlist>

            <para>As previously described, the VR Juggler kernel calls these
            functions from its control loop to allocate processing time to
            them. These functions handle initialization and computation. Other
            member functions that can be used for reconfiguration, focus
            control, resetting, and exiting will be covered later in this
            book.</para>

            <figure id="figure.app.obj.interface">
               <title>Application object interface</title>

               <mediaobject>
                  <imageobject>
                     <imagedata align="center"
                                fileref="figures/userOglApp_hierarchy.png"
                                format="PNG" />
                  </imageobject>
               </mediaobject>
            </figure>

            <section id="section.app.obj.init">
               <title>Initialization</title>

               <indexterm zone="section.app.obj.init">
                  <primary>application object</primary>

                  <secondary>initialization</secondary>
               </indexterm>

               <para>The following is a description of the application objects
               related to the initialization of a VR Juggler application. The
               order of presentation is the same as the order of execution
               when the application is executed by the kernel.</para>

               <section>
                  <title><methodname>vrj::App::init()</methodname></title>

                  <para>The <methodname>init()</methodname> method is called
                  by the kernel to initialize any application data. When the
                  kernel prepares to start a new application, it first calls
                  <methodname>init()</methodname> to signal the application
                  that it is about to be executed.</para>

                  <section>
                     <title>Timing</title>

                     <para>This member function is called immediately after
                     the kernel is told to start running the application and
                     before any graphics API handling has been started by VR
                     Juggler.</para>
                  </section>

                  <section>
                     <title>Uses</title>

                     <para>Typical applications will utilize this method to
                     load data files, create lookup tables, or perform some
                     steps that should be done only once per execution. In
                     other words, this method is the place to perform any
                     pre-processing steps needed by the application to set up
                     its data structures.</para>
                  </section>
               </section>

               <section>
                  <title><methodname>vrj::App::apiInit()</methodname></title>

                  <para>This member function is for any graphics API-specific
                  initialization required by the application. Data members
                  that cannot be initialized until after the graphics API is
                  started should be initialized here.</para>

                  <note>
                     <para>In OpenGL, there is no concept of initializing the
                     API, so this method is normally empty in such
                     applications.</para>
                  </note>

                  <section>
                     <title>Timing</title>

                     <para>This member function is called after the graphics
                     API has been started but before the kernel frame is
                     started.</para>
                  </section>

                  <section>
                     <title>Uses</title>

                     <para>In most cases, scene graph loading and other
                     API-specific initialization should be done in this
                     method.</para>
                  </section>
               </section>
            </section>

            <section id="section.app.frame.functions">
               <title>Frame Functions</title>

               <indexterm zone="section.app.frame.functions">
                  <primary>application object</primary>

                  <secondary>frame functions</secondary>
               </indexterm>

               <para>Once the application object has been initialized by the
               VR Juggler kernel, the kernel frame loop begins. Each frame,
               there are specific application object methods that are invoked,
               and understanding the timing and potential uses of these
               methods can improve the functionality of the immersive
               application. In some cases, it is possible to use these member
               functions to optimize the application to improve the frame rate
               and the level of interactivity.</para>

               <section id="section.getDrawScaleFactor">
                  <title><methodname>vrj::App::getDrawScaleFactor()</methodname></title>

                  <para>As of VR Juggler 2.0 Alpha 1, applications can specify
                  the units of measure that are the basis for the graphics
                  they render. The default unit of measure is feet (identified
                  by the constant scale factor
                  <constant>gadget::PositionUnitConversion::ConvertToFeet</constant>)
                  to maintain backwards compatibility with the previous VR
                  Juggler semantics. By overriding this method, applications
                  can identify the unit of measure they expect. The default
                  implementation is the following:</para>

                  <programlisting>float vrj::App::getDrawScaleFactor()
{
   return gadget::PositionUnitConversion::ConvertToFeet;
}</programlisting>

                  <para>Overriding this method means changing the rendering
                  scale factor used by the VR Juggler Draw Managers. The
                  current list of constants (defined in
                  <filename>gadget/Position/PositionUnitConversion.h</filename>)
                  is as follows:</para>

                  <itemizedlist>
                     <listitem>
                        <para><constant>gadget::PositionUnitConversion::ConvertToFeet</constant></para>
                     </listitem>

                     <listitem>
                        <para><constant>gadget::PositionUnitConversion::ConvertToInches</constant></para>
                     </listitem>

                     <listitem>
                        <para><constant>gadget::PositionUnitConversion::ConvertToMeters</constant></para>
                     </listitem>

                     <listitem>
                        <para><constant>gadget::PositionUnitConversion::ConvertToCentimeters</constant></para>
                     </listitem>
                  </itemizedlist>

                  <para>Because the value returned is simply a scaling factor,
                  user applications can define whatever units they want. Note
                  that internally, VR Juggler is treating all units as
                  <emphasis>meters</emphasis>, so the scaling factor converts
                  from meters to the desired units.</para>
               </section>

               <section>
                  <title><methodname>vrj::App::preFrame()</methodname></title>

                  <para>The <methodname>preFrame()</methodname> method is
                  called when the system is about to trigger drawing. This is
                  the time that the application object should do any
                  last-minute updates of data based on input device status. It
                  is best to avoid doing any time-consuming computation in
                  this method. The time used in this method contributes to the
                  overall device latency in the system. The devices will not
                  be re-sampled before rendering begins.</para>

                  <section>
                     <title>Timing</title>

                     <para>This method is called before triggering rendering
                     of the current frame.</para>
                  </section>

                  <section>
                     <title>Uses</title>

                     <para>In general, this method should be reserved for
                     <quote>last-millisecond</quote> data updates in response
                     to device input (latency-critical code).</para>
                  </section>
               </section>

               <section>
                  <title><methodname>vrj::App::latePreFrame()</methodname></title>

                  <para>The <methodname>latePreFrame()</methodname> method is
                  called after <classname>preFrame()</classname> and after
                  shared application-specific data is synchronized among the
                  cluster nodes (see <xref linkend="section.cluster.apps" />
                  for more details) but before the scene is rendered. Scene
                  graph-based application objects making use of
                  application-specific data in a cluster configuration should
                  perform scene graph updates based on the most recently
                  received copy of the shared application data. Application
                  objects not using a scene graph can make state updates in
                  this method or in the rendering method
                  (<methodname>draw()</methodname> in the case of
                  <classname>vrj::GlApp</classname>). The writer node must
                  have written to the shared application data in
                  <methodname>preFrame()</methodname> to minimize the latency
                  of the data.</para>

                  <section>
                     <title>Timing</title>

                     <para>This method is called after application-specific
                     data is sychronized among the cluster nodes but before
                     triggering rendering of the current frame.</para>
                  </section>

                  <section>
                     <title>Uses</title>

                     <para>When using shared application-specific data with a
                     scene-graph based application object in a cluster
                     configuration, the nodes that read from the shared data
                     (those where
                     <methodname>cluster::UserData&lt;T&gt;::isLocal()</methodname>
                     returns false) should perform state updates based on the
                     freshly received update to the shared data.</para>
                  </section>
               </section>

               <section id="section.app.intraFrame">
                  <title><methodname>vrj::App::intraFrame()</methodname></title>

                  <para>The code in this method executes in parallel with the
                  rendering method. That is, it executes while the current
                  frame is being drawn. This is the place to put any
                  processing that can be done in advance for the next frame.
                  By doing parallel processing in this method, the application
                  can increase its frame rate because drawing and computation
                  can be parallelized. Special care must be taken to ensure
                  that any data being used for rendering does not change while
                  rendering is happening. One method for doing this is
                  buffering. Use of synchronization primitives is not
                  recommended because that technique could
                  <emphasis>lower</emphasis> the frame rate.</para>

                  <section>
                     <title>Timing</title>

                     <para>This method is invoked after rendering has been
                     triggered but before the rendering has finished.</para>
                  </section>

                  <section>
                     <title>Uses</title>

                     <para>The primary use of this method is performing
                     time-consuming computations, the results of which can be
                     used in the next frame.</para>
                  </section>
               </section>

               <section>
                  <title><methodname>vrj::App::postFrame()</methodname></title>

                  <para>Finally, the <methodname>postFrame()</methodname>
                  method is available for final processing at the end of the
                  kernel frame loop. This is a good place to do any data
                  updates that are not dependent upon input data and cannot be
                  overlapped with the rendering process (see the discussion on
                  <methodname>vrj::App::intraFrame()</methodname>
                  above).</para>

                  <section>
                     <title>Timing</title>

                     <para>This method is invoked after rendering has
                     completed but before VR Juggler updates devices and other
                     internal data.</para>
                  </section>

                  <section>
                     <title>Uses</title>

                     <para>Some possible uses of this method include
                     <quote>cleaning up</quote> after the frame has been
                     rendered or synchronizing with external networking or
                     computational processes.</para>
                  </section>
               </section>
            </section>
         </section>

         <section id="section.draw.mgr.classes">
            <title>Draw Manager-Specific Application Classes</title>

            <indexterm>
               <primary>Draw Manager</primary>

               <secondary>application classes</secondary>
            </indexterm>

            <para>Beyond the basic methods common to all applications, there
            are methods that are specific to a given Draw Manager. The
            application classes are extended for each of the specific Draw
            Managers. The graphics API-specific application classes derive
            from <classname>vrj::App</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vrj::App</secondary>
               </indexterm> and extend this interface further. They add extra
            <quote>hooks</quote> that support the abilities of the specific
            API.</para>

            <section id="section.draw.mgr.opengl.classes">
               <title>OpenGL Application Class</title>

               <indexterm zone="section.draw.mgr.opengl.classes">
                  <primary>Draw Manager</primary>

                  <secondary>application classes</secondary>

                  <tertiary>OpenGL</tertiary>
               </indexterm>

               <para>The OpenGL application base class adds several methods to
               the application interface that allow rendering of OpenGL
               graphics. The extensions to the base
               <classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::App</secondary>
                  </indexterm> class are shown in <xref
               linkend="figure.vrj.GlApp" />. In the following, we describe
               the method <methodname>vrj::GlApp::draw()</methodname>, the
               most important element of the interface. More details about the
               <classname>vrj::GlApp</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::GlApp</secondary>
                  </indexterm> class are provided in <xref
               linkend="section.opengl.apps" />, found in <xref
               linkend="chapter.writing.apps" />.</para>

               <figure id="figure.vrj.GlApp">
                  <title><classname>vrj::GlApp</classname> interface
                  extensions to <classname>vrj::App</classname></title>

                  <mediaobject>
                     <imageobject>
                        <imagedata align="center"
                                   fileref="figures/GlAppHierarchy.png"
                                   format="PNG" />
                     </imageobject>
                  </mediaobject>
               </figure>

               <section>
                  <title><methodname>vrj::GlApp::draw()</methodname></title>

                  <para>The <quote>draw function</quote> is called by the
                  OpenGL Draw Manager when it needs to render the current
                  scene in an OpenGL graphics window. It is called for each
                  active OpenGL context.</para>
               </section>
            </section>

            <section id="section.draw.mgr.performer">
               <title>OpenGL Performer Application Class</title>

               <indexterm zone="section.draw.mgr.performer">
                  <primary>Draw Manager</primary>

                  <secondary>application classes</secondary>

                  <tertiary>OpenGL Performer</tertiary>
               </indexterm>

               <para>The OpenGL Performer application base class adds
               interface functions that deal with the OpenGL Performer scene
               graph. Some of the interface extensions are shown in <xref
               linkend="figure.vrj.PfApp" />. The following is a description
               of only two methods in the
               <classname>vrj::PfApp</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::PfApp</secondary>
                  </indexterm> interface. More detailed discussion on this
               class is provided in <xref linkend="section.pf.apps" />, found
               in <xref linkend="chapter.writing.apps" />.</para>

               <figure id="figure.vrj.PfApp">
                  <title><classname>vrj::PfApp</classname> interface
                  extensions to <classname>vrj::App</classname></title>

                  <mediaobject>
                     <imageobject>
                        <imagedata align="center"
                                   fileref="figures/userPfApp_hierarchy.png"
                                   format="PNG" />
                     </imageobject>
                  </mediaobject>
               </figure>

               <section>
                  <title><methodname>vrj::PfApp::initScene()</methodname></title>

                  <para>The <methodname>initScene()</methodname> member
                  function is called when the application should create the
                  scene graph it will use.</para>
               </section>

               <section>
                  <title><methodname>vrj::PfApp::getScene()</methodname></title>

                  <para>The <methodname>getScene()</methodname> member
                  function is called by the Performer Draw Manager when it
                  needs to know what scene graph it should render for the
                  application.</para>
               </section>
            </section>
         </section>
      </chapter>

      <chapter id="chapter.helper.classes">
         <title>Helper Classes</title>

         <para>Within this chapter, we present information on some helper
         classes that are provided for use with VR Juggler. These classes are
         intended to make it easier for application programmers to write their
         code. Ultimately, we want application programmers to focus more on
         compelling immersive content and less on the many details that are
         involved with 3D graphics programming. The classes presented in this
         chapter focus on mathematical computations and on input from hardware
         devices. VR Juggler uses the Graphics Math Template Library or GMTL
         (part of the <ulink url="http://ggt.sf.net/">Generic Graphics
         Toolkit</ulink> software) for mathematical computation. An overview
         of the most commonly used GMTL data types and operations is presented
         here. In addition to the GMTL operations, special attention is paid
         to Gadgeteer, the input system used by VR Juggler, and its device
         interfaces and device proxies.</para>

         <section id="section.vec.classes">
            <title>The <classname>gmtl::Vec&lt;S, T&gt;</classname> Helper
            Class</title>

            <indexterm>
               <primary>gmtl::Vec&lt;S, T&gt;</primary>
            </indexterm>

            <para>This section is intended to provide an introduction to how
            the helper class <classname>gmtl::Vec&lt;S,
            T&gt;</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gmtl::Vec&lt;S, T&gt;</secondary>

                  <seealso>gmtl::Vec3f, gmtl::Vec4f</seealso>
               </indexterm> works and how it can be used in VR Juggler
            applications. It begins with a high-level description of the
            classes which forms the necessary basis for understanding them in
            detail. Then, examples of how to use all the available operations
            in the interfaces for these classes are provided. It concludes
            with a description of the internal details of the classes.</para>

            <section>
               <title>High-Level Description</title>

               <indexterm>
                  <primary>gmtl::Vec&lt;S, T&gt;</primary>

                  <secondary>description of</secondary>
               </indexterm>

               <para>The class <classname>gmtl::Vec&lt;S,
               T&gt;</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gmtl::Vec&lt;S, T&gt;</secondary>
                  </indexterm> is designed to work the same way as a
               mathematical vector, typically of 3 or 4 dimensions. There are
               predefined vector types that would normally be used in a VR
               application that are provided for convenience. That is, a
               <classname>gmtl::Vec3f</classname> object can be thought of as
               a vector of the form &lt;x, y, z&gt;. Similarly, a
               <classname>gmtl::Vec4f</classname> can be thought of as a
               vector of the form &lt;x, y, z, w&gt;. An existing
               understanding of mathematical vectors is sufficient to know how
               these classes can be used. The question then becomes, how are
               they used? We will get to that later, and readers who have
               experience with vectors can skip ahead. If vectors are an
               unfamiliar topic, it may be convenient to think of these
               classes as three- and four-element C++ arrays of
               <type>float</type>s respectively. Most benefits of the vector
               concept are lost with that simpler idea, however. Therefore, if
               the reader needs to think of them as arrays, then arrays should
               probably be used until vectors feel more comfortable. Once the
               use of vectors seems familiar and straightforward, readers are
               encouraged to come back and read further.</para>

               <para>Vectors are typically used to contain spatial data or
               something similar. For convenience, however, they can be
               visualized as a more general-purpose container for numerical
               data upon which well-defined operations can be performed. There
               is no need to constrain thinking of them as only holding the
               coordinates for some point in space or some other limited-scope
               use. The GMTL vectors use by VR Juggler retain this generality
               and can be used wherever vectors come in handy.</para>

               <para><classname>gmtl::Vec3f</classname> and
               <classname>gmtl::Vec4f</classname>, as specific implementations
               of mathematical vectors, hide vector operations on
               single-precision floating-point numbers (<type>float</type>)
               behind a simple-to-use interface. For a single vector, the
               following standard vector operations are available:</para>

               <itemizedlist>
                  <listitem>
                     <para>Inversion (changing the sign of all
                     elements)</para>
                  </listitem>

                  <listitem>
                     <para>Normalization</para>
                  </listitem>

                  <listitem>
                     <para>Calculation of length</para>
                  </listitem>

                  <listitem>
                     <para>Multiplication by a scalar</para>
                  </listitem>

                  <listitem>
                     <para>Division by a scalar</para>
                  </listitem>

                  <listitem>
                     <para>Conversion to a Performer vector</para>
                  </listitem>
               </itemizedlist>

               <para>For two vectors, the following operations can be
               performed:</para>

               <itemizedlist>
                  <listitem>
                     <para>Assignment</para>
                  </listitem>

                  <listitem>
                     <para>Equality/inequality comparison</para>
                  </listitem>

                  <listitem>
                     <para>Dot product</para>
                  </listitem>

                  <listitem>
                     <para>Cross product</para>
                  </listitem>

                  <listitem>
                     <para>Addition</para>
                  </listitem>

                  <listitem>
                     <para>Subtraction</para>
                  </listitem>
               </itemizedlist>

               <para>Using GMTL vectors should be straightforward if readers
               understand these operations and keep in mind that
               <classname>gmtl::Vec3f</classname> and
               <classname>gmtl::Vec4f</classname> can be thought of at this
               high level.</para>
            </section>

            <section id="section.gmtl.Vec.use">
               <title>Using <classname>gmtl::Vec3f</classname> and
               <classname>gmtl::Vec4f</classname></title>

               <indexterm zone="section.gmtl.Vec.use">
                  <primary>classes</primary>

                  <secondary>gmtl::Vec3f</secondary>
               </indexterm>

               <indexterm zone="section.gmtl.Vec.use">
                  <primary>classes</primary>

                  <secondary>gmtl::Vec4f</secondary>
               </indexterm>

               <para>With an understanding of these classes as standard
               mathematical vectors, it is time to learn how to deal with them
               at the C++ level. In some cases, the mathematical operators are
               overloaded to simplify user code; in other cases, a named
               method must be invoked on an object. Before any of that,
               however, make sure that the source file includes the
               <filename>gmtl/Vec.h</filename> header file. From here on, the
               available operations are presented in the order they were
               listed in the previous section. We begin with creating the
               objects and setting their values.</para>
            </section>

            <section id="section.gmtl.Vec.creation">
               <title>Creating Vectors and Setting Their Values</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>creating</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>creating</secondary>
               </indexterm>

               <para>Before doing anything with vectors, some must be created.
               The examples here use <classname>gmtl::Vec3f</classname>, but
               the example is equally applicable to
               <classname>gmtl::Vec4f</classname>. To create a
               <classname>gmtl::Vec3f</classname>, use the default constructor
               which initializes the vector to &lt;0.0, 0.0, 0.0&gt;:</para>

               <programlisting>gmtl::Vec3f vec1;</programlisting>

               <para>After creating the vector <varname>vec1</varname>, its
               elements can be assigned values all at once as follows:</para>

               <programlisting>vec1.set(1.0, 1.5, -1.0);</programlisting>

               <para>or individually:</para>

               <programlisting>vec1[0] = 1.0;
vec1[1] = 1.5;
vec1[2] = -1.0;</programlisting>

               <para>Note that in the last example, the individual elements of
               the vector can be accessed exactly as with a normal array. To
               do the above steps all at once when the vector is created, give
               the element values when declaring the vector:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);</programlisting>

               <para>All of the above code has exactly the same results but
               accomplishes them in different ways. This flexibility is just
               one of the ways that GMTL vectors are more powerful than C++
               arrays (of the same size, of course).</para>
            </section>

            <section id="section.gmtl.Vec.inversion">
               <title>Inversion (Finding the Negative of a Vector)</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>inverting</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>inverting</secondary>
               </indexterm>

               <para>Once a vector is created, the simplest operation that can
               be performed on it is finding its inverse. The following code
               demonstrates just that:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = -vec1;</programlisting>

               <para>The vector <varname>vec2</varname> now has the value
               &lt;-1.0, -1.5, 1.0&gt;. That is all there is to it. (Readers
               interested in details should note that the above does a copy
               operation to return the negative values.)</para>
            </section>

            <section>
               <title>Normalization</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>normalizing</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>normalizing</secondary>
               </indexterm>

               <para>Normalizing a vector is another simple operation (at the
               interface level anyway). The following code normalizes a
               vector:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

gmtl::normalize( vec1 );</programlisting>

               <para>The vector <varname>vec1</varname> is now normalized.
               Clean and simple.</para>

               <para>Besides normalizing a given vector, a vector can be
               tested to determine if it has already been normalized. This is
               done as follows (assuming the vector <varname>vec</varname> has
               already been declared before this point):</para>

               <programlisting>if ( gmtl::isNormalized( vec1 ) )
{
   // Go here if vec is normalized
}</programlisting>
            </section>

            <section>
               <title>Length Calculation</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>length of</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>length of</secondary>
               </indexterm>

               <para>Part of normalizing a vector requires finding its length
               first. To get a vector's length, do the following:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);
float length;

length = gmtl::length( vec1 );</programlisting>

               <para>In this case, length is assigned the value 2.061553 (or
               more accurately, the square root of 4.25). Finding the length
               of a vector appears simple from the programmer's perspective,
               but it has some hidden costs. Namely, it requires a square root
               calculation. For optimization purposes, GMTL provides a
               function called <function>gmtl::lengthSquared()</function> that
               returns the length of the vector without calculating the square
               root.</para>
            </section>

            <section>
               <title>Multiplication by a Scalar</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>multiplying by a scalar</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>multiplying by a scalar</secondary>
               </indexterm>

               <para>The GMTL vector classes provide an easy way to multiply a
               vector by a scalar. There are several ways to do it depending
               on what is required. Examples of each method follow.</para>

               <para>To multiply a vector by a scalar and store the result in
               another vector, do the following:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = 3 * vec1;</programlisting>

               <para>(The order of the factors in the multiplication can be
               swapped depending on preference or need.) Here,
               <varname>vec2</varname> gets the value &lt;3.0, 4.5,
               -3.0&gt;.</para>

               <para>To multiply a vector by a scalar and store the result in
               the same vector, do the following:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

vec1 *= 3;</programlisting>

               <para>After this, <varname>vec1</varname> has the value
               &lt;3.0, 4.5, -3.0&gt;.</para>
            </section>

            <section>
               <title>Division by a Scalar</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>dividing by a scalar</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>dividing by a scalar</secondary>
               </indexterm>

               <para>Very similar to multiplying by a scalar, division by
               scalars is also possible. While the examples are almost
               identical, they are provided here for clarity.</para>

               <para>To divide a vector by a scalar and store the result in
               another vector, do the following:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = vec1 / 3;</programlisting>

               <para>Here, <varname>vec2</varname> gets the value
               &lt;0.333333, 0.5, -0.333333&gt;. Note that the scalar must
               come after the vector because the operation would not make
               sense otherwise.</para>

               <para>To divide a vector by a scalar and store the result in
               the same vector, do the following:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

vec1 /= 3;</programlisting>

               <para>After this, <varname>vec1</varname> has the value
               &lt;0.333333, 0.5, -0.333333&gt;.</para>
            </section>

            <section id="section.pfVec.to.gmtl.Vec">
               <title>Converting to an OpenGL Performer Vector</title>

               <indexterm zone="section.pfVec.to.gmtl.Vec">
                  <primary>gmtl::Vec3f</primary>

                  <secondary>converting to pfVec3</secondary>
               </indexterm>

               <indexterm zone="section.pfVec.to.gmtl.Vec">
                  <primary>pfVec3</primary>

                  <secondary>converting from gmtl::Vec3f</secondary>

                  <seealso>gmtl::Vec3f</seealso>
               </indexterm>

               <para>SGI's OpenGL Performer likes to work with its own
               <classname>pfVec3</classname> class, and to facilitate the use
               of it with <classname>gmtl::Vec3f</classname>, two conversion
               functions are provided for converting a
               <classname>gmtl::Vec3f</classname> to a
               <classname>pfVec3</classname> and vice versa. The first works
               as follows:</para>

               <programlisting>gmtl::Vec3f vj_vec;
pfVec3 pf_vec;

// Do stuff to vj_vec...

pf_vec = vrj::GetPfVec(vj_vec);</programlisting>

               <para>where <varname>vj_vec</varname> is passed by reference
               for efficiency. (<varname>pf_vec</varname> gets a copy of a
               <classname>pfVec3</classname>.) To convert a
               <classname>pfVec3</classname> to a
               <classname>gmtl::Vec3f</classname>, do the following:</para>

               <programlisting>pfVec3 pf_vec;
gmtl::Vec3f vj_vec;

// Do stuff to pf_vec...

vj_vec = vrj::GetVjVec(pf_vec);</programlisting>

               <para>Here again, <varname>pf_vec</varname> is passed by
               reference for efficiency, and <varname>vj_vec</varname> gets a
               copy of a <classname>gmtl::Vec3f</classname>. Both of these
               functions are found in the header
               <filename>vrj/Draw/Pf/PfUtil.h</filename>.</para>
            </section>

            <section>
               <title>Assignment</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>assigning</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>assigning</secondary>
               </indexterm>

               <para>We have already demonstrated vector assignment, though it
               was not pointed out explicitly. It works just as vector
               assignment in mathematics. The C++ code that does assignment is
               as follows:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = vec1;</programlisting>

               <para>After the assignment, <varname>vec2</varname> has the
               value &lt;-1.0, -1.5, 1.0&gt;. Ta da! Note that this is a copy
               operation which is the case for all the types of assignments of
               GMTL vectors.</para>
            </section>

            <section>
               <title>Equality/Inequality Comparison</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>equality comparison</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>equality comparison</secondary>
               </indexterm>

               <para>To compare the equality of two vectors, there are three
               available methods (one is just the complement of the other,
               though):</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( gmtl::isEqual(vec1, vec2) )
{
   // Go here if vec1 and vec2 are equal.
}</programlisting>

               <para>or</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1 == vec2 )
{
   // Go here if vec1 and vec2 are equal.
}</programlisting>

               <para>or</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1 != vec2 )
{
   // Go here if vec1 and vec2 are not equal.
}</programlisting>

               <para>Choose whichever method is most convenient.</para>
            </section>

            <section>
               <title>Dot Product</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>dot product</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>dot product</secondary>
               </indexterm>

               <para>Given two vectors, finding the dot product is often
               needed. GMTL vectors provide a way to do this quickly so that
               programmers can save themselves the time of typing in the
               formula over and over. It works as follows:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);
float dot_product;

dot_product = gmtl::dot(vec1, vec2);</programlisting>

               <para>Now, <varname>dot_product</varname> has the value
               4.0.</para>
            </section>

            <section>
               <title>Cross Product</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>cross product</secondary>
               </indexterm>

               <para>Besides the dot product of two vectors, the cross product
               is another commonly needed result. It is calculated
               thusly:</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = gmtl::cross(vec1, vec2);</programlisting>

               <para>The result is that <varname>vec3</varname> gets a copy of
               <varname>vec1</varname> cross <varname>vec2</varname>.</para>
            </section>

            <section>
               <title>Addition</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>adding</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>adding</secondary>
               </indexterm>

               <para>Adding two vectors can be done one of two ways. The first
               method returns a resulting vector, and the second method
               performs the addition and stores the result in the first
               vector.</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1 + vec2;</programlisting>

               <para>Now, <varname>vec3</varname> has the value &lt;2.5, 2.5,
               -2.0&gt;.</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

vec1 += vec2;</programlisting>

               <para>This time, <varname>vec1</varname> has the value &lt;2.5,
               2.5, -2.0&gt;.</para>
            </section>

            <section>
               <title>Subtraction</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>subtracting</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>subtracting</secondary>
               </indexterm>

               <para>Subtracting two vectors gives the same options as
               addition, and while the code is nearly identical, it is
               provided for the sake of clarity.</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1 - vec2;</programlisting>

               <para>Now, <varname>vec3</varname> has the value &lt;-0.5, 0.5,
               0.0&gt;.</para>

               <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

vec1 -= vec2;</programlisting>

               <para>In this case, <varname>vec1</varname> has the value
               &lt;-0.5, 0.5, 0.0&gt;.</para>
            </section>

            <section>
               <title>Full Transformation by a Matrix</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>transforming by a matrix</secondary>

                  <tertiary>full</tertiary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>transforming by a matrix</secondary>

                  <tertiary>full</tertiary>
               </indexterm>

               <para>It is often helpful to apply a transformation to a
               vector. Transformations are represented by a matrix, so it is
               necessary to multiply a matrix and a vector. The function
               <function>gmtl::xform()</function> does this job. For the
               following example, assume that there is a
               <classname>gmtl::Matrix44f</classname> transformation matrix
               <varname>xform_mat</varname>:</para>

               <programlisting>gmtl::Vec3f vec(1.0, 1.0, 1.0), result_vec;

gmtl::xform(result_vec, xform_mat, vec1);</programlisting>

               <para>Depending on the transformations contained within
               <varname>xform_mat</varname>, <varname>result_vec</varname>
               will be transformed fully. The operation as a mathematical
               equation would be:</para>

               <informalequation>
                  <mediaobject>
                     <imageobject>
                        <imagedata fileref="figures/eq_v_eq_m_v.png"
                                   format="PNG" />
                     </imageobject>

                     <textobject>
                        <phrase>V' = M * V</phrase>
                     </textobject>

                     <textobject role="tex">
                        <phrase>V^{\prime }=M*V</phrase>
                     </textobject>
                  </mediaobject>
               </informalequation>

               <para>where V and V' are vectors and M is a 4×4 transformation
               matrix.</para>
            </section>

            <section>
               <title>The Gory Details</title>

               <indexterm>
                  <primary>gmtl::Vec3f</primary>

                  <secondary>details</secondary>
               </indexterm>

               <indexterm>
                  <primary>gmtl::Vec4f</primary>

                  <secondary>details</secondary>
               </indexterm>

               <para>The details behind <classname>gmtl::Vec3f</classname> and
               <classname>gmtl::Vec4f</classname> really are not all that
               gory. Internally, they are represented as three- and
               four-element arrays of <type>float</type>s respectively. Access
               to these arrays is provided through the member function
               <methodname>getData()</methodname>. For example, this access
               can be used in the following way:</para>

               <programlisting>gmtl::Vec3f pos(4.0, 1.0982, 10.1241);

glVertex3fv(pos.getData());</programlisting>

               <para>Granted, this particular example is rather silly and much
               slower than just listing the values as the individual arguments
               to <function>glVertex3f()</function>, but it should get the
               point across.</para>

               <para>In general, the <methodname>getData()</methodname> member
               function should be treated very carefully. Access to it is
               provided mainly so that operations similar to this example can
               be performed quickly. An example of abusing access to
               <methodname>getData()</methodname> follows:</para>

               <programlisting>gmtl::Vec4f my_vec;

my_vec.getData()[0] = 4.0;
my_vec.getData()[1] = 1.0982;
my_vec.getData()[2] = 10.1241;
my_vec.getData()[3] = 1.0;</programlisting>

               <para>Do not do this. It can be confusing to readers of the
               code who do not necessarily need to know the details of the
               internal representation. Instead, use one of the methods
               described above for creating vectors and assigning the elements
               values.</para>
            </section>
         </section>

         <section id="section.gmtl.Matrix44f">
            <title>The <classname>gmtl::Matrix44f</classname> Helper
            Class</title>

            <indexterm>
               <primary>gmtl::Matrix44f</primary>
            </indexterm>

            <para>This section is intended to provide an introduction into how
            the helper class <classname>gmtl::Matrix44f</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gmtl::Matrix44f</secondary>

                  <seealso>gmtl::Matrix44f</seealso>
               </indexterm> works and how it can be used in VR Juggler
            applications. It begins with a high-level description of the
            class, which forms the necessary basis for understanding it in
            detail. Then, examples of how to use all the available operations
            in the interfaces for the class are provided. It concludes with a
            description of the internal C++ details of
            <classname>gmtl::Matrix44f</classname>.</para>

            <section>
               <title>High-Level Description</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>description of</secondary>
               </indexterm>

               <para>Abstractly,
               <classname>gmtl::Matrix44f</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gmtl::Matrix44f</secondary>

                     <seealso>gmtl::Matrix44f</seealso>
                  </indexterm> represents a 4×4 matrix of single-precision
               floating-point values. The class includes implementations of
               the standard matrix operations such as transpose, scale, and
               multiply. More specifically, it is a mechanism to facilitate
               common matrix operations used in computer graphics, especially
               those associated with a <emphasis>transform</emphasis> matrix.
               On the surface, it is nearly identical to a 4×4 C++ array of
               <type>float</type>s, but there is one crucial difference: a
               <classname>gmtl::Matrix44f</classname> keeps its internal
               matrix in column-major order rather than in row-major
               order<indexterm>
                     <primary>gmtl::Matrix44f</primary>

                     <secondary>compared to C++ matrices</secondary>
                  </indexterm>. More detail on this is given below, but this
               is done because OpenGL maintains its internal matrices using
               the same memory layout. At the conceptual level, this does not
               matter—it is related only to the matrix representation in the
               computer's memory. Access to the elements is still in row-major
               order. In any case, understanding how C++ multidimensional
               arrays work means understanding 90% of what there is to know
               about <classname>gmtl::Matrix44f</classname>. The class
               provides a degree convenience not found with a normal C++
               array, especially when programming with OpenGL. The
               complications surrounding the
               <classname>gmtl::Matrix44f</classname> class are identical to
               those with OpenGL matrix handling, and with an understanding of
               that, then all that is left to learn is the interface of
               <classname>gmtl::Matrix44f</classname>.</para>

               <para>As a representation of mathematical matrices,
               <classname>gmtl::Matrix44f</classname> implements several
               common operations performed on matrices to relieve the users of
               some tedious, repetitive effort. The general mathematical
               operations are:</para>

               <itemizedlist>
                  <listitem>
                     <para>Assignment</para>
                  </listitem>

                  <listitem>
                     <para>Equality/inequality comparison</para>
                  </listitem>

                  <listitem>
                     <para>Transposing</para>
                  </listitem>

                  <listitem>
                     <para>Finding the inverse</para>
                  </listitem>

                  <listitem>
                     <para>Addition</para>
                  </listitem>

                  <listitem>
                     <para>Subtraction</para>
                  </listitem>

                  <listitem>
                     <para>Multiplication</para>
                  </listitem>

                  <listitem>
                     <para>Scaling by a scalar value</para>
                  </listitem>
               </itemizedlist>

               <para>The operations well-suited for use with computer graphics
               are:</para>

               <itemizedlist>
                  <listitem>
                     <para>Creating an identity matrix quickly</para>
                  </listitem>

                  <listitem>
                     <para>Zeroing a matrix in a single step</para>
                  </listitem>

                  <listitem>
                     <para>Creating an XYZ, a ZYX, or a ZXY Euler rotation
                     matrix</para>
                  </listitem>

                  <listitem>
                     <para>Constraining rotation about a specific axis or
                     axes</para>
                  </listitem>

                  <listitem>
                     <para>Making a matrix using direction cosines</para>
                  </listitem>

                  <listitem>
                     <para>Making a matrix from a quaternion</para>
                  </listitem>

                  <listitem>
                     <para>Making a rotation transformation matrix about a
                     single axis</para>
                  </listitem>

                  <listitem>
                     <para>Making a translation transformation matrix</para>
                  </listitem>

                  <listitem>
                     <para>Making a scale transformation matrix</para>
                  </listitem>

                  <listitem>
                     <para>Extracting specific transformation
                     information</para>
                  </listitem>

                  <listitem>
                     <para>Converting to an OpenGL Performer matrix</para>
                  </listitem>
               </itemizedlist>

               <para>What is presented here involves some complicated concepts
               that are far beyond the scope of this documentation. Without an
               understanding of matrix math (linear algebra) and an
               understanding of how transformation matrices work in OpenGL,
               this document will not be very useful. It is highly recommended
               that readers be familiar with these topics before proceeding.
               Otherwise, with this high-level description in mind, we now
               continue on to explain the
               <classname>gmtl::Matrix44f</classname> class at the C++
               level.</para>
            </section>

            <section>
               <title>Using <classname>gmtl::Matrix44f</classname></title>

               <indexterm>
                  <primary>classes</primary>

                  <secondary>gmtl::Matrix44f</secondary>
               </indexterm>

               <para>Keeping the idea of a normal mathematical matrix in mind,
               we are now ready to look at the C++ use of the
               <classname>gmtl::Matrix44f</classname> class. Most of the
               interface is defined using methods, but there are a few cases
               where mathematical operators have been overloaded to make code
               easier to read. Before going any further, whenever using a
               <classname>gmtl::Matrix44f</classname>, make sure to include
               <filename>gmtl/Matrix.h</filename> first. The operations
               presented above are now described in detail in the order in
               which they were listed above. We begin with creating the
               objects and setting their values.</para>
            </section>

            <section>
               <title>Creating Matrices and Setting Their Values</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>creating</secondary>
               </indexterm>

               <para>Before doing anything with matrices, some must be created
               first. To create a <classname>gmtl::Matrix44f</classname>, the
               default constructor can be used. It initializes the matrix to
               be an identity matrix:</para>

               <programlisting>gmtl::Matrix44f mat1;</programlisting>

               <para>After creating this matrix <varname>mat1</varname>, its
               16 elements can be assigned values all at once as
               follows:</para>

               <programlisting>mat1.set(0.0, 1.0, 2.3, 4.1,
         8.3, 9.0, 2.2, 1.0,
         5.6, 9.9, 9.7, 8.2,
         3.8, 0.9, 2.1, 0.1);</programlisting>

               <para>or with a <type>float</type> array:</para>

               <programlisting>float mat_vals[16] =
{
   0.0, 8.3, 5.6, 3.8,
   1.0, 9.0, 9.9, 0.9,
   2.3, 2.2, 9.7, 2.1,
   4.1, 1.0, 1.0, 0.1
};

mat1.set(mat_vals);</programlisting>

               <para>Note that when explicitly listing the values with
               <methodname>set()</methodname>, they are specified in
               <emphasis>row-major</emphasis> order. When put into a
               16-element array of <type>float</type>s, however, they must be
               ordered so that they can be copied into the
               <classname>gmtl::Matrix44f</classname> in
               <emphasis>column-major</emphasis> order. This is the one
               exception in the interface where access is column-major (which
               probably means that the interface has a bug).</para>

               <para>To set all the values of a new matrix in one step, they
               can be given as arguments when declaring the matrix:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);</programlisting>

               <para>All of the above code has exactly the same results but
               accomplishes those results in different ways.</para>

               <para>To read the elements in a
               <classname>gmtl::Matrix44f</classname> object, programmers can
               use either the overloaded [] operator or the overloaded ()
               operator. The overloaded [] operator returns the specified row
               of the <classname>gmtl::Matrix44f</classname>, and an element
               in that row can then be read using [] again. The code looks
               exactly the same as with a normal C++ two-dimensional
               array:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);
float val;

val = mat1[3][0];</programlisting>

               <para>Here, <varname>val</varname> is assigned the value 3.8.
               Using the overloaded () operator results in code that looks
               similar to the way the matrix element would be referenced in
               mathematics:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);
float val;

val = mat1(3, 0);</programlisting>

               <para>Again, <varname>val</varname> is assigned the value 3.8.
               Both of these operations are row-major.</para>
            </section>

            <section>
               <title>Assignment</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>assigning</secondary>
               </indexterm>

               <para>Assigning one <classname>gmtl::Matrix44f</classname> to
               another happens using the normal = operator as follows:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2;

mat2 = mat1;</programlisting>

               <para>This makes a <emphasis>copy</emphasis> of
               <varname>mat1</varname> in <varname>mat2</varname> which can be
               a slow operation.</para>
            </section>

            <section>
               <title>Equality/Inequality Comparison</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>equality comparison</secondary>
               </indexterm>

               <para>To compare the equality of two matrices, there are three
               available methods (one is just the complement of the other,
               though):</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( gmtl::isEqual(mat1, mat2) )
{
   // Go here if mat1 and mat2 are equal.
}</programlisting>

               <para>or</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( mat1 == mat2 )
{
   // Go here if mat1 and mat2 are equal.
}</programlisting>

               <para>or</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( mat1 != mat2 )
{
   // Go here if mat1 and mat2 are not equal.
}</programlisting>

               <para>Choose whichever method is most convenient.</para>
            </section>

            <section>
               <title>Transposing</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>transposing</secondary>
               </indexterm>

               <para>The transpose operation works conceptually as
               <inlineequation>
                     <inlinemediaobject>
                        <imageobject>
                           <imagedata fileref="figures/eq_m1_eq_tr_m2.png"
                                      format="PNG" />
                        </imageobject>

                        <textobject>
                           <phrase>matrix1 = transpose(matrix2)</phrase>
                        </textobject>

                        <textobject role="tex">
                           <phrase>matrix_{1}=transpose\left(
                           matrix_{2}\right)</phrase>
                        </textobject>
                     </inlinemediaobject>
                  </inlineequation>. The code is then:</para>

               <programlisting>gmtl::Matrix44f mat1;
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::transpose(mat1, mat2);</programlisting>

               <para>The result is stored in <varname>mat1</varname>.
               <varname>mat2</varname> is passed by reference for
               efficiency.</para>
            </section>

            <section>
               <title>Finding the Inverse</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>inverting</secondary>
               </indexterm>

               <para>The inverse operation works conceptually as
               <inlineequation>
                     <inlinemediaobject>
                        <imageobject>
                           <imagedata fileref="figures/eq_m1_eq_inv_m2.png"
                                      format="PNG" />
                        </imageobject>

                        <textobject>
                           <phrase>matrix1 = inverse(matrix2)</phrase>
                        </textobject>

                        <textobject role="tex">
                           <phrase>matrix_{1}=inverse\left(
                           matrix_{2}\right)</phrase>
                        </textobject>
                     </inlinemediaobject>
                  </inlineequation>. The code is then:</para>

               <programlisting>gmtl::Matrix44f mat1;
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::invert(mat1, mat2);</programlisting>

               <para>The result is stored in <varname>mat1</varname>.
               <varname>mat2</varname> is passed by reference for
               efficiency.</para>
            </section>

            <section>
               <title>Addition</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>adding</secondary>
               </indexterm>

               <para>For the addition operation, the interface is defined so
               that the sum of two matrices is stored in a third. There are
               two ways to do addition with
               <classname>gmtl::Matrix44f</classname>: using the add() method
               or using the overloaded + operator. Use of the former is
               recommended, but the latter can be used if one prefers that
               style of programming. Examples of both methods follow. The
               first block of code only declares the
               <classname>gmtl::Matrix44f</classname> objects.</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>

               <para>Using the <function>gmtl::add()</function>
               function:</para>

               <programlisting>gmtl::add(mat3, mat1, mat2);</programlisting>

               <para>Using the overloaded + operator:</para>

               <programlisting>mat3 = mat1 + mat2;</programlisting>

               <para>The result is stored (via a copy) in
               <varname>mat3</varname>.</para>
            </section>

            <section>
               <title>Subtraction</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>subtracting</secondary>
               </indexterm>

               <para>For the subtraction operation, the interface is defined
               so that the difference of two matrices is stored in a third.
               There are two ways to do subtraction with
               <classname>gmtl::Matrix44f</classname>: using the
               <methodname>sub()</methodname> method or using the overloaded -
               operator. It is recommended that developers use the former, but
               the latter can be used for stylistic purposes. Examples of both
               methods follow. The first block of code only declares the
               <classname>gmtl::Matrix44f</classname> objects.</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>

               <para>Using the <methodname>gmtl::sub()</methodname>
               method:</para>

               <programlisting>gmtl::sub(mat3, mat1, mat2);</programlisting>

               <para>Using the overloaded - operator:</para>

               <programlisting>mat3 = mat1 - mat2;</programlisting>

               <para>The result is stored (via a copy) in
               <varname>mat3</varname>.</para>
            </section>

            <section>
               <title>Multiplication</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>multiplying</secondary>
               </indexterm>

               <para>As in the case of addition and subtraction, the
               multiplication interface is defined so that the product of two
               matrices is stored in a third. This is likely to be the
               operation used most often since transformation matrices are
               constructed through multiplication of different transforms. For
               normal matrix multiplication, there are two ways to do
               multiplication with <classname>gmtl::Matrix44f</classname>:
               using the <function>gmtl::mult()</function> function or using
               the overloaded * operator. We recommend the use of the
               <function>gmtl::mult()</function> function but the overloaded *
               operator can be used by those who prefer that style of
               programming. Examples of both methods follow. The first block
               of code only declares the
               <classname>gmtl::Matrix44f</classname> objects.</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                    5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>

               <para>Using the <function>gmtl::mult()</function>
               function:</para>

               <programlisting>gmtl::mult(mat3, mat1, mat2);</programlisting>

               <para>Using the overloaded * operator:</para>

               <programlisting>mat3 = mat1 * mat2;</programlisting>

               <para>The result is stored (via a copy) in
               <varname>mat3</varname>.</para>

               <para>There are two more multiplication operations provided
               that help in handling the order of the matrices when they are
               multiplied. These two extra operations do post-multiplication
               and pre-multiplication of two matrices. An example of
               post-multiplication is:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::postMult(mat1, mat2);</programlisting>

               <para>Conceptually, the operation is <inlineequation>
                     <inlinemediaobject>
                        <imageobject>
                           <imagedata fileref="figures/eq_m1_eq_m1_m2.png"
                                      format="PNG" />
                        </imageobject>

                        <textobject>
                           <phrase>mat1 = mat1 * mat2</phrase>
                        </textobject>

                        <textobject role="tex">
                           <phrase>mat_{1}=mat_{1}*mat_{2}</phrase>
                        </textobject>
                     </inlinemediaobject>
                  </inlineequation> so that the second matrix
               (<varname>mat2</varname>) comes as the second factor. The same
               result can be achieved using the overloaded *= operator:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

mat1 *= mat2;</programlisting>

               <para>An example of pre-multiplication is:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::preMult(mat1, mat2);</programlisting>

               <para>Here, the conceptual operation is <inlineequation>
                     <inlinemediaobject>
                        <imageobject>
                           <imagedata fileref="figures/eq_m1_eq_m2_m1.png"
                                      format="PNG" />
                        </imageobject>

                        <textobject>
                           <phrase>mat1 = mat2 * mat1</phrase>
                        </textobject>

                        <textobject role="tex">
                           <phrase>mat_{1}=mat_{2}*mat_{1}</phrase>
                        </textobject>
                     </inlinemediaobject>
                  </inlineequation> so that the second matrix
               (<varname>mat2</varname>) comes as the first factor. In both
               cases, the result of the multiplication is stored in
               <varname>mat1</varname>.</para>
            </section>

            <section>
               <title>Scaling by a Scalar Value</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>scaling</secondary>
               </indexterm>

               <para>Scaling the values of a matrix by a scalar value can be
               done using two different methods: the
               <methodname>setScale()</methodname> method or the overloaded *
               and / operators that take a single scalar value and returns a
               <classname>gmtl::Matrix44f</classname>. As with the preceding
               operations, we recommend the use of the former, but the latter
               is available for those who want it. Examples of both methods
               follow. First, using the <function>gmtl::setScale()</function>
               function works as:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);


gmtl::setScale(mat1, 3.0);</programlisting>
            </section>

            <section>
               <title>Making an Identity Matrix Quickly</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>making</secondary>

                  <tertiary>identity</tertiary>
               </indexterm>

               <para>In computer graphics, an identity matrix is often needed
               when performing transformations. Because of this,
               <classname>gmtl::Matrix44f</classname> provides a method for
               converting a matrix into an identity matrix in a single step
               (at the user code level anyway):</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::identity(mat1);</programlisting>

               <para>Of course, simply declaring <varname>mat1</varname> with
               no arguments would achieve the same result, but that is not
               such an interesting example.</para>
            </section>

            <section>
               <title>Zeroing a Matrix in a Single Step</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>zeroing</secondary>
               </indexterm>

               <para>Before using a matrix, it is often helpful to zero it out
               to ensure that there is no pollution from previous use. With a
               <classname>gmtl::Matrix44f</classname>, this can be done in one
               step:</para>

               <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::zero(mat1);</programlisting>

               <para>The result is that all elements of
               <varname>mat1</varname> are now 0.0.</para>
            </section>

            <section>
               <title>Making an XYZ, a ZYX, or a ZXY Euler Rotation
               Matrix</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>making</secondary>

                  <tertiary>Euler rotation</tertiary>
               </indexterm>

               <para>All the rotation information for a transform can be
               contained in a single matrix using the methods for making an
               XYZ, a ZYX, or a ZXY Euler matrix. Code for all three
               follows:</para>

               <programlisting>vrj::Matrix mat1;
float x_rot = 0.4, y_rot = 0.541, z_rot = 0.14221;

gmtl::setRot(mat1, gmtl::EulerAngleXYZf(x_rot, y_rot, z_rot));
gmtl::setRot(mat1, gmtl::EulerAngleZYXf(z_rot, y_rot, x_rot));
gmtl::setRot(mat1, gmtl::EulerAngleZXYf(z_rot, x_rot, y_rot));</programlisting>

               <para>In every case, the matrix is zeroed before the rotation
               transformation is stored. The result of the above code is that
               <varname>mat1</varname> is a ZXY Euler rotation matrix. The
               previous two operations are destroyed.</para>
            </section>

            <section>
               <title>Making a Translation Transformation Matrix</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>making</secondary>

                  <tertiary>translation transformation</tertiary>
               </indexterm>

               <para>To make a translation matrix, there are two methods with
               each having two different types of arguments specifying the
               translation. The first makes a matrix with only the given
               translation (all other transformation information is
               destroyed):</para>

               <programlisting>gmtl::Matrix44f mat;
gmtl::Vec3f trans(4.0, -4.231, 1.0);

mat = gmtl::makeTrans&lt;gmtl::Matrix44f&gt;(trans);</programlisting>

               <para>To <emphasis>change</emphasis> the translation of a
               transformation matrix without completely obliterating all other
               transformations, use the following instead:</para>

               <programlisting>gmtl::Vec3f trans(4.0, -4.231, 1.0);

gmtl::setTrans(mat, trans);</programlisting>
            </section>

            <section>
               <title>Making a Scale Transformation Matrix</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>making</secondary>

                  <tertiary>scale transformation</tertiary>
               </indexterm>

               <para>To make a transformation matrix that only scales, a
               simple method is provided. It works as follows:</para>

               <programlisting>gmtl::Matrix44f mat;
gmtl::Vec3f scale( 1.5, 1.5, 1.5 );

mat = gmtl::makeScale&lt;Matrix44f&gt;(scale);</programlisting>

               <para>The result is that mat is a transformation matrix that
               will perform a scale operation. In this specific case, the
               scaling happens uniformly for x, y, and z.</para>
            </section>

            <section>
               <title>Extracting Specific Transformation Information</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>extracting transformation information</secondary>
               </indexterm>

               <para>Finally, methods are provided for extracting
               transformations from a given matrix. The individual rotations
               and the translation can be read. For the following examples,
               assume that <varname>mat</varname> is a
               <classname>gmtl::Matrix44f</classname> object representing
               arbitrary translation, rotation, and scaling transformations.
               To get the Z-axis rotation information (an Euler angle), use
               the following:</para>

               <programlisting>float z_rot = (gmtl::makeRot&lt;gmtl::EulerAngleXYZf&gt;(mat))[2];</programlisting>

               <para>The value return is in radians. We can also get the
               X-axis rotation.</para>

               <programlisting>float x_rot = (gmtl::makeRot&lt;gmtl::EulerAngleXYZf&gt;(mat))[0];</programlisting>

               <para>Getting translations is even simpler because translations
               are collected into a single vector easily.</para>

               <programlisting>gmtl::Vec3f trans;
gmtl::setTrans(trans, mat);</programlisting>

               <para>After this, the translation in <varname>mat</varname> is
               stored in trans. The same can be done with a
               <classname>gmtl::Vec4f</classname> instead of the
               <classname>gmtl::Vec3f</classname>.</para>
            </section>

            <section>
               <title>Converting to an OpenGL Performer Matrix</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>converting to pfMatrix</secondary>
               </indexterm>

               <indexterm>
                  <primary>pfMatrix</primary>

                  <secondary>converting from gmtl::Matrix44f</secondary>

                  <seealso>gmtl::Matrix44f</seealso>
               </indexterm>

               <para>SGI's OpenGL Performer likes to work with its own
               <classname>pfMatrix</classname> class, and to facilitate the
               use of it with <classname>gmtl::Matrix44f</classname>, two
               conversion functions are provided for making conversions. The
               first works as follows:</para>

               <programlisting>gmtl::Matrix44f vj_mat;
pfMatrix pf_mat;

// Perform operations on vj_mat...

pf_mat = vrj::GetPfMatrix(vj_mat);</programlisting>

               <para>where <varname>vj_mat</varname> is passed by reference
               for efficiency. (<varname>pf_mat</varname> gets a copy of a
               <classname>pfMatrix</classname> which is a slow operation.) To
               convert a <classname>pfMatrix</classname> to a
               <classname>gmtl::Matrix44f</classname>, do the
               following:</para>

               <programlisting>pfMatrix pf_mat;
gmtl::Matrix44f vj_mat;

// Perform operations on pf_mat...

vj_mat = vrj::GetVjMatrix(pf_mat);</programlisting>

               <para>Here again, <varname>pf_mat</varname> is passed by
               reference for efficiency, and <varname>vj_mat</varname> gets a
               copy of a <classname>gmtl::Matrix44f</classname>. Both of these
               functions are found in the header
               <filename>vrj/Draw/Pf/PfUtil.h</filename>.</para>
            </section>

            <section>
               <title>The Gory Details</title>

               <indexterm>
                  <primary>gmtl::Matrix44f</primary>

                  <secondary>details</secondary>
               </indexterm>

               <para>Now it is time for the really nasty part. Reading this
               could cause difficulty in understanding the overwhelming amount
               of information just presented. Do not read any further unless
               you absolutely have to or you just like to confuse
               yourself.</para>

               <para>C, C++, and mathematics use matrices in row-major order.
               Access indices are shown in <xref
               linkend="table.row-major.access" /></para>

               <table id="table.row-major.access">
                  <title>Row-major access indices</title>

                  <tgroup align="left" cols="5" colsep="1" rowsep="1">
                     <tbody>
                        <row>
                           <entry align="center">(0,0)</entry>

                           <entry align="center">(0,1)</entry>

                           <entry align="center">(0,2)</entry>

                           <entry align="center">(0,3)</entry>

                           <entry>&lt;--- Array</entry>
                        </row>

                        <row>
                           <entry align="center">(1,0)</entry>

                           <entry align="center">(1,1)</entry>

                           <entry align="center">(1,2)</entry>

                           <entry align="center">(1,3)</entry>

                           <entry>&lt;--- Array</entry>
                        </row>

                        <row>
                           <entry align="center">(2,0)</entry>

                           <entry align="center">(2,1)</entry>

                           <entry align="center">(2,2)</entry>

                           <entry align="center">(2,3)</entry>

                           <entry>&lt;--- Array</entry>
                        </row>

                        <row>
                           <entry align="center">(3,0)</entry>

                           <entry align="center">(3,1)</entry>

                           <entry align="center">(3,2)</entry>

                           <entry align="center">(3,3)</entry>

                           <entry>&lt;--- Array</entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>

               <para>OpenGL ordering specifies that the matrix has to be
               column-major in memory. Thus, to provide programmers with a way
               to pass a transformation matrix to OpenGL in one step (via
               <function>glMultMatrixf()</function>), the
               <classname>gmtl::Matrix44f</classname> class maintains its
               internal matrix in column-major order. Note that in the
               following table, the given indices are what the cells have to
               be called in C/C++ notation because we are putting them back to
               back. This is illustrated in <xref
               linkend="table.column-major.access" />.</para>

               <table id="table.column-major.access">
                  <title>Column-major access indices</title>

                  <tgroup align="left" cols="4" colsep="1" rowsep="1">
                     <tbody>
                        <row>
                           <entry align="center">(0,0)</entry>

                           <entry align="center">(1,0)</entry>

                           <entry align="center">(2,0)</entry>

                           <entry align="center">(3,0)</entry>
                        </row>

                        <row>
                           <entry align="center">(0,1)</entry>

                           <entry align="center">(1,1)</entry>

                           <entry align="center">(2,1)</entry>

                           <entry align="center">(3,1)</entry>
                        </row>

                        <row>
                           <entry align="center">(0,2)</entry>

                           <entry align="center">(1,2)</entry>

                           <entry align="center">(2,2)</entry>

                           <entry align="center">(3,2)</entry>
                        </row>

                        <row>
                           <entry align="center">(0,3)</entry>

                           <entry align="center">(1,3)</entry>

                           <entry align="center">(2,3)</entry>

                           <entry align="center">(3,3)</entry>
                        </row>

                        <row>
                           <entry align="center">^</entry>

                           <entry align="center">^</entry>

                           <entry align="center">^</entry>

                           <entry align="center">^</entry>
                        </row>

                        <row>
                           <entry align="center">Array</entry>

                           <entry align="center">Array</entry>

                           <entry align="center">Array</entry>

                           <entry align="center">Array</entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>

               <para>As mentioned, all of this is done so that a given
               <classname>gmtl::Matrix44f</classname> that acts as a full
               transformation matrix can be passed to OpenGL directly (more or
               less)<indexterm>
                     <primary>vrj::Matrix</primary>

                     <secondary>using with OpenGL</secondary>
                  </indexterm>. For example, with a given
               <classname>gmtl::Matrix44f</classname> object
               <varname>mat</varname> upon which painstaking transformations
               have been performed, the following can be done:</para>

               <programlisting>glMultMatrixf(mat.getData());</programlisting>

               <para>That could not be simpler. All the transformation efforts
               have culminated into one statement.</para>

               <para>For further information, the best possible source of
               information, especially for this class, is the header file.
               Read it; understand it; love it.</para>
            </section>
         </section>

         <section id="section.gadget.proxies.devif">
            <title>Device Proxies and Device Interfaces</title>

            <indexterm zone="section.gadget.proxies.devif">
               <primary>device proxies</primary>
            </indexterm>

            <indexterm zone="section.gadget.proxies.devif">
               <primary>device interfaces</primary>
            </indexterm>

            <indexterm zone="section.gadget.proxies.devif">
               <primary>application programming</primary>

               <secondary>getting input</secondary>

               <seealso>device proxies</seealso>
            </indexterm>

            <indexterm zone="section.gadget.proxies.devif">
               <primary>application programming</primary>

               <secondary>getting input</secondary>

               <seealso>device interfaces</seealso>
            </indexterm>

            <para>When writing a VR Juggler application object, direct access
            to hardware devices is not allowed<indexterm>
                  <primary>applications</primary>

                  <secondary>device access</secondary>
               </indexterm>. This is a design choice that helps facilitate the
            portability of VR applications by preventing them from depending
            on specific input device makes and models. Instead, the
            applications are granted access to the device through a <glossterm
            linkend="gloss.proxy">proxy</glossterm><indexterm>
                  <primary>proxy</primary>

                  <secondary>application-level access</secondary>
               </indexterm>. A proxy is nothing more than an intermediary who
            forwards information between two parties<indexterm>
                  <primary>proxy</primary>

                  <secondary>definition of</secondary>
               </indexterm>. In this case, the two parties are a VR Juggler
            application and an input device. The application makes requests on
            the input device through the proxy.</para>

            <para>Proxies are acquired through the Gadgeteer Input Manager,
            but the process is not entirely straightforward. To assist with
            the use of device proxies, Gadgeteer provides what are called
            <glossterm linkend="gloss.device.interface">device
            interfaces</glossterm>. Device interfaces hide the details of
            proxy acquisition through the Input Manager, but the concept of
            device interfaces is something that often causes confusion for
            those new to VR Juggler application programming. Two
            object-oriented design patterns are combined by device interfaces:
            smart pointers and proxies. Within this section, we aim to explain
            Gadgeteer device proxies and device interfaces clearly and simply.
            We begin with high-level descriptions of both and then move on to
            their use in VR Juggler application objects.</para>

            <section id="section.proxies.description">
               <title>High-Level Description of Device Proxies</title>

               <indexterm zone="section.proxies.description">
                  <primary>device proxies</primary>

                  <secondary>description of</secondary>
               </indexterm>

               <para>As noted above, access to input device data is granted
               through device proxies allocated by the Gadgeteer Input
               Manager. For each type of input device (digital, analog,
               keyboard/mouse, etc.), there is a device proxy class. As a
               programmer of VR Juggler applications, knowledge of such
               proxies does not have to be terribly in-depth. The fact is,
               most VR Juggler application object programmers will probably
               never need to know more about the interface of a type-specific
               device proxy than the return type of its data request method
               (usually named <methodname>getData()</methodname>). We will see
               more about the data request method in the explanation of device
               interfaces below. Most of the perceived complexity in the
               type-specific proxy classes is only important to Gadgeteer's
               internal maintenance of the active proxies. The following is
               the complete list of proxy classes in Gadgeteer 1.0 (used by VR
               Juggler 2.0):</para>

               <indexterm zone="list.gadget.TypedProxy.subclasses">
                  <primary>gadget::TypedProxy&lt;T&gt;</primary>

                  <secondary>subclasses of</secondary>
               </indexterm>

               <indexterm zone="list.gadget.TypedProxy.subclasses">
                  <primary>device proxies</primary>

                  <secondary>available types</secondary>
               </indexterm>

               <variablelist id="list.gadget.TypedProxy.subclasses">
                  <varlistentry>
                     <term><classname>gadget::AnalogProxy</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::AnalogProxy</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>The proxy type for analog input devices (those
                        of type
                        <classname>gadget::Analog</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::Analog</secondary>
                           </indexterm>). It is defined in the header file
                        <filename>gadget/Type/AnalogProxy.h</filename>. The
                        return type of
                        <methodname>gadget::AnalogProxy::getData()</methodname>
                        is <type>float</type>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::CommandProxy</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::CommandProxy</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>The proxy type for command-oriented input
                        devices (those of type
                        <classname>gadget::Command</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::Command</secondary>
                           </indexterm>). It is defined in the header file
                        <filename>gadget/Type/CommandProxy.h</filename>. The
                        return type of
                        <methodname>gadget::CommandProxy::getData()</methodname>
                        is <type>int</type>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::DigitalProxy</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::DigitalProxy</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>The proxy type for digital (on/off) input
                        devices (those of type
                        <classname>gadget::Digital</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::Digital</secondary>
                           </indexterm>). It is defined in the header file
                        <filename>gadget/Type/DigitalProxy.h</filename>. The
                        return type of
                        <methodname>gadget::DigitalProxy::getData()</methodname>
                        is <type>gadget::Digital::State</type>, an enumerated
                        type. This means that values returned by
                        <methodname>gadget::DigitalProxy::getData()</methodname>
                        can be treated as integers.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::GloveProxy</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::GloveProxy</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>The proxy type for glove input devices (those of
                        type <classname>gadget::Glove</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::Glove</secondary>
                           </indexterm>). It is defined in the header file
                        <filename>gadget/Type/GloveProxy.h</filename>. The
                        return type of
                        <methodname>gadget::GloveProxy::getData()</methodname>
                        is <classname>gadget::GloveData</classname>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::KeyboardMouseProxy</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::KeyboardMouseProxy</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>The proxy type for keyboard/mouse input handlers
                        (those of type
                        <classname>gadget::KeyboardMouse</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::KeyboardMouse</secondary>
                           </indexterm>). It is defined in the header file
                        <filename>gadget/Type/KeyboardMouseProxy.h</filename>.
                        There is no method
                        <methodname>gadget::KeyboardMouse::getData()</methodname>.
                        Rather, the method to use for querying input data is
                        <methodname>gadget::KeyboardMouseProxy::getEventQueue()</methodname>,
                        the return type of which is
                        <classname>gadget::KeyboardMouse::EventQueue</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::KeyboardMouse::EventQueue</secondary>
                           </indexterm>. We explain more about this below in
                        <xref
                        linkend="section.using.gadget.KeyboardMouseInterface" />.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::PositionProxy</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::PositionProxy</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>The proxy type for position tracking input
                        devices (those of type
                        <classname>gadget::Position</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::Position</secondary>
                           </indexterm>). It is defined in the header file
                        <filename>gadget/Type/PositionProxy.h</filename>. The
                        return type of
                        <methodname>gadget::PositionProxy::getData()</methodname>
                        is <classname>gmtl::Matrix44f</classname>. The method
                        <methodname>gadget::PositionProxy::getData()</methodname>
                        takes an optional <type>float</type> paramter that
                        indicates the units to use for the returned
                        transformation matrix. The value must be a conversion
                        factor from meters to the desired units.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::StringProxy</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::StringProxy</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>The proxy type for string (text- or word-driven)
                        input devices (those of type
                        <classname>gadget::String</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::String</secondary>
                           </indexterm>). It is defined in the header file
                        <filename>gadget/Type/StringProxy.h</filename>. The
                        return type of
                        <methodname>gadget::StringProxy::getData()</methodname>
                        is <classname>std::string</classname>.</para>
                     </listitem>
                  </varlistentry>
               </variablelist>

               <para>In summary, the important thing to know is that a proxy
               is a pointer to a physical device<indexterm>
                     <primary>gadget::Proxy</primary>

                     <secondary>as pointer to physical device</secondary>
                  </indexterm><indexterm>
                     <primary>device proxy</primary>

                     <secondary>as pointer to physical device</secondary>
                  </indexterm>. Application object programmers should normally
               use the higher level device interface as the mechanism to
               acquire a proxy and read data from the proxied device. The
               device interface encapsulates some type of proxy that in turn
               points to an input device. That device can be a wand, a
               keyboard, a light sensor, or a home-brewed device that reads
               some input and returns it to Gadgeteer in a meaningful way.
               That is a lot of indirection, but it makes the handling of
               physical devices by Gadgeteer incredibly powerful.</para>
            </section>

            <section id="section.device.interfaces.description">
               <title>High-Level Description of Device Interfaces</title>

               <indexterm zone="section.device.interfaces.description">
                  <primary>gadget::DeviceInterface&lt;T&gt;</primary>

                  <secondary>description of</secondary>
               </indexterm>

               <indexterm zone="section.device.interfaces.description">
                  <primary>device interfaces</primary>

                  <secondary>description of</secondary>
               </indexterm>

               <para>Device interfaces are designed to act as wrappers around
               type-specific device properties. This is implemented through
               the (template) class
               <classname>gadget::DeviceInterface&lt;T&gt;</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gadget::DeviceInterface&lt;T&gt;</secondary>
                  </indexterm>. Applications could use the proxy classes
               directly, but as we have already noted, acquiring the desired
               proxies from the Gadgeteer Input Manager is not wholly
               straightforward. The type-specific instances of
               <classname>gadget::DeviceInterface&lt;T&gt;</classname> (such
               as <classname>gadget::PositionInterface</classname>,
               <classname>gadget::DigitalInterface</classname>, etc.) simplify
               acquisition of proxies. Thus, typical VR Juggler application
               objects will have one or more device interface member variables
               and no proxy member variables.</para>

               <para>The class
               <classname>gadget::DeviceInterface&lt;T&gt;</classname> is a
               templated class based on the proxy type it wraps. The following
               is the complete list of available
               <classname>gadget::DeviceInterface&lt;T&gt;</classname>
               instantiations in Gadgeteer 1.0 (used by VR Juggler
               2.0):</para>

               <indexterm zone="list.gadget.DeviceInterface.instantiations">
                  <primary>gadget::DeviceInterface&lt;T&gt;</primary>

                  <secondary>instantiations of</secondary>
               </indexterm>

               <indexterm zone="list.gadget.DeviceInterface.instantiations">
                  <primary>device interfaces</primary>

                  <secondary>available types</secondary>
               </indexterm>

               <variablelist id="list.gadget.DeviceInterface.instantiations">
                  <varlistentry>
                     <term><classname>gadget::AnalogInterface</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::AnalogInterface</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>This is a typedef for the template instantiation
                        <classname>gadget::DeviceInterface&lt;gadget::AnalogProxy&gt;</classname>.
                        It wraps the proxy type
                        <classname>gadget::AnalogProxy</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::AnalogProxy</secondary>
                           </indexterm> and is used for reading data from
                        analog devices. Include the header file
                        <filename>gadget/Type/AnalogInterface.h</filename>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::CommandInterface</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::CommandInterface</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>This is a typedef for the template instantiation
                        <classname>gadget::DeviceInterface&lt;gadget::CommandProxy&gt;</classname>.
                        It wraps the proxy type
                        <classname>gadget::CommandProxy</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::CommandProxy</secondary>
                           </indexterm> and is used for reading data from
                        command-driven devices. Include the header file
                        <filename>gadget/Type/CommandInterface.h</filename>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::DigitalInterface</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::DigitalInterface</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>This is a typedef for the template instantiation
                        <classname>gadget::DeviceInterface&lt;gadget::DigitalProxy&gt;</classname>.
                        It wraps the proxy type
                        <classname>gadget::DigitalProxy</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::DigitalProxy</secondary>
                           </indexterm> and is used for reading data from
                        digital (on/off) devices. Include the header file
                        <filename>gadget/Type/DigitalInterface.h</filename>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::GloveInterface</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::GloveInterface</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>This is a typedef for the template instantiation
                        <classname>gadget::DeviceInterface&lt;gadget::GloveProxy&gt;</classname>.
                        It wraps the proxy type
                        <classname>gadget::GloveProxy</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::GloveProxy</secondary>
                           </indexterm> and is used for reading data from
                        glove devices. Include the header file
                        <filename>gadget/Type/GloveInterface.h</filename>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::KeyboardMouseInterface</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::KeyboardMouseInterface</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>This is a typedef for the template instantiation
                        <classname>gadget::DeviceInterface&lt;gadget::KeyboardMouseProxy&gt;</classname>.
                        It wraps the proxy type
                        <classname>gadget::KeyboardMouseProxy</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::KeyboardMouseProxy</secondary>
                           </indexterm> and is used for reading data from
                        analog devices. Include the header file
                        <filename>gadget/Type/KeyboardMouseInterface.h</filename>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::PositionInterface</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::PositionInterface</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>This is a typedef for the template instantiation
                        <classname>gadget::DeviceInterface&lt;gadget::PositionProxy&gt;</classname>.
                        It wraps the proxy type
                        <classname>gadget::PositionProxy</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::PositionProxy</secondary>
                           </indexterm> and is used for reading data from
                        position tracking devices. Include the header file
                        <filename>gadget/Type/PositionInterface.h</filename>.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term><classname>gadget::StringInterface</classname><indexterm>
                           <primary>classes</primary>

                           <secondary>gadget::StringInterface</secondary>
                        </indexterm></term>

                     <listitem>
                        <para>This is a typedef for the template instantiation
                        <classname>gadget::DeviceInterface&lt;gadget::StringProxy&gt;</classname>.
                        It wraps the proxy type
                        <classname>gadget::StringProxy</classname><indexterm>
                              <primary>classes</primary>

                              <secondary>gadget::StringProxy</secondary>
                           </indexterm> and is used for reading data from
                        string (text- or word-driven) devices. Include the
                        header file
                        <filename>gadget/Type/StringInterface.h</filename>.</para>
                     </listitem>
                  </varlistentry>
               </variablelist>

               <para>The typedefs are provided to make the application object
               code more readable.</para>

               <para>In the application object, a device interface member
               variable is used as a <glossterm
               linkend="gloss.smart.pointer">smart
               pointer</glossterm><indexterm>
                     <primary>smart pointer</primary>
                  </indexterm> to the proxy. In C++, a smart pointer is not
               usually an actual object pointer. Instead, the class acting as
               a smart pointer overloads the dereference operator -&gt; so
               that a special action can be taken when the
               <quote>pointer</quote> is dereferenced. The dereference
               operator is just another operator like the addition and
               subtraction operators, and overloading the deference operator
               allows some extra work to be done behind the scenes. On the
               surface, the code looks exactly the same as a normal pointer
               dereference, and in most cases, people reading and writing the
               code can think of the smart pointer as a standard pointer. It
               may also be convenient to think of a smart pointer as a
               handle.</para>

               <para>With that background, we can move on to explain how
               <classname>gadget::DeviceInterface&lt;T&gt;</classname> uses
               these concepts. In user code, there will be instances of types
               such as
               <classname>gadget::DigitalInterface</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gadget::DigitalInterface</secondary>
                  </indexterm>,
               <classname>gadget::PositionInterface</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gadget::PositionInterface</secondary>
                  </indexterm>,
               <classname>gadget::KeyboardMouseInterface</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gadget::KeyboardMouseInterface</secondary>
                  </indexterm>, and the like. Once they are properly
               initialized, device interface objects (whatever their types may
               be) will act as smart pointers to the actual Gadgeteer device
               proxy objects that they encapsulate.</para>

               <para>At this point, it is perfectly reasonable to wonder why
               Gadgeteer uses a concept that requires all sorts of
               documentation and explanation. The extra effort is worth it
               because it allows Gadgeteer to hide the actual type of the
               device being used. There is no need to know that some specific
               VR system uses a wireless mouse connected to a PC reading bytes
               from a PS/2 port that represent button presses. All that
               matters is knowing which buttons are pressed at a given
               instant. The class
               <classname>gadget::DigialInterface</classname> gives exactly
               that information, and it quietly hides the messiness of dealing
               with the mouse, its driver, and its communication
               protocol.</para>
            </section>

            <section>
               <title>Using Device Interfaces</title>

               <para>Before using a device interface, some objects must be
               declared. Programmers must choose the type that is appropriate
               for the type of devices relevant to a given application. All
               device interface objects must be initialized in the application
               object's override of the method
               <methodname>vrj::App::init()</methodname> method<indexterm>
                     <primary>device interfaces</primary>

                     <secondary>initialization of</secondary>
                  </indexterm>. Because we are dealing with a templated type
               (<classname>gadget::DeviceInterface&lt;T&gt;</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gadget::DeviceInterface&lt;T&gt;</secondary>
                  </indexterm>), every type-specific instantiation has the
               same interface. Hence, all type-specific device interfaces are
               initialized using the
               <methodname>gadget::DeviceInterface&lt;T&gt;::init()</methodname>
               method. This method takes a single string argument naming the
               proxy to which the interface will connect. The name can be the
               name of a proxy or a proxy alias, both of which are defined in
               VR Juggler configuration files. Example names are
               <quote>VJHead</quote>, <quote>Wand</quote>,
               <quote>VJButton0</quote>, and <quote>Accelerate
               Button</quote><indexterm>
                     <primary>device aliases</primary>

                     <secondary>examples of</secondary>
                  </indexterm>. Using meaningful symbolic names makes them
               easier to remember, and it also contributes to hiding the
               details about the physical device. With this system, no one
               needs to care how transformation information from the user's
               head is generated. Gadgeteer cares, but there is no need for it
               to tell anyone else. All developers care about is the head
               transformation matrix. An example of initializing a
               <classname>gadget::PositionInterface</classname> that connects
               with the user head proxy is:</para>

               <programlisting>gadget::PositionInterface head;

head.init("VJHead");</programlisting>

               <para>Remember that this has to be done in an application
               object's <methodname>init()</methodname> method. The actual
               object used would be a member variable of the application
               class. Note that here, the normal syntax for calling the method
               of a C++ object is used rather than using the dereference
               operator. Until it is initialized, the device interface object
               cannot act as a smart pointer.</para>

               <para>Once device interface objects are all initialized and
               ready to use, it is time to start using them as smart
               pointers<indexterm>
                     <primary>device interfaces</primary>

                     <secondary>as smart pointers</secondary>

                     <seealso>smart pointer</seealso>
                  </indexterm>. VR Juggler and Gadgeteer are already working
               hard in the background to update device proxies, and the
               application is free to access them. It is usually best to
               acquire data from the device proxy through the device interface
               in the <methodname>preFrame()</methodname> method, but this may
               not necessarily be true for all proxies. Continuing with our
               example of a <classname>gadget::PositionInterface</classname>
               to the user head proxy, the following code shows how to read
               the transformation matrix for the user's head (in feet):</para>

               <programlisting>gmtl::Matrix44f head_mat = head-&gt;getData();</programlisting>

               <para>Believe it or not, the code really is that easy. Simply
               use the overloaded dereference operator to get access to the
               position proxy object hidden in
               <classname>gadget::PositionInterface</classname> to read data
               from the proxy. We now move on to explain the use of
               type-specific device interfaces.</para>

               <section>
                  <title>Using
                  <classname>gadget::AnalogInterface</classname></title>

                  <para>Analog devices return floating-point data. As noted
                  above, the return type of
                  <methodname>gadget::AnalogProxy::getData()</methodname> is
                  <type>float</type>. Behind the scenes, analog devices in
                  Gadgeteer scale their input so that application objects
                  always receive it in the range 0.0 to 1.0 inclusive (also
                  denoted [0.0,1.0] in mathematically oriented descriptions).
                  Hence, application objects can always expect analog data to
                  be in that range regardless of the specific type of analog
                  device being used.</para>
               </section>

               <section>
                  <title>Using
                  <classname>gadget::CommandInterface</classname></title>

                  <para>Command-oriented devices were introduced in Gadgeteer
                  1.0 Beta 1. They are an evolving device type geared towards
                  complex input that can be interpreted at an abstract level.
                  In Gadgeteer 1.0, such input comes in the form of spoken
                  phrases that are reinterpreted as commands identified by
                  unique integer values. In future versions of Gadgeteer, this
                  device type will be used for scalable gesture recognition.
                  The return type of
                  <methodname>gadget::CommandProxy::getData()</methodname> is
                  <type>int</type>, and it is up to the person configuring the
                  command-oriented device to set up the command-to-integer
                  mappings.</para>
               </section>

               <section>
                  <title>Using
                  <classname>gadget::DigitalInterface</classname></title>

                  <para>Digital devices are those that have distinct on and
                  off states. The method
                  <methodname>gadget::DigitalProxy::getData()</methodname>
                  returns the current state of such a device as a value of the
                  enumerated type <type>gadget::Digital::State</type>. This
                  type is defined to allow for easy on/off testing, but it
                  also provides state toggling information. The possible
                  values of <type>gadget::Digital::State</type> are
                  <constant>OFF</constant> (integer value 0),
                  <constant>ON</constant> (integer value 1),
                  <constant>TOGGLE_ON</constant> (integer value 2),
                  <constant>TOGGLE_OFF</constant> (integer value 3). In <xref
                  linkend="example.using.gadget.DigitalInterface" />, we see
                  some example uses of the information returned by
                  <methodname>gadget::DigitalProxy::getData()</methodname>.</para>

                  <example id="example.using.gadget.DigitalInterface">
                     <title>Using
                     <classname>gadget::DigitalInterface</classname> in an
                     Application Object</title>

                     <programlisting linenumbering="numbered">void MyApp::preFrame()
{
   if ( mButton0-&gt;getData() )
   {
      // Set state for when mButton0 is pressed, has been pressed
      // since the last frame, or has been released since the
      // last frame ...
   }
   else
   {
      // Set state for when mButton0 is not pressed ...
   }

   switch (mButton1-&gt;getData()
   {
      case gadget::Digital::OFF:
         // Set state for when mButton1 is not pressed ...
         break;
      case gadget::Digital::ON:
         // Set state for when mButton1 is pressed ...
         break;
      case gadget::Digital::TOGGLE_ON:
         // Set state for when mButton1 has been pressed since
         // the last frame ...
         break;
      case gadget::Digital::TOGGLE_OFF:
         // Set state for when mButton1 has been released since
         // the last frame ...
         break;
   }

   if ( mButton2-&gt;getData() == gadget::Digital::TOGGLE_ON )
   {
      // Set state when mButton2 goes "high" (is toggled on) ...
   }
   else if ( mButton2-&gt;getData() == gadget::Digital::TOGGLE_OFF )
   {
      // Set state when mButton2 goes "low" (is toggled off) ...
   }
}</programlisting>
                  </example>
               </section>

               <section>
                  <title>Using
                  <classname>gadget::GloveInterface</classname></title>

                  <para></para>
               </section>

               <section id="section.using.gadget.KeyboardMouseInterface">
                  <title>Using
                  <classname>gadget::KeyboardMouseInterface</classname></title>

                  <para>Input read from a keyboard and a mouse is provided
                  through
                  <classname>gadget::KeyboardMouseProxy</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::KeyboardMouseProxy</secondary>
                     </indexterm>, instances of which are acquired through
                  <classname>gadget::KeyboardMouseInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::KeyboardMouseInterface</secondary>
                     </indexterm>. Unlike most other device proxy types,
                  <classname>gadget::KeyboardMouseProxy</classname> does not
                  have a <methodname>getData()</methodname> method. Rather, it
                  has a method called <methodname>getEventQueue()</methodname>
                  with return type
                  <classname>gadget::KeyboardMouse::EventQueue</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::KeyboardMouse::EventQueue</secondary>
                     </indexterm> that is the <quote>event queue.</quote>
                  Keyboard and mouse input is handled as events, either key
                  press events or mouse events. Key press events come from the
                  keyboard and are for both the pressing and releasing of
                  individual keys or keys with modifiers
                  (<keycap>CTRL</keycap>, <keycap>ALT</keycap>, and
                  <keycap>SHIFT</keycap>). Mouse events include both the
                  motion of the mouse in the X &amp; Y axes and the pressing
                  and releasing of mouse buttons which may or may not be
                  associated with a keyboard modifier.</para>

                  <para>The event queue contains all the key press and mouse
                  events that occurred since the last frame. Each event is
                  contained in an object of type
                  <classname>gadget::EventPtr</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::EventPtr</secondary>
                     </indexterm><footnote>
                        <para>Behind the scenes,
                        <classname>gadget::KeyboardMouse::EventQueue</classname>
                        is a typedef for
                        <classname>std::vector&lt;gadget::EventPtr&gt;</classname>.</para>
                     </footnote>. The type
                  <classname>gadget::EventPtr</classname> is a
                  reference-counted smart pointer for instances of
                  <classname>gadget::Event</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::Event</secondary>
                     </indexterm>, which is in turn a base class for
                  <classname>gadget::KeyEvent</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::KeyEvent</secondary>
                     </indexterm> and
                  <classname>gadget::MouseEvent</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::MouseEvent</secondary>
                     </indexterm>. Each of these has its own reference-counted
                  smart pointer, namely
                  <classname>gadget::KeyEventPtr</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::KeyEventPtr</secondary>
                     </indexterm> and
                  <classname>gadget::MouseEventPtr</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::MouseEventPtr</secondary>
                     </indexterm>. This seems like a lot of types to
                  understand, but it is simple enough to use by keeping in
                  mind that there are only two types of events: key press
                  events and mouse events. Furthermore, user code should only
                  be interested in <classname>gadget::KeyEventPtr</classname>
                  and <classname>gadget::MouseEventPtr</classname>. The
                  specific event type is determined through the method
                  <methodname>gadget::Event::type()</methodname>.</para>

                  <para>At this point, observant readers will be wondering how
                  to downcast instances of
                  <classname>gadget::EventPtr</classname> to either
                  <classname>gadget::KeyEventPtr</classname> or
                  <classname>gadget::MouseEventPtr</classname>. All three of
                  the reference-counted smart pointer types make use of <ulink
                  url="http://www.boost.org/">Boost</ulink> shared pointers
                  (instantiations of the type
                  <classname>boost::shared_ptr&lt;T&gt;</classname>), part of
                  the <ulink
                  url="http://www.boost.org/libs/smart_ptr/smart_ptr.htm">Boost
                  smart pointer library</ulink>. Boost shared pointers have
                  their own version of the built-in C++ operation
                  <function>dynamic_cast&lt;T,U&gt;()</function> called
                  <function>boost::dynamic_pointer_cast&lt;T,U&gt;()</function>.
                  It works the same way as
                  <function>dynamic_cast&lt;T,U&gt;()</function>, but it is
                  designed specifically for Boost shared pointers. In <xref
                  linkend="example.using.gadget.KeyboardMouseInterface" />, we
                  see how to put all of this together in order to handle
                  keyboard and mouse input.</para>

                  <example id="example.using.gadget.KeyboardMouseInterface">
                     <title>Using
                     <classname>gadget::KeyboardMouseInterface</classname> in
                     an Application Object</title>

                     <programlisting linenumbering="numbered">#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;gadget/Type/KeyboardMouseInterface.h&gt;
#include &lt;gadget/Type/KeyboardMouse/KeyEvent.h&gt;
#include &lt;gadget/Type/KeyboardMouse/MouseEvent.h&gt;
#include &lt;vrj/Draw/OGL/GlApp.h&gt;


// This is here to shorten the use of the function in preFrame()
// boost::dynamic_pointer_cast&lt;T,U&gt;() below.
using namespace boost;

class MyApp : public vrj::GlApp
{
public:
   MyApp() : vrj::GlApp()
   {
      /* Do nothing. */ ;
   }

   virtual ~MyApp()
   {
      /* Do nothing. */ ;
   }

   void init()
   {
      mKeyboard.init("VJKeyboard");
   }

   void preFrame()
   {
      gadget::KeyboardMouse::EventQueue evt_queue =
         mKeyboard-&gt;getEventQueue();
      gadget::KeyboardMouse::EventQueue::iterator i;

      // Loop over all the keyboard and mouse events that
      // occurred since the last frame.
      for ( i = evt_queue.begin(); i != evt_queue.end(); ++i )
      {
         const gadget::EventType type = (*i)-&gt;type();

         if ( type == gadget::KeyPressEvent ||
              type == gadget::KeyReleaseEvent )
         {
            gadget::KeyEventPtr key_evt =
               dynamic_pointer_cast&lt;gadget::KeyEvent&gt;(*i);
            // Handle the key press event ...
         }
         else if ( type == gadget::MouseButtonPressEvent ||
                   type == gadget::MouseButtonReleaseEvent ||
                   type == gadget::MouseMoveEvent )
         {
            gadget::MouseEventPtr mouse_evt =
               dynamic_pointer_cast&lt;gadget::MouseEvent&gt;(*i);
            // Handle the mouse event ...
         }
      }
   }

   void draw()
   {
      // Draw something ...
   }

private:
   gadget::KeyboardMouseInterface mKeyboard;
};</programlisting>
                  </example>
               </section>

               <section>
                  <title>Using
                  <classname>gadget::PositionInterface</classname></title>

                  <para>Position tracking devices return data to application
                  objects as 4×4 transformation matrices. The return type of
                  <methodname>gadget::PositionProxy::getData()</methodname> is
                  <classname>gmtl::Matrix44f</classname>, which was introduced
                  in <xref linkend="section.gmtl.Matrix44f" />. All tracking
                  devices return a full transformation matrix even if the
                  physical tracking hardware is only capable of returning
                  translation or orientation data.</para>

                  <tip>
                     <para>When querying a positional device for its data, it
                     is critical to ask for the data in the units that the
                     application expects. An easy way to do this is to pass
                     the result of
                     <methodname>getDrawScaleFactor()</methodname> to
                     <methodname>gadget::PositionProxy::getData()</methodname>.
                     By default,
                     <methodname>gadget::PositionProxy::getData()</methodname>
                     returns data in feet, and the implementation of
                     <methodname>vrj::App::getDrawScaleFactor()</methodname>
                     returns
                     <constant>gadget::PositionUnitConversion::ConvertToFeet</constant>.
                     This is for backwards compatibility with VR Juggler 1.0
                     behavior. See <xref
                     linkend="example.query.pos.data.units" /> for an example
                     of this. Refer to <xref
                     linkend="section.getDrawScaleFactor" /> for more
                     information about
                     <methodname>getDrawScaleFactor()</methodname>.</para>
                  </tip>

                  <example id="example.query.pos.data.units">
                     <title>Requesting Positional Data in Application-Specific
                     Units</title>

                     <programlisting linenumbering="numbered">#include &lt;gmtl/Matrix.h&gt;

#include &lt;gadget/Type/Position/PositionUnitConversion.h&gt;
#include &lt;gadget/Type/PositionInterface.h&gt;

#include &lt;vrj/Draw/OGL/GlApp.h&gt;


class MyApp : public vrj::GlApp
{
public:
   MyApp() : vrj::GlApp()
   {
      /* Do nothing. */ ;
   }

   virtual ~MyApp()
   {
      /* Do nothing. */ ;
   }

   void init()
   {
      mWand.init("VJWand");
   }

   // Use meters for the application units.
   float getDrawScaleFactor()
   {
      return gadget::PositionUnitConversion::ConvertToMeters;
   }

   void preFrame()
   {
      // Request the current wand transformation matrix in
      // application units (meters).
      const float units = getDrawScaleFactor();
      gmtl::Matrix44f wand_mat(mWand-&gt;getData(units));
      // Do something with the wand transformation ...
   }

   void draw()
   {
      // Draw something ...
   }

private:
   gadget::PositionInterface mWand;
};</programlisting>
                  </example>
               </section>

               <section>
                  <title>Using
                  <classname>gadget::StringInterface</classname></title>

                  <para>String (text- or word-driven) devices were introduced
                  in Gadgeteer 1.0 Beta 1. They are an evolving device type
                  geared towards textual or spoken input. In Gadgeteer 1.0,
                  such input comes in the form of spoken phrases that are
                  returned to the application object as strings matching those
                  in a pre-defined grammar. In future versions of Gadgeteer,
                  this device type may be used for additional forms of
                  high-level input. The return type of
                  <methodname>gadget::StringProxy::getData()</methodname> is
                  <classname>std::string</classname>, and it is up to the
                  person configuring the string device to set up the
                  recognized grammar.</para>
               </section>
            </section>

            <section id="section.stupefied.proxies">
               <title>Stupefied Proxies</title>

               <indexterm zone="section.stupefied.proxies">
                  <primary>proxy</primary>

                  <secondary>stupefied</secondary>
               </indexterm>

               <para>The indirection provided by device proxies facilitates
               run-time reconfiguration of hardware devices. If a hardware
               device breaks down while an application is running, the device
               can be replaced without shutting down and restarting the
               application. To support this capability, proxies can become
               <quote>stupefied,</quote> which means that they are not
               connected to a device and cannot return new data.</para>

               <para>In general, application programmers do not need to worry
               about stupefied proxies. Data will be returned by the proxy
               whether it is stupefied or not, but if the proxy is stupefied,
               it cannot return <emphasis>new</emphasis> data. Stupefied
               proxies can occur as a result of an error in the VR Juggler
               configuration or because the hardware device pointed at by the
               proxy failed to start up correctly.</para>

               <para>To determine whether a proxy is stupefied, the method
               <methodname>gadget::Proxy::isStupefied()</methodname> can be
               used. The stupefied state cannot be changed programatically by
               user code, however. Only the Input Manager is capable of
               reconfiguring a proxy to point at a new valid device. Hence,
               changing the stupefication state of a proxy from an application
               object will have no effect and may cause the application to
               crash.</para>

               <warning>
                  <para>In all versions of VR Juggler prior to 2.0 Beta 3, the
                  word <quote>stupefied</quote> was misspelled as
                  <quote>stupified.</quote> The method
                  <methodname>gadget::Proxy::isStupified()</methodname> is
                  retained in Gadgeteer 1.0 for backwards compatibility, but
                  it will be removed in Gadgeteer 1.2 (which will ship as part
                  of VR Juggler 2.2).</para>
               </warning>
            </section>

            <section id="section.device.interface.details">
               <title>The Gory Details</title>

               <indexterm zone="section.device.interface.details">
                  <primary>gadget::DeviceInterface&lt;T&gt;</primary>

                  <secondary>details</secondary>
               </indexterm>

               <indexterm zone="section.device.interface.details">
                  <primary>device interfaces</primary>

                  <secondary>details</secondary>
               </indexterm>

               <para>What is truly amazing about Gadgeteer device interfaces
               is, despite their seeming complexity, there is really nothing
               to them. Trying to trace through the source code is a little
               tricky, but conceptually, it is all about pointers. Keep in
               mind that all this documentation was written using nothing more
               than the Gadgeteer header files as a reference.</para>

               <para>As mentioned, the class
               <classname>gadget::DeviceInterface&lt;T&gt;</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gadget::DeviceInterface&lt;T&gt;</secondary>
                  </indexterm> provides the method interface for all the
               type-specific instantiations, including the overloaded
               dereference operator. The base class of
               <classname>gadget::DeviceInterface&lt;T&gt;</classname>,
               <classname>gadget::BaseDeviceInterface</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>gadget::BaseDeviceInterface</secondary>
                  </indexterm>, maintains the name of the proxy and the proxy
               reference itself, and it provides the all-important
               <methodname>init()</methodname> method.</para>

               <para>The beauty of it all is that the proxy object being
               pointed to by the device interface can be changed without
               affecting the execution of the user application. In other
               words, the proxies can be changed at run time to point to
               different <emphasis>physical</emphasis> devices. All the while,
               the user code is still using the smart pointer interface and
               getting data of some sort. This flexibility is one of the most
               important features of Gadgeteer, and it is important to
               understand.</para>
            </section>
         </section>
      </chapter>
   </part>

   <part id="app.programming.part">
      <title>Application Programming</title>

      <partintro>
         <para>In each chapter of this part, we outline specific areas of
         interest for application developers. We begin with the basics of
         writing VR Juggler applications in general. Then, we move on to the
         use of different graphics programming interfaces, such as OpenGL and
         OpenSG, with VR Juggler. Afterwards, we address some additional, but
         vital, topics such as how to write cluster-capable applications and
         how to add sound to VR Juggler applications. This part concludes with
         chapters providing tips on porting applications written using other
         toolkits such as GLUT and the
         <productname>CAVElibs</productname>.</para>
      </partintro>

      <chapter id="chapter.writing.apps">
         <title>Application Authoring Basics</title>

         <indexterm zone="chapter.writing.apps">
            <primary>applications</primary>

            <secondary>writing</secondary>

            <tertiary>basics</tertiary>
         </indexterm>

         <para>In this chapter, we build upon the information presented in the
         previous chapters to explain the basics of writing VR Juggler
         applications. This information will apply to all applications
         regardless of the graphics programming interface used to render the
         immersive space. Understanding this chapter will be critical in being
         able to write effective, portable VR Juggler applications.</para>

         <section>
            <title>Application Review</title>

            <para>Before getting into too much detail, we present this section
            as a review from earlier chapters. There is no new information
            here; it is simply a quick overview of the basics of VR Juggler
            applications.</para>

            <section>
               <title>Basic Application Information</title>

               <para>As described in previous chapters (see <xref
               linkend="chapter.getting.started" />, for example), all VR
               Juggler applications derive from a base application object
               class (<classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::App</secondary>
                  </indexterm>). This class defines the basic interface that
               VR Juggler expects from all application objects. This means
               that when constructing an application, the user-defined
               application object must inherit from
               <classname>vrj::App</classname> or from a Draw Manager-specific
               application class that has <classname>vrj::App</classname> as a
               superclass. For example:</para>

               <programlisting>class userApp : public vrj::App
{
public:
   init();
   preFrame();
   postFrame();
}</programlisting>

               <para>This defines a new application class
               (<classname>userApp</classname>), instances of which can be
               used anywhere that VR Juggler expects an application
               object.</para>
            </section>

            <section>
               <title>Draw Manager-Specific Application Classes</title>

               <para>A user application does not have to (and in most cases
               does not) derive from <classname>vrj::App</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::App</secondary>
                  </indexterm> directly. In almost all cases, an application
               class is derived from a Draw Manager-specific application
               class. For example:</para>

               <programlisting>class userGlApp : public vrj::GlApp
{
public:
   init();
   preFrame();
   postFrame();
   
   draw();
}</programlisting>

               <para>This is an example of an OpenGL application. The
               application class (<classname>userGlApp</classname>) has
               derived directly from the OpenGL Draw Manager-specific
               <classname>vrj::GlApp</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::GlApp</secondary>
                  </indexterm> application base class. This class provides
               extra definitions in the interface that are custom for OpenGL
               applications.</para>
            </section>
         </section>

         <section id="section.get.input">
            <title>Getting Input</title>

            <indexterm zone="section.get.input">
               <primary>application programming</primary>

               <secondary>getting input</secondary>
            </indexterm>

            <para>There are many types of input devices that VR Juggler
            application objects can use including positional, digital, and
            analog<indexterm>
                  <primary>input device types</primary>
               </indexterm>. All application objects share the same processes
            and concepts for acquiring input from devices. The main thing to
            remember about getting input in applications is that all VR
            Juggler applications receive input through device proxies managed
            by
            <classname>gadget::DeviceInterface&lt;T&gt;</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::DeviceInterface&lt;T&gt;</secondary>
               </indexterm> instantiations. There are
            <classname>gadget::DeviceInterface&lt;T&gt;</classname>
            instantiations for each type of input data that Gadgeteer can
            handle. There is one for positional input, one for analog, and so
            on. In this section, we will only demonstrate the use of position
            and digital device interfaces. Refer to <xref
            linkend="section.gadget.proxies.devif" /> for more detailed
            information on the use of all the available device
            interfaces.</para>

            <section>
               <title>How to Get Input</title>

               <para>While there has already been a brief presentation about
               getting input in an application, we need something more. Since
               all device interfaces look the same, we will focus on an
               example of getting positional input. All other types are very
               similar. We begin with a simple application object
               skeleton.</para>

               <programlisting>class myApp : public vrj::App
{
public:
   init();
   preFrame();
private:
   gadget::PositionInterface mWand;
}</programlisting>

               <para>Note the declaration of the variable
               <varname>mWand</varname> of type
               <classname>gadget::PositionInterface</classname>. This is the
               first addition to an application. Device interfaces are usually
               member variables of the user application class, as in this
               example.</para>

               <programlisting>myApp::init()
{
   mWand.init("NameOfPosDevInConfiguration");
}</programlisting>

               <para>The device interface has to be told about the device from
               which it will get data. This is done by calling the device
               interface object's <methodname>init()</methodname> method with
               the symbolic string name of the device. This device name comes
               from the active configuration. We are now ready to read from
               the device.</para>

               <programlisting>...
const float units = getDrawScaleFactor();
gmtl::Matrix44f wand_pos(mWand-&gt;getData(units));
...</programlisting>

               <para>The above code shows an example of using the positional
               device interface in an application. It shows some sample code
               where the application copies the positional information from a
               device interface. When it is dereferenced, the device interface
               figures out what device it points to and returns the data from
               that device. Again, refer to <xref
               linkend="section.gadget.proxies.devif" /> for more information
               about using device proxies and device interfaces.</para>
            </section>

            <section>
               <title>Where to Get Input</title>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>where to get device input</secondary>
               </indexterm>

               <para>In the previous section, we showed how to get input from
               devices, but we never said where to put the code. The location,
               surprisingly, is application dependent. There are some very
               good guidelines regarding where applications should process
               input. Before explaining them, however, we should review the VR
               Juggler kernel control loop, presented again in <xref
               linkend="figure.kernel.loop.sequence2" />.</para>

               <figure id="figure.kernel.loop.sequence2">
                  <title>VR Juggler kernel control loop</title>

                  <mediaobject>
                     <imageobject>
                        <imagedata align="center"
                                   fileref="figures/Kernel_Loop_Call_Sequence.png"
                                   format="PNG" scalefit="1" />
                     </imageobject>
                  </mediaobject>
               </figure>

               <para>This diagram looks complicated, but the key here is the
               <methodname>updateAllData()</methodname> call near the bottom
               of the diagram. This is where the Gadgeteer Input Manager
               updates all the cached device data that will be used in drawing
               the next frame. This updated copy is used by all user
               references to device data until the next update and the end of
               the next frame of execution.</para>

               <para>This means two things:</para>

               <orderedlist>
                  <listitem>
                     <para>The device data is most fresh in
                     <methodname>vrj::App::preFrame()</methodname>, and</para>
                  </listitem>

                  <listitem>
                     <para>Any time spent in
                     <methodname>vrj::App::preFrame()</methodname> increases
                     the overall system latency.</para>
                  </listitem>
               </orderedlist>

               <para>The first point is important because it means that the
               copy of the device data with the lowest latency is always
               available in the <methodname>preFrame()</methodname> member
               function. The second point is equally important because it says
               why user applications should not waste any time in
               <methodname>preFrame()</methodname>. Any time spent in
               <methodname>preFrame()</methodname> increases system latency
               and in turn decreases the perceived quality of the environment.
               Hence, it is crucial to avoid placing computations in
               <methodname>preFrame()</methodname>.</para>
            </section>

            <section>
               <title>Tutorial: Getting Input</title>

               <indexterm>
                  <primary>tutorial</primary>

                  <secondary>getting input</secondary>
               </indexterm>

               <highlights>
                  <para>In this section, we present a tutorial that
                  demonstrates simple input handling using Gadgeteer device
                  interfaces. The tutorial overview is as follows:</para>

                  <itemizedlist>
                     <listitem>
                        <para>Description: Simple application that prints the
                        location of the head and the wand.</para>
                     </listitem>

                     <listitem>
                        <para>Objective: Understand how to get positional and
                        digital input in a VR Juggler application.</para>
                     </listitem>

                     <listitem>
                        <para>Member functions:
                        <methodname>vrj::App::init()</methodname>,
                        <methodname>vrj::App::preFrame()</methodname></para>
                     </listitem>

                     <listitem>
                        <para>Directory:
                        <filename>$VJ_BASE_DIR/share/samples/OGL/simple/simpleInput</filename></para>
                     </listitem>

                     <listitem>
                        <para>Files: <filename>simpleInput.h</filename>,
                        <filename>simpleInput.cpp</filename></para>
                     </listitem>
                  </itemizedlist>
               </highlights>

               <section>
                  <title>Class Declaration and Data Members</title>

                  <para>In the following class declaration, note the data
                  members (<varname>mWand</varname>, <varname>mHead</varname>,
                  etc.). This application has four device interface member
                  variables: two for positional input
                  (<varname>mHead</varname> and <varname>mWand</varname>) and
                  two for digital input (<varname>mButton0</varname> and
                  <varname>mButton1</varname>). Each of these member variables
                  will act as a handle to a <quote>real</quote> device from
                  which we will read data in
                  <methodname>preFrame()</methodname>.</para>

                  <programlisting linenumbering="numbered">class simpleInput : public vrj::GlApp
{
public:
   virtual void init();
   virtual void preFrame();

public:
   gadget::PositionInterface mWand;     // Positional interface for Wand position
   gadget::PositionInterface mHead;     // Positional interface for Head position
   gadget::DigitalInterface  mButton0;  // Digital interface for button 0
   gadget::DigitalInterface  mButton1;  // Digital interface for button 1
};</programlisting>
               </section>

               <section>
                  <title>Initializing the Device Interfaces:
                  <methodname>vrj::App::init()</methodname></title>

                  <para>The devices are initialized in the
                  <methodname>init()</methodname> member function of the
                  application. For each device interface member variable, the
                  application calls the variable's own
                  <methodname>init()</methodname> method. The argument passed
                  is the symbolic name of the configured device from which
                  data will be read. From this point on in the application,
                  the member variables are <emphasis>handles</emphasis> to the
                  named device.</para>

                  <programlisting linenumbering="numbered">virtual void init()
{
   // Initialize devices
   mWand.init("VJWand");
   mHead.init("VJHead");
   mButton0.init("VJButton0");
   mButton1.init("VJButton1");
}</programlisting>
               </section>

               <section>
                  <title>Examining the Device Data:
                  <methodname>vrj::App::preFrame()</methodname></title>

                  <para>The following member function implementation gives an
                  example of how to examine the input data using the device
                  interface member variables.</para>

                  <programlistingco>
                     <areaspec>
                        <areaset coords="" id="button.reads">
                           <area coords="3" id="mButton0.read" />

                           <area coords="7" id="mButton1.read" />
                        </areaset>

                        <area coords="12" id="button.print" />

                        <area coords="19" id="position.get" />
                     </areaspec>

                     <programlisting linenumbering="numbered">virtual void preFrame()
{
   if ( mButton0-&gt;getData() )
   {
      std::cout &lt;&lt; "Button 0 pressed" &lt;&lt; std::endl;
   }
   if( mButton1-&gt;getData() )
   {
      std::cout &lt;&lt; "Button 1 pressed" &lt;&lt; std::endl;
   }
 
   std::cout &lt;&lt; "Wand Buttons:"
             &lt;&lt; " 0:" &lt;&lt; mButton0-&gt;getData()
             &lt;&lt; " 1:" &lt;&lt; mButton1-&gt;getData()
             &lt;&lt; std::endl;
                 
   // -- Get Wand matrix --- //
   const float units = getDrawScaleFactor();
   gmtl::Matrix44f wand_matrix(mWand-&gt;getData(units));
   std::cout &lt;&lt; "Wand pos: \n" &lt;&lt; wand_matrix &lt;&lt; std::endl;
}</programlisting>

                     <calloutlist>
                        <callout arearefs="button.reads">
                           <para>These statements check the status of the two
                           digital buttons and write out a line if the button
                           has been pressed.</para>
                        </callout>

                        <callout arearefs="button.print">
                           <para>This writes out the current state of both
                           buttons.</para>
                        </callout>

                        <callout arearefs="position.get">
                           <para>The final section prints out the current
                           location of the wand in the VR environment.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>
            </section>
         </section>
      </chapter>

      <chapter id="chapter.writing.apps.graphics.apis">
         <title>Using Graphics Programming Interfaces</title>

         <indexterm zone="chapter.writing.apps.graphics.apis">
            <primary>applications</primary>

            <secondary>writing</secondary>

            <tertiary>graphics APIs</tertiary>
         </indexterm>

         <para>This chapter comprises the bulk of information about
         application development. This makes sense when one considers the
         importance of computer grahpics in the context of immersive
         applications. In each section of this chapter, we explain the use of
         different graphics application programming interfaces (APIs) within
         the scope of VR Juggler. While the sections of this chapter are tied
         to specific APIs, we highly recommend that all prospective
         programmers of VR Juggler applications read the first section about
         OpenGL applications. This section covers core fundamentals of the VR
         Juggler OpenGL Draw Manager that apply to the use of Open Scene Graph
         and OpenSG with VR Juggler.</para>

         <section id="section.opengl.apps">
            <title>OpenGL Applications</title>

            <indexterm zone="section.opengl.apps">
               <primary>application programming</primary>

               <secondary>OpenGL</secondary>
            </indexterm>

            <para>We can now describe how to write OpenGL applications in VR
            Juggler. An OpenGL-based VR Juggler application must be derived
            from <classname>vrj::GlApp</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vrj::GlApp</secondary>
               </indexterm>. This in turn is derived from
            <classname>vrj::App</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vrj::App</secondary>
               </indexterm>. As was discussed in the application object
            section, <classname>vrj::App</classname> defines the base
            interface that VR Juggler expects of all applications. The
            <classname>vrj::GlApp</classname> class extends this interface by
            adding members that the VR Juggler OpenGL Draw Manager needs to
            render an OpenGL application correctly.</para>

            <figure id="figure.vrj.GlApp2">
               <title><classname>vrj::GlApp</classname> application
               class</title>

               <mediaobject>
                  <imageobject>
                     <imagedata align="center"
                                fileref="figures/userOglApp_hierarchy.png"
                                format="PNG" />
                  </imageobject>
               </mediaobject>
            </figure>

            <para>In <xref linkend="figure.vrj.GlApp2" />, we see some of the
            methods added by the <classname>vrj::GlApp</classname> interface:
            <methodname>draw()</methodname>,
            <methodname>contextInit()</methodname>, and
            <methodname>contextPreDraw()</methodname><indexterm>
                  <primary>vrj::GlApp</primary>

                  <secondary>extensions to vrj::App</secondary>
               </indexterm>. These methods deal with OpenGL drawing and
            managing <glossterm linkend="gloss.csdata">context-specific
            data</glossterm> (do not worry what context data is right now—we
            cover that in detail later). There are a few other member
            functions in the interface, but these cover 99% of the issues that
            most developers face. In the following sections, we will describe
            how to add OpenGL drawing to an application and how to handle
            context-specific data. There is a tutorial for each topic.</para>

            <section id="section.clear.buffers">
               <title>Clearing the Color and Depth Buffers</title>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>OpenGL</secondary>

                  <tertiary>clearing color and depth buffers</tertiary>
               </indexterm>

               <indexterm>
                  <primary>vrj::GlApp</primary>

                  <secondary>bufferPreDraw() method</secondary>
               </indexterm>

               <para>Before describing how to render using OpenGL with VR
               Juggler, we must cover the more basic topic of clearing the
               color and depth buffers. We describe this part before
               explaining how to render graphics because these steps will be
               common to all VR Juggler applications based on OpenGL.</para>

               <para>In VR Juggler 1.1 and beyond, there is support for
               drawing multiple OpenGL viewports in a single VR Juggler
               display window. This feature is useful for tiled displays where
               each viewport renders a specific part of the scene. In order
               for an OpenGL-based application to work with multiple
               viewports, the color and depth buffers need to be cleared at
               the correct times.</para>

               <para>In a user application, the method
               <methodname>vrj::GlApp::bufferPreDraw()</methodname> is
               overridden so that it clears the color buffer. For example, the
               following code clears the color buffer using black:</para>

               <programlisting>void userApp::bufferPreDraw()
{
   glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
   glClear(GL_COLOR_BUFFER_BIT);
}</programlisting>

               <para>Now we need to clear the depth buffer. This must be done
               separately from the color buffer to ensure proper stereo
               rendering. The depth buffer must be cleared in the application
               object's <methodname>draw()</methodname> method, usually as the
               first step:</para>

               <programlisting>void userApp::draw()
{
   glClear(GL_DEPTH_BUFFER_BIT);

   // Rendering the scene ...
}</programlisting>
            </section>

            <section>
               <title>OpenGL Drawing:
               <methodname>vrj::GlApp::draw()</methodname></title>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>OpenGL</secondary>

                  <tertiary>drawing</tertiary>
               </indexterm>

               <indexterm>
                  <primary>vrj::GlApp</primary>

                  <secondary>draw() method</secondary>
               </indexterm>

               <para>The most important (and visible) component of most OpenGL
               applications is the OpenGL drawing. The
               <classname>vrj::GlApp</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vrj::GlApp</secondary>
                  </indexterm> class interface defines a
               <methodname>draw()</methodname> member function to hold the
               code for drawing a virtual environment. Hence, any OpenGL
               drawing calls should be placed in the
               <methodname>vrj::GlApp::draw()</methodname> function of the
               user application object.</para>

               <para>Adding drawing code to an OpenGL-based VR Juggler
               application is straightforward. The
               <methodname>draw()</methodname> method is called whenever the
               OpenGL Draw Manager needs to render a view of the virtual world
               created by the user's application. It is called for each
               defined OpenGL context, and it may be called multiple times per
               frame in the case of multi-surface setups and/or stereo
               configurations. Applications should <emphasis>never</emphasis>
               rely upon the number of times this member function is called
               per frame.</para>

               <para>When the method is called, the OpenGL model view and
               projection matrices have been configured correctly to draw the
               scene. Input devices are guaranteed to be in the same state
               (position, value, etc.) for each call to the
               <methodname>draw()</methodname> method for a given
               frame.</para>

               <section>
                  <title>Recommended Uses</title>

                  <para>The only code that should execute in this function is
                  calls to OpenGL drawing routines. It is permissible to read
                  from input devices to determine what to draw, but
                  application data members should not be updated in this
                  function.</para>
               </section>

               <section>
                  <title>Possible Misuses</title>

                  <para>The <methodname>draw()</methodname> method should not
                  be used to perform any time-consuming computations. Code in
                  this member function should not change the state of any
                  application variables.</para>
               </section>
            </section>

            <section id="section.simple.opengl.app">
               <title>Tutorial: Drawing a Cube with OpenGL</title>

               <indexterm>
                  <primary>tutorial</primary>

                  <secondary>drawing a cube with OpenGL</secondary>
               </indexterm>

               <highlights>
                  <para>In this section, we present a tutorial that
                  demonstrates simple rendering with OpenGL calls. The
                  tutorial overview is as follows:</para>

                  <itemizedlist>
                     <listitem>
                        <para>Description: Simple OpenGL application that
                        draws a cube in the environment.</para>
                     </listitem>

                     <listitem>
                        <para>Objectives: Understand how the
                        <methodname>draw()</methodname> member function in
                        <classname>vrj::GlApp</classname> works; create basic
                        OpenGL-based VR Juggler applications.</para>
                     </listitem>

                     <listitem>
                        <para>Member functions:
                        <methodname>vrj::App::init()</methodname>,
                        <methodname>vrj::GlApp::draw()</methodname></para>
                     </listitem>

                     <listitem>
                        <para>Directory:
                        <filename>$VJ_BASE_DIR/share/samples/OGL/simple/SimpleApp</filename></para>
                     </listitem>

                     <listitem>
                        <para>Files: <filename>simpleApp.h</filename>,
                        <filename>simpleApp.cpp</filename></para>
                     </listitem>
                  </itemizedlist>
               </highlights>

               <section>
                  <title>Class Declaration</title>

                  <para>The following application class is called
                  <classname>simpleApp</classname>. It is derived from
                  <classname>vrj::GlApp</classname> and has custom
                  <methodname>init()</methodname> and
                  <methodname>draw()</methodname> methods declared. Note that
                  the application declares several device interface members
                  that are used by the application for getting device
                  data.</para>

                  <programlisting linenumbering="numbered">using namespace vrj;
using namespace gadget;

class simpleApp : public GlApp
{
public:
   simpleApp();
   virtual void init();
   virtual void draw();

public:
   PositionInterface mWand;
   PositionInterface mHead;
   DigitalInterface mButton0;
   DigitalInterface mButton1;
};</programlisting>
               </section>

               <section>
                  <title>The <methodname>draw()</methodname> Member
                  Function</title>

                  <para>The implementation of <methodname>draw()</methodname>
                  is located in <filename>simpleApp.cpp</filename>. Its job is
                  to draw the environment. A partial implementation
                  follows.</para>

                  <programlistingco>
                     <areaspec>
                        <area coords="5" id="box-offset.init" />

                        <area coords="11" id="box-offset.push" />

                        <area coords="13" id="draw.cube" />
                     </areaspec>

                     <programlisting linenumbering="numbered">using namespace gmtl;

void simpleApp::draw()
{
   ...
   // Create box offset matrix
   Matrix44f box_offset;
   const EulerAngleXYZf euler_ang(Math::deg2Rad(-90.0f), Math::deg2Rad(0.0f),
                                  Math::deg2Rad(0.0f));
   box_offset = gmtl::makeRot&lt;Matrix44f&gt;(euler_ang);
   gmtl::setTrans(box_offset, Vec3f(0.0, 1.0f, 0.0f));
   ...
   glPushMatrix();
      // Push on offset
      glMultMatrixf(box_offset.getData());
      ...
      drawCube();
   glPopMatrix();
   ...
}</programlisting>

                     <calloutlist>
                        <callout arearefs="box-offset.init">
                           <para>This creates a
                           <classname>gmtl::Matrix44f</classname> object that
                           defines the offset of the cube in the virtual
                           world.</para>
                        </callout>

                        <callout arearefs="box-offset.push">
                           <para>The new matrix is pushed onto the OpenGL
                           modelview matrix stack.</para>
                        </callout>

                        <callout arearefs="draw.cube">
                           <para>Finally, a cube is drawn.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>

                  <para>In the above, there is no projection code in the
                  function. When the function is called by VR Juggler, the
                  projection matrix has already been set up correctly for the
                  system. All the user application must do is draw the
                  environment; VR Juggler handles the rest. In this example,
                  the <methodname>draw()</methodname> member function renders
                  a cube at an offset location.</para>
               </section>

               <section>
                  <title>Exercise</title>

                  <para>Change the code so that the cube is drawn at the
                  position of the wand instead of at the
                  <varname>box_offset</varname> location.</para>
               </section>
            </section>

            <section id="section.csdata.intro">
               <title>Context-Specific Data</title>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>OpenGL</secondary>

                  <tertiary>context-specific data</tertiary>
               </indexterm>

               <indexterm>
                  <primary>context-specific data</primary>
               </indexterm>

               <para>Many readers may already be familiar with the specifics
               of OpenGL. In this section, we provide a very brief
               introduction to <glossterm
               linkend="gloss.csdata">context-specific data</glossterm> within
               OpenGL, and we proceed to explain how it is used by VR Juggler.
               Those who are already familiar with context-specific data may
               skip ahead to <xref linkend="section.need.for.csdata" /> or to
               <xref linkend="section.using.csdata" />.</para>

               <para>The OpenGL graphics API operates using a state machine
               that tracks the current settings and attributes set by the
               OpenGL code. Each window in which we render using OpenGL has a
               state machine associated with it. The state machines associated
               with these windows are referred to as <glossterm
               linkend="gloss.opengl.rendering.context">OpenGL rendering
               contexts</glossterm><indexterm>
                     <primary>OpenGL rendering contexts</primary>
                  </indexterm>.</para>

               <para>Each context stores the current state of an OpenGL
               renderer instance. The state includes the following:</para>

               <itemizedlist>
                  <listitem>
                     <para>Current color</para>
                  </listitem>

                  <listitem>
                     <para>Current shading mode</para>
                  </listitem>

                  <listitem>
                     <para>Current texture</para>
                  </listitem>

                  <listitem>
                     <para>Display lists</para>
                  </listitem>

                  <listitem>
                     <para>Texture objects</para>
                  </listitem>
               </itemizedlist>

               <section id="section.need.for.csdata">
                  <title>Why it is Needed</title>

                  <para>As outlined in the VR Juggler architecture
                  documentation, VR Juggler uses a single memory area for all
                  application data. All threads can see the same memory area
                  and thus share the same copy of all variables. This makes
                  programming normal application code very easy because
                  programmers never have to worry about which thread can see
                  which variables. In the case of context-specific data,
                  however, it presents a problem.</para>

                  <para>To understand the problem, consider an environment
                  where we use a single display list. That display list is
                  created to draw some object in the scene. We would like to
                  be able to call the display list in our
                  <methodname>draw()</methodname> method and have it draw the
                  primitives that were captured in it.</para>

                  <para>The following class skeleton shows an outline of this
                  idea. Do not worry for now that we do not show the code
                  where we allocate the display list—that will be covered
                  later. For now, we see that there is a variable that stores
                  the display list ID (<varname>mDispListId</varname>), and we
                  use it in the <methodname>draw()</methodname> method.</para>

                  <programlisting>using namespace vrj;

class userApp : public GlApp
{
public:
  draw();
public:
  int mDispListId;
};

userApp::draw()
{
   glCallList(mDispListId);
}</programlisting>

                  <para>Now, imagine that we have a VR system configured that
                  needs more than one display window (a multi-wall projection
                  system, for example). There is a thread for each display,
                  and all the display threads call
                  <methodname>draw()</methodname> in parallel.</para>

                  <para>Since all threads share the same copy of the
                  variables, they all use the same
                  <varname>mDispListId</varname> when calling
                  <function>glCallList()</function>. This is an error because
                  we call draw from multiple windows (that is, multiple OpenGL
                  rendering contexts). The display list ID is not the same in
                  each context. What we need, then, is a way to use a
                  different display list ID depending upon the OpenGL context
                  within which we are currently rendering. Context-specific
                  data comes to the rescue to address this problem.</para>

                  <para>Context-specific data provides us with a way to get a
                  separate copy of a variable for each OpenGL rendering
                  context. This may sound daunting at first, but VR Juggler
                  manages this special variable so that it appears just as a
                  normal variable. The developer never has to deal with
                  contexts directly. VR Juggler transparently ensures that the
                  correct copy of the variable is being used.</para>
               </section>

               <section>
                  <title>Context-Specific Variables in VR Juggler</title>

                  <indexterm>
                     <primary>context-specific variables</primary>
                  </indexterm>

                  <para>The following shows how a context-specific variable
                  appears in a VR Juggler application:</para>

                  <programlisting>using namespace vrj;

class userApp : public GlApp
{
public:
   draw();
public:
   GlContextData&lt;int&gt; mDispListId; // Context-specific variable
};

userApp::draw()
{
   glCallList(*mDispListId);
}</programlisting>

                  <para>This code looks nearly the same as the previous
                  example. In this case, <varname>mDispListId</varname> is
                  treated as a pointer, and it has a special template-based
                  type that tells VR Juggler it is context-specific data. When
                  defining a context-specific data member, use the
                  <classname>vrj::GlContextData&lt;T&gt;</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>vrj::GlContextData&lt;T&gt;</secondary>
                     </indexterm> template class and pass the
                  <quote>true</quote> type of the variable to the template
                  definition. From then on, it can be treated as a normal
                  pointer.</para>

                  <note>
                     <para>The types that are used for context-specific data
                     must provide default constructors. The user cannot
                     directly call the constructor for the data item because
                     VR Juggler has to allocate new items on the fly as new
                     contexts are created.</para>
                  </note>
               </section>

               <section>
                  <title>The Inner Workings of Context-Specific
                  Variables</title>

                  <para>Curious readers are probably wondering how all of this
                  works. To satisfy any curiosity, we now provide a brief
                  description.</para>

                  <para>The context data items are allocated using a
                  template-based smart pointer class
                  (<classname>vrj::GlContextData&lt;T&gt;</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>vrj::GlContextData&lt;T&gt;</secondary>
                     </indexterm>). Behind the scenes, VR Juggler keeps a list
                  of currently allocated variables for each context. When the
                  application wants to use a context data item, the smart
                  pointer looks in the list and returns a reference to the
                  correct copy for the current context.</para>

                  <para>This is all done in a fairly light-weight manner. It
                  all boils down to one memory lookup and a couple of pointer
                  dereferences. Not bad for all the power that it
                  gives.</para>
               </section>
            </section>

            <section id="section.using.csdata">
               <title>Using Context-Specific Data</title>

               <indexterm>
                  <primary>context-specific data</primary>

                  <secondary>use of</secondary>
               </indexterm>

               <para>The VR Juggler OpenGL graphics system is a complex,
               multi-headed beast. Luckily, developers do not have to
               understand how the system is working to use it correctly. As
               long as developers subscribe to several simple rules for
               allocating and using context data, everything will work fine.
               This section contains these rules, but it does not describe the
               rationale behind the rules. Those readers who are interested in
               the details of why these rules should be followed should please
               read the subsequent section. It contains much more
               (excruciating) detail.</para>

               <section>
                  <title>The Rules</title>

                  <para>With the background in how to make a context-specific
                  data member and how to use it in a
                  <methodname>draw()</methodname> member function, we can move
                  on to how and where the context-specific data should be
                  allocated. If we want to create a display list, we need to
                  know where we should allocate it.</para>

                  <section>
                     <title>Rule 1: Do not allocate context data in
                     <methodname>draw()</methodname></title>

                     <para>This is straightforward: do not allocate context
                     data in the <methodname>draw()</methodname> member
                     function. There are many reasons for this, but the
                     primary one is that allocation tests would be occurring
                     too many times and at incorrect times. There are better
                     places to allocate context data.</para>
                  </section>

                  <section>
                     <title>Rule 2: Initialize static context data in
                     <methodname>contextInit()</methodname></title>

                     <para>The place to allocate static context-specific data
                     is the
                     <methodname>vrj::GlApp::contextInit()</methodname><indexterm>
                           <primary>vrj::GlApp</primary>

                           <secondary>contextInit() method</secondary>
                        </indexterm> member function. <quote>Static</quote>
                     context data refers to context data that does not change
                     during the application's execution. An example of static
                     context data would be a display list to render an object
                     model that is preloaded by the application and never
                     changes. It is static because the display list only has
                     to be generated once for each context, and the
                     application can generate the display list as soon as it
                     starts execution.</para>

                     <para>The <methodname>contextInit()</methodname> member
                     function is called immediately after creation of any
                     <emphasis>new</emphasis> OpenGL contexts. In other words,
                     it is called whenever new windows open. When it is
                     called, the newly created context is active. This method
                     is the perfect place to allocate static context data
                     because it is only called when we have a new context that
                     we need to prepare (and also because that is what it is
                     designed for).</para>

                     <para>The following code snippet shows a possible use of
                     the application object's
                     <methodname>contextInit()</methodname> method:</para>

                     <example id="context.data.init.example">
                        <title>Initializing context-specific data</title>

                        <programlisting linenumbering="numbered">void userApp::contextInit()
{
   // Allocate context specific data
   (*mDispListId) = glGenLists(1);

   glNewList((*mDispListId), GL_COMPILE);
      glScalef(0.50f, 0.50f, 0.50f);
      // Call func that draws a cube in OpenGL
      drawCube();
   glEndList();
   ...
}</programlisting>
                     </example>

                     <para>This shows the normal way that display lists should
                     be allocated in VR Juggler. Allocate the display list,
                     store it to a context-specific data member, and then fill
                     the display list. Texture objects and other types of
                     context-specific data are created in exactly the same
                     manner.</para>
                  </section>

                  <section>
                     <title>Rule 3: Allocate and update dynamic context data
                     in <methodname>contextPreDraw()</methodname></title>

                     <para>The place to allocate dynamic context-specific data
                     is the
                     <methodname>contextPreDraw()</methodname><indexterm>
                           <primary>vrj::GlApp</primary>

                           <secondary>contextPreDraw() method</secondary>
                        </indexterm> member function. <quote>Dynamic</quote>
                     context data differs from static context data in that
                     dynamic data may change during the application's
                     execution. An example of dynamic data would be a display
                     list for rendering an object from a data set that changes
                     as the applications executes. This requires dynamic
                     context data because the display list has to be
                     regenerated every time the application changes the data
                     set.</para>

                     <para>Consider also the following example. While running
                     an application, the user requests to load a new model
                     from a file. After the model data is loaded, it may be
                     best to put the drawing functions into a fresh display
                     list for rendering the model. In this case,
                     <methodname>vrj::GlApp::contextInit()</methodname> cannot
                     be used because it is only called when a new context is
                     created. Here, all the windows have already been created.
                     What we need, then, is a <glossterm
                     linkend="gloss.callback">callback</glossterm> that is
                     called once per existing context so that we can add and
                     change the context-specific data. That is what
                     <methodname>contextPreDraw()</methodname> does. It is
                     called once per context for each VR Juggler frame with
                     the current context active.</para>

                     <para>Please notice, however, that since this method is
                     called often and is called in performance-critical areas,
                     you should not do much work in it. Any time taken by this
                     method directly decreases the draw performance of the
                     application. In most cases, we recommend trying to make
                     the function have a very simple early exit clause such as
                     in the following example. This makes the average cost
                     only that of a single comparison operation.</para>

                     <programlisting>userApp::contextInit()
{
   if (have work to do)
   {
     // Do it
   }
}</programlisting>
                  </section>
               </section>
            </section>

            <section>
               <title>Context-Specific Data Details</title>

               <indexterm>
                  <primary>context-specific data</primary>

                  <secondary>details</secondary>
               </indexterm>

               <para>Within this section, we provide the details of
               context-specific data in VR Juggler and justify the rules
               presented in the previous section.</para>

               <figure id="figure.vrj.opengl.system">
                  <title>VR Juggler OpenGL system</title>

                  <mediaobject>
                     <imageobject>
                        <imagedata align="center"
                                   fileref="figures/JugglerOGLSystemChart.png"
                                   format="PNG" scalefit="1" />
                     </imageobject>
                  </mediaobject>
               </figure>

               <section>
                  <title>Do Not Allocate Context-Specific Data in
                  <methodname>draw()</methodname></title>

                  <para>Rule 1 says that context-specific data should not be
                  allocated in an application object's
                  <methodname>draw()</methodname> method. We have already
                  stated that the main reason is that
                  <methodname>draw()</methodname> is called too many times,
                  and it is called at the wrong time for allocation of
                  context-specific data. To be more specific, the
                  <methodname>draw()</methodname> method is called for each
                  surface, or for each eye, every frame. Static
                  context-specific data only needs to be allocated when a new
                  window is opened. (Dynamic context-specific data is handled
                  separately.)</para>
               </section>
            </section>

            <section>
               <title>Tutorial: Drawing a Cube using OpenGL Display
               Lists</title>

               <indexterm>
                  <primary>tutorial</primary>

                  <secondary>drawing a cube using display lists</secondary>
               </indexterm>

               <highlights>
                  <para>In this section, we present a tutorial that
                  demonstrates the use of OpenGL display lists with VR Juggler
                  context-specific data. The tutorial overview is as
                  follows:</para>

                  <itemizedlist>
                     <listitem>
                        <para>Description: Drawing a cube using a display list
                        in the <methodname>draw()</methodname> member
                        function.</para>
                     </listitem>

                     <listitem>
                        <para>Objective: Understand how to use
                        context-specific data in an application.</para>
                     </listitem>

                     <listitem>
                        <para>Member functions:
                        <methodname>vrj::App::init()</methodname>,
                        <methodname>vrj::GlApp::contextInit()</methodname>,
                        <methodname>vrj::GlApp::draw()</methodname></para>
                     </listitem>

                     <listitem>
                        <para>Directory:
                        <filename>$VJ_BASE_DIR/share/samples/OGL/simple/contextApp</filename></para>
                     </listitem>

                     <listitem>
                        <para>Files: <filename>contextApp.h</filename>,
                        <filename>contextApp.cpp</filename></para>
                     </listitem>
                  </itemizedlist>
               </highlights>

               <section>
                  <title>Class Declaration and Data Members</title>

                  <para>The following code example shows the basics of
                  declaring the class interface and data members for an
                  application that will use context-specific data. This is an
                  extension of the simple OpenGL application presented in
                  <xref linkend="section.simple.opengl.app" />. Note the
                  addition of the <methodname>contextInit()</methodname>
                  declaration and the use of the context-specific data member
                  <varname>mCubeDlId</varname>.</para>

                  <programlisting linenumbering="numbered">using namespace vrj;

class contextApp : public GlApp
{
public:
   contextApp() {;}
   virtual void init();
   virtual void contextInit();
   virtual void draw();
    ...
public:
   // Id of the cube display list
   GlContextData&lt;GLuint&gt; mCubeDlId;
   ...
};</programlisting>
               </section>

               <section>
                  <title>The <methodname>contextInit()</methodname> Member
                  Function</title>

                  <para>We now show the implementation of
                  <methodname>contextApp::contextInit()</methodname>. Here the
                  display list is created and stored using context-specific
                  data. Recall <xref linkend="context.data.init.example" />,
                  presented in <xref linkend="section.using.csdata" />. That
                  example was based on this tutorial application.</para>

                  <programlisting linenumbering="numbered">void contextApp::contextInit()
{
   // Allocate context specific data
   (*mCubeDlId) = glGenLists(1);

   glNewList((*mCubeDlId), GL_COMPILE);
      glScalef(0.50f, 0.50f, 0.50f);
      drawCube();
   glEndList();
   ...
}</programlisting>
               </section>

               <section>
                  <title>The <methodname>draw()</methodname> Member
                  Function</title>

                  <para>Now that we have a display list ID in context-specific
                  data, we can use it in the <methodname>draw()</methodname>
                  member function. We render the display list by dereferencing
                  the context-specific display list ID.</para>

                  <programlisting linenumbering="numbered">using namespace gmtl;

void contextApp::draw()
{
   // Get Wand matrix
   const float units = getDrawScaleFactor();
   gmtl::Matrix44f wand_matrix(mWand-&gt;getData(units));
   ...
   glPushMatrix();
      glPushMatrix();
         glMultMatrixf(wand_mat.getData());    
         glCallList(*mCubeDlId);
      glPopMatrix();
      ...
   glPopMatrix();
}</programlisting>
               </section>

               <section>
                  <title>Exercise</title>

                  <para>In the tutorial application code, replace the call to
                  <methodname>drawAxis()</methodname> with a display list
                  call.</para>
               </section>
            </section>
         </section>

         <section id="section.pf.apps">
            <title>OpenGL Performer Applications</title>

            <indexterm zone="section.pf.apps">
               <primary>application programming</primary>

               <secondary>OpenGL Performer</secondary>
            </indexterm>

            <para>Programmers familiar with the use of scene graphs may prefer
            to use that data structure rather than writing OpenGL manually.
            While VR Juggler does not provide a scene graph of its own, its
            design allows the use of existing scene graph software. In VR
            Juggler 1.1 and beyond, the supported scene graphs are OpenGL
            Performer from SGI, OpenSG, and Open Scene Graph. This section
            explains how to use OpenGL Performer to write VR Juggler
            applications.</para>

            <para>A Performer-based VR Juggler application must derive from
            <classname>vrj::PfApp</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vrj::PfApp</secondary>
               </indexterm>. Similar to <classname>vrj::GlApp</classname>
            presented in the previous section,
            <classname>vrj::PfApp</classname> derives from
            <classname>vrj::App</classname>. <classname>vrj::PfApp</classname>
            extends <classname>vrj::App</classname> by adding methods that
            deal with scene graph initialization and access. <xref
            linkend="figure.vrj.PfApp2" /> shows how
            <classname>vrj::PfApp</classname> fits into the class hierarchy of
            a Performer-based VR Juggler application.</para>

            <figure id="figure.vrj.PfApp2">
               <title><classname>vrj::PfApp</classname> application
               class</title>

               <mediaobject>
                  <imageobject>
                     <imagedata align="center"
                                fileref="figures/userPfApp_hierarchy.png"
                                format="PNG" />
                  </imageobject>
               </mediaobject>
            </figure>

            <para>Two of the methods added to the application interface by
            <classname>vrj::PfApp</classname> are
            <methodname>initScene()</methodname> and
            <methodname>getScene()</methodname><indexterm>
                  <primary>vrj::PfApp</primary>

                  <secondary>extensions to vrj::App</secondary>
               </indexterm>. These are called by the Performer Draw Manager to
            initialize the application scene graph and to get the root of the
            scene graph respectively. They must be implemented by the
            application (they are pure virtual methods within
            <classname>vrj::PfApp</classname>). Additional methods will be
            discussed in this section, but in many cases the default
            implementations of these other methods may be used. A simple
            tutorial application will be provided to illustrate the concepts
            presented.</para>

            <section>
               <title>Scene Graph Initialization:
               <methodname>vrj::PfApp::initScene()</methodname></title>

               <indexterm>
                  <primary>vrj::PfApp</primary>

                  <secondary>initScene() method</secondary>
               </indexterm>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>OpenGL Performer</secondary>

                  <tertiary>scene graph initialization</tertiary>
               </indexterm>

               <para>In an application using OpenGL Performer, the scene graph
               must be initialized before it can be used. The method
               <methodname>vrj::PfApp::initScene()</methodname> is provided
               for that purpose. Within this method, the root of the
               application scene graph should be created, and any required
               models should be loaded and attached to the root in some way.
               The exact mechanisms for accomplishing this will vary depending
               on what the application will do.</para>

               <para>During the initialization of OpenGL Performer by VR
               Juggler, <methodname>vrj::PfApp::initScene()</methodname> is
               invoked after the Performer functions
               <function>pfInit()</function> and
               <function>pfConfig()</function> but before
               <methodname>vrj::App::apiInit()</methodname>.</para>
            </section>

            <section>
               <title>Scene Graph Access:
               <methodname>vrj::PfApp::getScene()</methodname></title>

               <indexterm>
                  <primary>vrj::PfApp</primary>

                  <secondary>getScene() method</secondary>
               </indexterm>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>OpenGL Performer</secondary>

                  <tertiary>scene graph access</tertiary>
               </indexterm>

               <para>In order for Performer to render the application scene
               graph, it must get access to the scene graph root. The method
               <methodname>vrj::PfApp::getScene()</methodname> will be called
               by the Performer Draw Manager so that it can give the scene
               graph root node to Performer. Since the job of
               <methodname>getScene()</methodname> is straightforward, its
               implementation can be very simple. A typical implementation
               will have a single statement that returns a member variable
               that holds a pointer to the application scene graph root
               node.</para>

               <note>
                  <para>Make sure that the node returned is
                  <emphasis>not</emphasis> a <classname>pfScene</classname>
                  object. If it is, then lighting will not work.</para>
               </note>

               <section>
                  <title>Possible Misuses</title>

                  <para>Do not load any models in this member function. This
                  sort of operation should be done within
                  <methodname>initScene()</methodname>.</para>
               </section>
            </section>

            <section>
               <title>Tutorial: Loading a Model with OpenGL Performer</title>

               <indexterm>
                  <primary>tutorial</primary>

                  <secondary>loading a model with OpenGL Performer</secondary>
               </indexterm>

               <highlights>
                  <para>In this section, we present a tutorial that
                  demonstrates model loading with OpenGL Performer. The
                  tutorial overview is as follows:</para>

                  <itemizedlist>
                     <listitem>
                        <para>Description: Simple OpenGL Performer application
                        that loads a model.</para>
                     </listitem>

                     <listitem>
                        <para>Objective: Understand how to load a model, add
                        it to a scene graph, and return the root to VR
                        Juggler.</para>
                     </listitem>

                     <listitem>
                        <para>Member functions:
                        <methodname>vrj::PfApp::initScene()</methodname>,
                        <methodname>vrj::PfApp::getScene()</methodname></para>
                     </listitem>

                     <listitem>
                        <para>Directory:
                        <filename>$VJ_BASE_DIR/share/samples/Pf/simple/simplePf</filename></para>
                     </listitem>

                     <listitem>
                        <para>Files: <filename>simplePfApp.h</filename>,
                        <filename>simplePfApp.cpp</filename></para>
                     </listitem>
                  </itemizedlist>
               </highlights>

               <section>
                  <title>Class Declaration</title>

                  <para>The following application class is called
                  <classname>simplePfApp</classname>. It is derived from
                  <classname>vrj::PfApp</classname> and has custom
                  <methodname>initScene()</methodname> and
                  <methodname>getScene()</methodname> methods declared. Note
                  that this application uses
                  <methodname>preForkInit()</methodname> which will be
                  discussed later. Refer to <filename>simplePfApp.h</filename>
                  for the implementations of
                  <methodname>preForkInit()</methodname> and
                  <methodname>setModel()</methodname>.</para>

                  <programlisting linenumbering="numbered">class simplePfApp : public vrj::PfApp
{
public:
   simplePfApp();
   virtual ~simplePfApp();

   virtual void preForkInit();
   virtual void initScene();
   virtual pfGroup* getScene();
   void setModel(std::string modelFile);

public:
   std::string    mModelFileName;

   pfGroup*       mLightGroup;
   pfLightSource* mSun;
   pfGroup*       mRootNode;
   pfNode*        mModelRoot;
};</programlisting>
               </section>

               <section>
                  <title>The <methodname>initScene()</methodname> Member
                  Function</title>

                  <para>The implementation of
                  <methodname>initScene()</methodname> is in
                  <filename>simplePfApp.cpp</filename>. Within this method, we
                  create the scene graph root node, the lighting node, and
                  load a user-specified model. The implementation
                  follows:</para>

                  <programlistingco>
                     <areaspec>
                        <area coords="4" id="rootnode.create" />

                        <area coords="7" id="light.source.create" />

                        <area coords="17" id="model.load" />

                        <areaset coords="" id="scenegraph.add.all">
                           <area coords="20" id="scenegraph.add.model" />

                           <area coords="21" id="scenegraph.add.light" />
                        </areaset>
                     </areaspec>

                     <programlisting linenumbering="numbered">void simplePfApp::initScene ()
{
   // Allocate all the nodes needed
   mRootNode = new pfGroup;

   // Create the SUN light source
   mLightGroup = new pfGroup;
   mSun = new pfLightSource;
   mLightGroup-&gt;addChild(mSun);
   mSun-&gt;setPos(0.3f, 0.0f, 0.3f, 0.0f);
   mSun-&gt;setColor(PFLT_DIFFUSE, 1.0f, 1.0f, 1.0f);
   mSun-&gt;setColor(PFLT_AMBIENT, 0.3f, 0.3f, 0.3f);
   mSun-&gt;setColor(PFLT_SPECULAR, 1.0f, 1.0f, 1.0f);
   mSun-&gt;on();

   // --- LOAD THE MODEL -- //
   mModelRoot = pfdLoadFile(mModelFileName.c_str());

   // -- CONSTRUCT STATIC STRUCTURE OF SCENE GRAPH -- //
   mRootNode-&gt;addChild(mModelRoot);
   mRootNode-&gt;addChild(mLightGroup);
}</programlisting>

                     <calloutlist>
                        <callout arearefs="rootnode.create">
                           <para>First, the root node is constructed as a
                           <classname>pfGroup</classname> object.</para>
                        </callout>

                        <callout arearefs="light.source.create">
                           <para>Next, some steps are taken to create a light
                           source for the application.</para>
                        </callout>

                        <callout arearefs="model.load">
                           <para>Finally, the model is loaded using
                           <function>pfdLoadFile()</function>, and the model
                           scene graph root node is stored in
                           <varname>mModelRoot</varname>. (The model loader
                           must be initialized prior to calling
                           <function>pfdLoadFile()</function>. This is done in
                           <methodname>preForkInit()</methodname>.)</para>
                        </callout>

                        <callout arearefs="scenegraph.add.all">
                           <para>Finally, the model and the light source nodes
                           are added as children of the root.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>

               <section>
                  <title>The <methodname>getScene()</methodname> Member
                  Function</title>

                  <para>The Performer Draw Manager will call the application's
                  <methodname>getScene()</methodname> method to get the root
                  of the scene graph. The implementation of this method can be
                  found in <filename>simplePfApp.h</filename>. The code is as
                  follows:</para>

                  <programlisting>pfGroup* simplePfApp::getScene ()
{
   return mRootNode;
}</programlisting>

                  <para>The simplicity of this method implementation is not
                  limited to the simple tutorial from which it is taken. All
                  Performer-based VR Juggler applications can take advantage
                  of this idiom where the root node is a member variable
                  returned in <methodname>getScene()</methodname>.</para>
               </section>
            </section>

            <section>
               <title>Other <classname>vrj::PfApp</classname> Methods</title>

               <para>Besides the two methods discussed so far, there are
               several other methods in <classname>vrj::PfApp</classname> that
               extend the basic <classname>vrj::App</classname> interface.
               Each is discussed in this section.</para>

               <section>
                  <title><methodname>preForkInit()</methodname></title>

                  <indexterm>
                     <primary>vrj::PfApp</primary>

                     <secondary>preForkInit() method</secondary>
                  </indexterm>

                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>

                        <type>void</type>

                        <methodname>preForkInit</methodname>

                        <void />
                     </methodsynopsis></para>

                  <para>This member function allows the user application to do
                  any processing that needs to happen before Performer forks
                  its processes but after <function>pfInit()</function> is
                  called. In other words, it is invoked after
                  <function>pfInit()</function> but before
                  <function>pfConfig()</function>.</para>
               </section>

               <section>
                  <title><methodname>appChanFunc()</methodname></title>

                  <indexterm>
                     <primary>vrj::PfApp</primary>

                     <secondary>appChanFunc() method</secondary>
                  </indexterm>

                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>

                        <type>void</type>

                        <methodname>appChanFunc</methodname>

                        <methodparam>
                           <type>pfChannel*</type>

                           <parameter>chan</parameter>
                        </methodparam>
                     </methodsynopsis></para>

                  <para>This method is called every frame in the application
                  process for each active channel. It is called immediately
                  before rendering (<function>pfFrame()</function>).</para>
               </section>

               <section>
                  <title><methodname>configPWin()</methodname></title>

                  <indexterm>
                     <primary>vrj::PfApp</primary>

                     <secondary>configPWin() method</secondary>
                  </indexterm>

                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>

                        <type>void</type>

                        <methodname>configPWin</methodname>

                        <methodparam>
                           <type>pfPipeWindow*</type>

                           <parameter>pWin</parameter>
                        </methodparam>
                     </methodsynopsis></para>

                  <para>This method is used to initialize a pipe window. It is
                  called as soon as the pipe window is opened.</para>
               </section>

               <section>
                  <title><methodname>getFrameBufferAttrs()</methodname></title>

                  <indexterm>
                     <primary>vrj::PfApp</primary>

                     <secondary>getFrameBufferAttrs() method</secondary>
                  </indexterm>

                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>

                        <type>std::vector&lt;int&gt;</type>

                        <methodname>getFrameBufferAttrs</methodname>

                        <void />
                     </methodsynopsis></para>

                  <para>This method returns the needed parameters for the
                  Performer frame buffer. Stereo, double buffering, depth
                  buffering, and RGBA are all requested by default.</para>
               </section>

               <section>
                  <title><methodname>drawChan()</methodname></title>

                  <indexterm>
                     <primary>vrj::PfApp</primary>

                     <secondary>drawChan() method</secondary>
                  </indexterm>

                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>

                        <void />

                        <methodname>drawChan</methodname>

                        <methodparam>
                           <type>pfChannel*</type>

                           <parameter>chan</parameter>
                        </methodparam>

                        <methodparam>
                           <type>void*</type>

                           <parameter>chandata</parameter>
                        </methodparam>
                     </methodsynopsis></para>

                  <para>This is the method called in the channel draw function
                  to do the actual rendering. For most programs, the default
                  behavior of this function is correct. It makes the following
                  calls:</para>

                  <programlisting>chan-&gt;clear();
pfDraw();</programlisting>

                  <para>Advanced users may want to override this behavior for
                  complex rendering effects such as overlays or multi-pass
                  rendering. (See the OpenGL Performer manual pages about
                  overriding the draw traversal function.) This function is
                  the draw traversal function but with the projections set
                  correctly for the given displays and eye. Prior to the
                  invocation of this method, <varname>chan</varname> is ready
                  to draw.</para>
               </section>

               <section>
                  <title><methodname>preDrawChan()</methodname></title>

                  <indexterm>
                     <primary>vrj::PfApp</primary>

                     <secondary>preDrawChan() method</secondary>
                  </indexterm>

                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>

                        <type>void</type>

                        <methodname>preDrawChan</methodname>

                        <methodparam>
                           <type>pfChannel*</type>

                           <parameter>chan</parameter>
                        </methodparam>

                        <methodparam>
                           <type>void*</type>

                           <parameter>chandata</parameter>
                        </methodparam>
                     </methodsynopsis></para>

                  <para>This is the function called by the
                  <emphasis>default</emphasis>
                  <methodname>drawChan()</methodname> member function before
                  clearing the channel and drawing the next frame
                  (<function>pfFrame()</function>).</para>
               </section>

               <section>
                  <title><methodname>postDrawChan()</methodname></title>

                  <indexterm>
                     <primary>vrj::PfApp</primary>

                     <secondary>postDrawChan() method</secondary>
                  </indexterm>

                  <para>Prototype: <methodsynopsis>
                        <modifier>public</modifier>

                        <void />

                        <methodname>postDrawChan</methodname>

                        <methodparam>
                           <type>pfChannel*</type>

                           <parameter>chan</parameter>
                        </methodparam>

                        <methodparam>
                           <type>void*</type>

                           <parameter>chandata</parameter>
                        </methodparam>
                     </methodsynopsis></para>

                  <para>This is the function called by the
                  <emphasis>default</emphasis>
                  <methodname>drawChan()</methodname> member function after
                  clearing the channel and drawing the next frame
                  (<function>pfFrame()</function>).</para>
               </section>
            </section>

            <section>
               <title><function>pfExit()</function>: To Call or Not to
               Call</title>

               <para>The Performer function <function>pfExit()</function>
               poses a problem for VR Juggler applications, and some
               background information will help ensure that readers understand
               the consequences of using <function>pfExit()</function> (or
               not). The main issue with <function>pfExit()</function> as it
               relates to VR Juggler is that calling
               <function>pfExit()</function> has the side effect of calling
               the system function <function>exit()</function>, which means
               that it should be (or has to be) the very last function call of
               a program. Prior to VR Juggler 2.0.1, the VR Juggler Performer
               Draw Manager was written to call <function>pfExit()</function>
               from within the method
               <methodname>vrj::PfDrawManager::closeAPI()</methodname>. Before
               VR Juggler 2.0 Beta 3, however, this method of the
               <classname>vrj::PfDrawManager</classname> interface had never
               been called—the result of the kernel shutdown process being
               incomplete. With the more complete kernel shutdown process in
               VR Juggler 2.0 Beta 3 and 2.0.0, authors of Performer-based VR
               Juggler applications saw their applications exiting prematurely
               after invoking the kernel shutdown. More specifically, any code
               that was intended to be executed after
               <methodname>vrj::PfDrawManager::closeAPI()</methodname> would
               not be executed. Such code includes
               <methodname>vrj::App::exit()</methodname> or an override
               thereof; an application object destructor; and anything else to
               be done after
               <methodname>vrj::Kernel::waitForKernelStop()</methodname>
               returned.</para>

               <para>To remedy this problem,
               <methodname>vrj::PfDrawManager::closeAPI()</methodname> in VR
               Juggler 2.0.1 and newer <emphasis>does not</emphasis> call
               <function>pfExit()</function>. Rather, it is the responsibility
               of the application programmer to call
               <function>pfExit()</function> if s/he so desires. Failing to
               call <function>pfExit()</function> could result in resource
               leaks from Performer, but calling <function>pfExit()</function>
               has been known to cause application crashes (irrespective of
               whether VR Juggler is used). In general, users should call
               <function>pfExit()</function> at the end of their
               <function>main()</function> function, but if doing so causes
               the application to crash on exit, then not calling
               <function>pfExit()</function> is probably the better
               option.</para>

               <sidebar>
                  <para>Resources that could be leaked by Performer if
                  <function>pfExit()</function> is not called would generally
                  fall under the heading of <quote>temporary files.</quote>
                  Resource leaks are not memory leaks since the operating
                  system will automatically deallocate any memory held by
                  Performer at the time of application exit. Since Performer
                  may allocate temporary files for its process locking and
                  shared memory arena, it would usually be best to ensure that
                  Performer cleans up after itself.</para>
               </sidebar>

               <para>The important thing to remember is that the application
               object destructor needs to be called
               <emphasis>before</emphasis> <function>pfExit()</function> is
               called. Refer to <xref linkend="example.using.pfExit.heap" />
               for an example of how <function>pfExit()</function> would be
               used with a VR Juggler application object allocated on the
               heap. For a stack-allocated application object, see <xref
               linkend="example.using.pfExit.stack" />.</para>

               <example id="example.using.pfExit.heap">
                  <title>Using <function>pfExit()</function> with a
                  Heap-Allocated Application Object</title>

                  <programlisting linenumbering="numbered">int main(int argc, char* argv[])
{
   vrj::Kernel* kernel = vrj::Kernel::instance();

   // Allocate the application object on the heap.  Its
   // destructor will be called manually before calling
   // pfExit().
   simplePfApp* application = new simplePfApp();

   // Load config files.
   for ( int i = 2; i &lt; argc; ++i )
   {
      kernel-&gt;loadConfigFile(argv[i]);
   }

   kernel-&gt;start();

   // Configure the application.
   application-&gt;setModel(argv[1]);
   kernel-&gt;setApplication(application);

   // Wait for the kernel to shut down.
   kernel-&gt;waitForKernelStop();

   // Final application clean-up.
   delete application;

   // Clean up Performer.
   // Calls system exit() function and therefore never returns.
   pfExit();

   return 0;
}</programlisting>
               </example>

               <example id="example.using.pfExit.stack">
                  <title>Using <function>pfExit()</function> with a
                  Stack-Allocated Application Object</title>

                  <programlisting linenumbering="numbered">int main(int argc, char* argv[])
{
   // Nested scope for stack-allocated data.
   {
      vrj::Kernel* kernel = vrj::Kernel::instance();

      // Load config files.
      for ( int i = 2; i &lt; argc; ++i )
      {
         kernel-&gt;loadConfigFile(argv[i]);
      }

      kernel-&gt;start();

      // Allocate the application object on the stack.  Its
      // destructor will be called automatically at the end
      // of this nested scope.
      simplePfApp application;

      // Configure the application and give it to the kernel.
      application.setModel(argv[1]);
      kernel-&gt;setApplication(&amp;application);

      // Wait for the kernel to shut down.
      kernel-&gt;waitForKernelStop();
   }

   // Clean up Performer.
   // Calls system exit() function and therefore never returns.
   pfExit();

   return 0;
}</programlisting>
               </example>
            </section>
         </section>

         <section id="section.opensg.apps">
            <title>OpenSG Applications</title>

            <indexterm zone="section.opensg.apps">
               <primary>application programming</primary>

               <secondary>OpenSG</secondary>
            </indexterm>

            <para>This section explains how to use the OpenSG scene graph in a
            VR Juggler application. OpenSG is an open source scene graph that
            is available at <ulink
            url="http://www.opensg.org/">www.opensg.org</ulink>.</para>

            <para>An OpenSG-based VR Juggler application must derive from
            <classname>vrj::OpenSGApp</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vrj::OpenSGApp</secondary>
               </indexterm>. The <classname>vrj::OpenSGApp</classname> class
            is derived from the <classname>vrj::GlApp</classname> presented
            previously, which in turn derives from
            <classname>vrj::App</classname>.
            <classname>vrj::OpenSGApp</classname> extends
            <classname>vrj::GlApp</classname> by adding methods that deal with
            scene graph initialization and access. <xref
            linkend="figure.class.vrj.OpenSGApp" /> shows how
            <classname>vrj::OpenSGApp</classname> fits into the class
            hierarchy of an OpenSG-based VR Juggler application.</para>

            <figure id="figure.class.vrj.OpenSGApp">
               <title><classname>vrj::OpenSGApp</classname> application
               class</title>

               <mediaobject>
                  <imageobject>
                     <imagedata align="center"
                                fileref="figures/userOpenSGApp_hierarchy.png"
                                format="PNG" />
                  </imageobject>
               </mediaobject>
            </figure>

            <para>The two main application methods for
            <classname>vrj::OpenSGApp</classname> VR Juggler applications are
            <methodname>initScene()</methodname> and
            <methodname>getScene()</methodname><indexterm>
                  <primary>vrj::OpenSGApp</primary>

                  <secondary>extensions to vrj::GlApp</secondary>
               </indexterm>. These are called by the OpenSG application class
            wrapper to initialize the application scene graph and to get the
            root of the scene graph respectively. They must be implemented by
            the application (they are pure virtual methods within
            <classname>vrj::OpenSGApp</classname>). The rest of this section
            gives a more detailed description of these methods and some sample
            code to illustrate the concepts presented.</para>

            <section>
               <title>Scene Graph Initialization:
               <methodname>vrj::OpenSGApp::initScene()</methodname></title>

               <indexterm>
                  <primary>vrj::OpenSGApp</primary>

                  <secondary>initScene() method</secondary>
               </indexterm>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>OpenSG</secondary>

                  <tertiary>scene graph initialization</tertiary>
               </indexterm>

               <para>In an application using OpenSG, the scene graph must be
               initialized before it can be used. The method
               <methodname>vrj::OpenSGApp::initScene()</methodname> is
               provided for that purpose. Within this method, the root of the
               application scene graph should be created, and any required
               models should be loaded and attached to the root in some way.
               The exact mechanisms for accomplishing this will vary depending
               on what the application will do.</para>

               <para>During the API initialization,
               <methodname>vrj::OpenSGApp::initScene()</methodname> is
               invoked. This happens after
               <methodname>OSG::osgInit()</methodname> has been called, so
               OpenSG should be fully initialized and ready to be used.</para>
            </section>

            <section>
               <title>Scene Graph Access:
               <methodname>vrj::OpenSGApp::getScene()</methodname></title>

               <indexterm>
                  <primary>vrj::OpenSGApp</primary>

                  <secondary>getScene() method</secondary>
               </indexterm>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>OpenSG</secondary>

                  <tertiary>scene graph access</tertiary>
               </indexterm>

               <para>In order for OpenSG to render the application scene
               graph, it must get access to the scene graph root. The method
               <methodname>vrj::OpenSGApp::getScene()</methodname> will be
               called by the OpenSG application class wrapper so that it can
               get access to the currently active scene graph whenever the
               wrapper needs to use it (for example when rendering or
               updating). Since the job of <methodname>getScene()</methodname>
               is straightforward, its implementation can be very simple. A
               typical implementation will have a single statement that
               returns a member variable that holds a pointer to the current
               scene graph root node.</para>

               <section>
                  <title>Possible Misuses</title>

                  <para>Do not do any CPU-heavy processing in this method.
                  Because this method is called frequently, it should only do
                  the minimum amount of processing necessary to return the
                  root scene graph node. In most cases this method should only
                  be one line of code. See the following code for an
                  example.</para>

                  <programlisting>virtual OSG::NodePtr getScene()
{
   return mSceneRoot;  // Return the root of the graph
}</programlisting>

                  <para>To update the scene graph, use either
                  <methodname>preFrame()</methodname>,
                  <methodname>intraFrame()</methodname>, or
                  <methodname>postFrame()</methodname>.</para>
               </section>
            </section>

            <section>
               <title>Tutorial: Loading a Model with OpenSG</title>

               <indexterm>
                  <primary>tutorial</primary>

                  <secondary>loading a model with OpenSG</secondary>
               </indexterm>

               <highlights>
                  <para>In this section, we present a tutorial that
                  demonstrates model loading with OpenSG. The tutorial
                  overview is as follows:</para>

                  <itemizedlist>
                     <listitem>
                        <para>Description: Simple OpenSG application that
                        loads a model.</para>
                     </listitem>

                     <listitem>
                        <para>Objectives: Understand how to load a model, add
                        it to a scene graph, and return the root to VR
                        Juggler.</para>
                     </listitem>

                     <listitem>
                        <para>Member functions:
                        <methodname>vrj::OpenSGApp::initScene()</methodname>,
                        <methodname>vrj::OpenSGApp::getScene()</methodname></para>
                     </listitem>

                     <listitem>
                        <para>Directory:
                        <filename>$VJ_BASE_DIR/share/vrjuggler/samples/OpenSG/simple/OpenSGNav</filename></para>
                     </listitem>

                     <listitem>
                        <para>Files: <filename>OpenSGNav.h</filename>,
                        <filename>OpenSGNav.cpp</filename></para>
                     </listitem>
                  </itemizedlist>
               </highlights>

               <section>
                  <title>Class Declaration</title>

                  <para>The following application class is called
                  <classname>OpenSGNav</classname>. It is derived from
                  <classname>vrj::OpenSGApp</classname> and has custom
                  <methodname>initScene()</methodname>,
                  <methodname>getScene()</methodname>,
                  <methodname>init()</methodname>,
                  <methodname>contextInit()</methodname>, and
                  <methodname>preFrame()</methodname> methods declared. Refer
                  to <filename>OpenSGNav.h</filename> for the implementation
                  of <methodname>setModelFileName()</methodname>.</para>

                  <programlisting linenumbering="numbered">class OpenSGNav : public vrj::OpenSGApp
{
public:
   OpenSGNav(vrj::Kernel* kern);
   virtual ~OpenSGNav();

   virtual void init();
   virtual void contextInit();
   virtual void preFrame();

   virtual void initScene();
   virtual OSG::NodePtr getScene();

   void setModelFileName(std::string filename);

private:
   void initGLState();

private:
   std::string mFileToLoad;

   OSG::NodePtr        mSceneRoot;
   OSG::TransformPtr   mSceneTransform;
   OSG::NodePtr        mModelRoot;

   OSG::NodePtr  mLightNode;
   OSG::NodePtr  mLightBeacon;

public:
   gadget::PositionInterface  mWandPos;
   gadget::DigitalInterface   mButton0;
   gadget::DigitalInterface   mButton1;
   gadget::DigitalInterface   mButton2;
   float  velocity;
};
</programlisting>
               </section>

               <section>
                  <title>The <methodname>initScene()</methodname> Member
                  Function</title>

                  <para>The implementation of
                  <methodname>initScene()</methodname> is in
                  <filename>OpenSGNav.cpp</filename>. Within this method, we
                  create the scene graph root node, the lighting node, and
                  load a user-specified model. The implementation
                  follows:</para>

                  <programlisting linenumbering="numbered">void OpenSGNav::initScene()
{
   // Load the model to use
   if (mFileToLoad == std::string("none"))                      <co
                        id="OpenSGNav.load.model.co"
                        linkends="OpenSGNav.load.model.desc" />
   {
      mModelRoot = OSG::makeTorus(.5, 2, 16, 16);      
   }
   else
   {
      mModelRoot =
         OSG::SceneFileHandler::the().read(mFileToLoad.c_str());
   }

   // --- Light setup --- //
   // - Add directional light for scene
   // - Create a beacon for it and connect to that beacon
   mLightNode   = OSG::Node::create();                          <co
                        id="OpenSGNav.create.light.co"
                        linkends="OpenSGNav.load.model.desc" />
   mLightBeacon = OSG::Node::create();
   OSG::DirectionalLightPtr light_core =
      OSG::DirectionalLight::create();
   OSG::TransformPtr light_beacon_core =
      OSG::Transform::create();

   // Setup light beacon
   OSG::Matrix light_pos;
   light_pos.setTransform(OSG::Vec3f(2.0f, 5.0f, 4.0f));

   OSG::beginEditCP(light_beacon_core, OSG::Transform::MatrixFieldMask);
      light_beacon_core-&gt;setMatrix(light_pos);
   OSG::endEditCP(light_beacon_core, OSG::Transform::MatrixFieldMask);

   OSG::beginEditCP(mLightBeacon);
      mLightBeacon-&gt;setCore(light_beacon_core);
   OSG::endEditCP(mLightBeacon);

   // Setup light node
   OSG::addRefCP(mLightNode);
   OSG::beginEditCP(mLightNode);
      mLightNode-&gt;setCore(light_core);
      mLightNode-&gt;addChild(mLightBeacon);
   OSG::endEditCP(mLightNode);

   OSG::beginEditCP(light_core);
      light_core-&gt;setAmbient   (0.9, 0.8, 0.8, 1);
      light_core-&gt;setDiffuse   (0.6, 0.6, 0.6, 1);
      light_core-&gt;setSpecular  (1, 1, 1, 1);
      light_core-&gt;setDirection (0, 0, 1);
      light_core-&gt;setBeacon    (mLightNode);
   OSG::endEditCP(light_core);

   // --- Setup Scene -- //
   // add the loaded scene to the light node, so that it is lit
   // by the light
   OSG::addRefCP(mModelRoot);
   OSG::beginEditCP(mLightNode);                                <co
                        id="OpenSGNav.model.add.co"
                        linkends="OpenSGNav.model.add.desc" />
      mLightNode-&gt;addChild(mModelRoot);
   OSG::endEditCP(mLightNode);

   // create the root part of the scene
   mSceneRoot = OSG::Node::create();                            <co
                        id="OpenSGNav.scene.root.create.co"
                        linkends="OpenSGNav.scene.root.create.desc" />
   mSceneTransform = OSG::Transform::create();

   // Set the root node
   OSG::beginEditCP(mSceneRoot);
      mSceneRoot-&gt;setCore(mSceneTransform);
      mSceneRoot-&gt;addChild(mLightNode);                         <co
                        id="OpenSGNav.add.light.co"
                        linkends="OpenSGNav.add.light.desc" />
   OSG::endEditCP(mSceneRoot);
}</programlisting>

                  <calloutlist>
                     <callout arearefs="OpenSGNav.load.model.co"
                              id="OpenSGNav.load.model.desc">
                        <para>We begin by loading the file set in
                        <methodname>OpenSGNav::setModelFileName()</methodname>.
                        If no file name was set, we default to using a simple
                        torus model. The model object is
                        <varname>mModelRoot</varname>.</para>
                     </callout>

                     <callout arearefs="OpenSGNav.create.light.co"
                              id="OpenSGNav.create.light.desc">
                        <para>Next, we create a node for the light, which we
                        define as a beacon light.</para>
                     </callout>

                     <callout arearefs="OpenSGNav.model.add.co"
                              id="OpenSGNav.model.add.desc">
                        <para>The model is added under the light in the scene
                        graph so that it gets lit.</para>
                     </callout>

                     <callout arearefs="OpenSGNav.scene.root.create.co"
                              id="OpenSGNav.scene.root.create.desc">
                        <para>Then, the root note for the scene graph is
                        created. This is what will be returned to OpenSG for
                        rendering by
                        <methodname>OpenSGNav::getScene()</methodname>.</para>
                     </callout>

                     <callout arearefs="OpenSGNav.add.light.co"
                              id="OpenSGNav.add.light.desc">
                        <para>Finally, we add the light node as a child of the
                        scene root. Remember that the light node already has
                        the loaded model as a child.</para>
                     </callout>
                  </calloutlist>
               </section>

               <section>
                  <title>The <methodname>getScene()</methodname> Member
                  Function</title>

                  <para>The method
                  <methodname>vrj::OpenSGApp::draw()</methodname> will call
                  the application's <methodname>getScene()</methodname> method
                  to get the root of the scene graph. The implementation of
                  this method can be found in
                  <filename>OpenSGNav.h</filename>. The code is as
                  follows:</para>

                  <programlisting>OSG::NodePtr OpenSGNav::getScene()
{
   return mRootNode;
}</programlisting>

                  <para>The simplicity of this method implementation is not
                  limited to the simple tutorial from which it is taken. All
                  OpenSG-based VR Juggler applications can take advantage of
                  this idiom where the root node is a member variable returned
                  in <methodname>getScene()</methodname>.</para>
               </section>
            </section>
         </section>

         <section id="section.osg.apps">
            <title>Open Scene Graph Applications</title>

            <indexterm zone="section.osg.apps">
               <primary>application programming</primary>

               <secondary>Open Scene Graph (OSG)</secondary>
            </indexterm>

            <para>This section explains how to use the Open Scene Graph (OSG)
            in a VR Juggler application. OSG is an open source scene graph
            that is available at <ulink
            url="http://www.opensg.org/">www.openscenegraph.org</ulink>.</para>

            <para>An OSG-based VR Juggler application must derive from
            <classname>vrj::OsgApp</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>vrj::OsgApp</secondary>
               </indexterm>. The <classname>vrj::OsgApp</classname> class is
            derived from the <classname>vrj::GlApp</classname> presented
            previously, which in turn derives from
            <classname>vrj::App</classname>.
            <classname>vrj::OsgApp</classname> extends
            <classname>vrj::GlApp</classname> by adding methods that deal with
            scene graph initialization and access. <xref
            linkend="figure.class.vrj.OsgApp" /> shows how
            <classname>vrj::OsgApp</classname> fits into the class hierarchy
            of an OSG-based VR Juggler application.</para>

            <figure id="figure.class.vrj.OsgApp">
               <title><classname>vrj::OsgApp</classname> application
               class</title>

               <mediaobject>
                  <imageobject>
                     <imagedata align="center"
                                fileref="figures/userOsgApp_hierarchy.png"
                                format="PNG" />
                  </imageobject>
               </mediaobject>
            </figure>

            <para>The two main application methods for
            <classname>vrj::OsgApp</classname> VR Juggler applications are
            <methodname>initScene()</methodname> and
            <methodname>getScene()</methodname><indexterm>
                  <primary>vrj::OsgApp</primary>

                  <secondary>extensions to vrj::GlApp</secondary>
               </indexterm>. These are called by the OSG application class
            wrapper to initialize the application scene graph and to get the
            root of the scene graph respectively. They must be implemented by
            the application (they are pure virtual methods within
            <classname>vrj::OsgApp</classname>). The rest of this section
            gives a more detailed description of these methods and some sample
            code to illustrate the concepts presented.</para>

            <section>
               <title>Scene Graph Initialization:
               <methodname>vrj::OsgApp::initScene()</methodname></title>

               <indexterm>
                  <primary>vrj::OsgApp</primary>

                  <secondary>initScene() method</secondary>
               </indexterm>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>Open Scene Graph</secondary>

                  <tertiary>scene graph initialization</tertiary>
               </indexterm>

               <para>In an application using OSG, the scene graph must be
               initialized before it can be used. The method
               <methodname>vrj::OsgApp::initScene()</methodname> is provided
               for that purpose. Within this method, the root of the
               application scene graph should be created, and any required
               models should be loaded and attached to the root in some way.
               The exact mechanisms for accomplishing this will vary depending
               on what the application will do.</para>

               <important>
                  <para>During the application initialization,
                  <methodname>vrj::OsgApp::initScene()</methodname> is
                  invoked. This method is invoked in
                  <methodname>vrj::OsgApp::init()</methodname>. Therefore,
                  user application objects that derive from
                  <classname>vrj::OsgApp</classname> should be sure to invoke
                  <methodname>vrj::OsgApp::init()</methodname> in their
                  overriding <methodname>init()</methodname> method, or the
                  contents of the overriding <methodname>init()</methodname>
                  method should be moved into the implementation of
                  <methodname>initScene()</methodname>.</para>
               </important>
            </section>

            <section>
               <title>Scene Graph Access:
               <methodname>vrj::OsgApp::getScene()</methodname></title>

               <indexterm>
                  <primary>vrj::OsgApp</primary>

                  <secondary>getScene() method</secondary>
               </indexterm>

               <indexterm>
                  <primary>application programming</primary>

                  <secondary>Open Scene Graph</secondary>

                  <tertiary>scene graph access</tertiary>
               </indexterm>

               <para>In order for OSG to render the application scene graph,
               it must get access to the scene graph root. The method
               <methodname>vrj::OsgApp::getScene()</methodname> will be called
               by the OSG application class wrapper so that it can get access
               to the currently active scene graph whenever the wrapper needs
               to use it (for example when rendering or updating). Since the
               job of <methodname>getScene()</methodname> is straightforward,
               its implementation can be very simple. A typical implementation
               will have a single statement that returns a member variable
               that holds a pointer to the current scene graph root
               node.</para>

               <section>
                  <title>Possible Misuses</title>

                  <para>Do not do any CPU-heavy processing in this method.
                  Because it is called frequently, it should only do the
                  minimum amount of processing necessary to return the root
                  scene graph node. In most cases, this method should only be
                  one line of code. See the following code for an
                  example.</para>

                  <programlisting>virtual osg::Group* getScene()
{
   return mSceneRoot;  // Return the root of the graph
}</programlisting>

                  <para>To update the scene graph, use either
                  <methodname>preFrame()</methodname>,
                  <methodname>intraFrame()</methodname>, or
                  <methodname>postFrame()</methodname>.</para>
               </section>
            </section>

            <section>
               <title>Tutorial: Loading a Model with Open Scene Graph</title>

               <indexterm>
                  <primary>tutorial</primary>

                  <secondary>loading a model with Open Scene Graph</secondary>
               </indexterm>

               <highlights>
                  <para>In this section, we present a tutorial that
                  demonstrates model loading and scene navigation using Open
                  Scene Graph. The tutorial overview is as follows:</para>

                  <itemizedlist>
                     <listitem>
                        <para>Description: Simple OSG application that loads a
                        model and allows navigation.</para>
                     </listitem>

                     <listitem>
                        <para>Objectives: Understand how to load a model, add
                        it to a scene graph, and return the root to VR
                        Juggler.</para>
                     </listitem>

                     <listitem>
                        <para>Member functions:
                        <methodname>vrj::OsgApp::initScene()</methodname>,
                        <methodname>vrj::OsgApp::getScene()</methodname></para>
                     </listitem>

                     <listitem>
                        <para>Directory:
                        <filename>$VJ_BASE_DIR/share/vrjuggler/samples/OSG/simple/osgNav</filename></para>
                     </listitem>

                     <listitem>
                        <para>Files: <filename>OsgNav.h</filename>,
                        <filename>OsgNav.cpp</filename></para>
                     </listitem>
                  </itemizedlist>
               </highlights>

               <section>
                  <title>Class Declaration</title>

                  <para>The following application class is called
                  <classname>osgNav</classname>. It is derived from
                  <classname>vrj::OsgApp</classname> and has custom
                  <methodname>initScene()</methodname>,
                  <methodname>getScene()</methodname>,
                  <methodname>configSceneView()</methodname>,
                  <methodname>preFrame()</methodname>, and
                  <methodname>latePreFrame()</methodname> methods declared.
                  Refer to <filename>OsgNav.h</filename> for the
                  implementation of
                  <methodname>setModelFileName()</methodname>. Note that we
                  will ignore the code for remote navigation via a Tweek-based
                  GUI in this description.</para>

                  <programlisting linenumbering="numbered">class OsgNav : public vrj::OpenSGApp
{
public:
   OsgNav(vrj::Kernel* kern, int&amp; argc, char** argv);
   virtual ~OsgNav();

   virtual void configSceneView();

   virtual void initScene();
   void myInit();
   virtual osg::Group* getScene();

   virtual void preFrame();
   virtual void latePreFrame();

   void setModelFileName(std::string filename);

private:
   osg::Group*             mRootNode;
   osg::Group*             mNoNav;
   osg::MatrixTransform*   mNavTrans;
   osg::MatrixTransform*   mModelTrans;
   osg::Node*              mModel;

   OsgNavigator  mNavigator;

   std::string   mFileToLoad;

   vpr::Interval mLastPreFrameTime;

public:
   gadget::PositionInterface  mWand;
   gadget::PositionInterface  mHead;
   gadget::DigitalInterface   mButton0;
   gadget::DigitalInterface   mButton1;
   gadget::DigitalInterface   mButton2;
   gadget::DigitalInterface   mButton3;
   gadget::DigitalInterface   mButton4;
   gadget::DigitalInterface   mButton5;
};
</programlisting>
               </section>

               <section>
                  <title>The <methodname>initScene()</methodname> Member
                  Function</title>

                  <para>The implementation of
                  <methodname>initScene()</methodname> is in
                  <filename>OsgNav.cpp</filename>. This method looks very
                  similar to the usual implementation of init() in other
                  application object examples. The important thing to note is
                  the last line of the method body where myInit() is
                  invoked.</para>

                  <programlisting linenumbering="numbered">void OsgNav::initScene()
{
   mWand.init("VJWand");
   mHead.init("VJHead");
   mButton0.init("VJButton0");
   mButton1.init("VJButton1");
   mButton2.init("VJButton2");
   mButton3.init("VJButton3");
   mButton4.init("VJButton4");
   mButton5.init("VJButton5");

   myInit();
}</programlisting>

                  <para>Within the <methodname>myInit()</methodname> method,
                  we see the real work for initializing the scene. In this
                  method, we create the scene graph root node, the lighting
                  node, and load a user-specified model. The implementation,
                  found in <filename>OsgNav.cpp</filename>, follows:</para>

                  <programlisting>void OsgNav::myInit()
{
   //
   //          /-- mNoNav
   // mRootNode
   //         \-- mNavTrans -- mModelTrans -- mModel

   //The top level nodes of the tree
   mRootNode = new osg::Group();                                 <co
                        id="OsgNav.create.graph.co"
                        linkends="OsgNav.create.graph.desc" />
   mNoNav    = new osg::Group();
   mNavTrans = new osg::MatrixTransform();

   mNavigator.init();

   mRootNode-&gt;addChild(mNoNav);
   mRootNode-&gt;addChild(mNavTrans);

   //Load the model
   std::cout &lt;&lt; "Attempting to load file: "
             &lt;&lt; mFileToLoad &lt;&lt; "... " &lt;&lt; std::flush;
   mModel = osgDB::readNodeFile(mFileToLoad);                    <co
                        id="OsgNav.load.model.co"
                        linkends="OsgNav.load.model.desc" />
   std::cout &lt;&lt; "done." &lt;&lt; std::endl;

   // Transform node for the model
   mModelTrans  = new osg::MatrixTransform();                    <co
                        id="OsgNav.model.xform.co"
                        linkends="OsgNav.model.xform.desc" />
   //This can be used if the model orientation needs to change
   mModelTrans-&gt;preMult(
      osg::Matrix::rotate(gmtl::Math::deg2Rad(-90.0f),
                          1.0f, 0.0f, 0.0f)
   );

   if(NULL == mModel)                                            <co
                        id="OsgNav.test.model.co"
                        linkends="OsgNav.attach.model.desc" />
   {
      std::cout &lt;&lt; "ERROR: Could not load file: "
                &lt;&lt; mFileToLoad &lt;&lt; std::endl;
   }
   else
   {
      // Add model to the transform
      mModelTrans-&gt;addChild(mModel);                             <co
                        id="OsgNav.attach.model.co"
                        linkends="OsgNav.attach.model.desc" />
   }
   
   // Add the transform to the tree
   mNavTrans-&gt;addChild(mModelTrans);                             <co
                        id="OsgNav.attach.xform.co"
                        linkends="OsgNav.attach.xform.desc" />

   // run optimization over the scene graph
   osgUtil::Optimizer optimizer;
   optimizer.optimize(mRootNode);                                <co
                        id="OsgNav.optimize.co"
                        linkends="OsgNav.optimize.desc" />
}</programlisting>

                  <calloutlist>
                     <callout arearefs="OsgNav.create.graph.co"
                              id="OsgNav.create.graph.desc">
                        <para>We begin by creating the nodes that will make up
                        the application scene graph. Note that this scene
                        graph will contain two branches: one for nodes that
                        will be affected by user navigation and one for nodes
                        that will not.</para>
                     </callout>

                     <callout arearefs="OsgNav.load.model.co"
                              id="OsgNav.load.model.desc">
                        <para>Next, we attempt to load the model provided
                        through an earlier call to
                        <methodname>setModelFileName()</methodname>. In this
                        application, the user must identify the model to load
                        on the command line when running the application. The
                        code for handling this can be found in the
                        <function>main()</function> function.</para>
                     </callout>

                     <callout arearefs="OsgNav.model.xform.co"
                              id="OsgNav.model.xform.desc">
                        <para>The model will be attached to the scene graph
                        under a transform node, so we must create that node
                        next.</para>
                     </callout>

                     <callout arearefs="OsgNav.test.model.co OsgNav.attach.model.co"
                              id="OsgNav.attach.model.desc">
                        <para>If the model was loaded successfully
                        (<varname>mModel</varname> is not
                        <literal>NULL</literal>), then we attach it to the
                        scene graph under the freshly created model transform
                        node.</para>
                     </callout>

                     <callout arearefs="OsgNav.attach.xform.co"
                              id="OsgNav.attach.xform.desc">
                        <para>Whether the named model was loaded successfully
                        or not, we attach the model transform to the scene
                        graph under the navigation-enabled branch. When the
                        model is loaded successfully, this allows the user to
                        fly around the model.</para>
                     </callout>

                     <callout arearefs="OsgNav.optimize.co"
                              id="OsgNav.optimize.desc">
                        <para>Finally, we use
                        <classname>osgUtil::Optimizer</classname> to optimize
                        the scene graph that we have built up.</para>
                     </callout>
                  </calloutlist>
               </section>

               <section>
                  <title>The <methodname>getScene()</methodname> Member
                  Function</title>

                  <para>The method
                  <methodname>vrj::OsgApp::draw()</methodname> will call the
                  application's <methodname>getScene()</methodname> method to
                  get the root of the scene graph. The implementation of this
                  method can be found in <filename>OsgNav.h</filename>. The
                  code is as follows:</para>

                  <programlisting>osg::Group* OsgNav::getScene()
{
   return mRootNode;
}</programlisting>

                  <para>The simplicity of this method implementation is not
                  limited to the simple tutorial from which it is taken. All
                  OSG-based VR Juggler applications can take advantage of this
                  idiom where the root node is a member variable returned in
                  <methodname>getScene()</methodname>.</para>
               </section>
            </section>
         </section>

         <section id="section.vtk.apps">
            <title>VTK Applications</title>

            <indexterm zone="section.vtk.apps">
               <primary>application programming</primary>

               <secondary>VTK</secondary>
            </indexterm>

            <para></para>
         </section>
      </chapter>

      <chapter id="chapter.writing.apps.misc">
         <title>Additional Application Programming Topics</title>

         <para>We now present topics that will be of interest to VR Juggler
         programmers in general but are not as low-level as those topics
         described in <xref linkend="chapter.writing.apps" />. Furthermore,
         understanding the use of graphics APIs within a VR Juggler
         application will help with understanding how these additional
         features can be used effectively. As such, it is expected that
         readers of this chapter will have already read and understood the
         topics presented in the previous chapters of this part of the
         book.</para>

         <section id="section.cluster.apps">
            <title>Cluster Application Programming</title>

            <indexterm zone="section.cluster.apps">
               <primary>application programming</primary>

               <secondary>clustering</secondary>
            </indexterm>

            <para>Traditionally, multi-screen immersive systems have relied
            upon dedicated high-end shared memory graphics workstations or
            supercomputers to generate interactive virtual environments. These
            multi-screen immersive systems typically require one or two video
            outputs for each screen and simultaneously utilize several
            interaction devices. In recent years this trend of almost
            exclusively using high-end systems has started to change as
            commodity hardware has become a viable alternative to high-end
            systems.</para>

            <para>Current technologies have empowered PC-based systems with
            high-quality graphics hardware, significant amount of memory and
            computing power, as well as support for many external devices.
            Their application to virtual reality applications is motivated by
            the dramatic cost decrease they represent and by the wide range of
            options and availability. To drive a multi-screen immersive
            environment we need multiple commodity systems working as a single
            unit, that is, a tightly synchronized <indexterm>
                  <primary>cluster</primary>
               </indexterm>cluster. The challenge is that, although the base
            technology is standard off-the-shelf technology, there is a lack
            of software for weaving together the cluster into a platform that
            supports the creation of virtual environments. Furthermore, there
            is an even greater lack of software that can allow existing
            virtual environment designed for high-end system to transparently
            migrate to a cluster.</para>

            <para>In this section, we review the clustering capabilities of VR
            Juggler 2.0. The current implementation of clustering in VR
            Juggler is the result of the hard work of many people and of
            several design and implementation iterations. It is the most
            important new feature in VR Juggler 2.0, and it is also the most
            complex new feature internally. At the level of the application
            object, the clustering infrastructure is largely hidden. Those
            pieces that are exposed have been designed to be easy to use and
            to work in non-cluster configurations. This aids in application
            portability between VR system configurations.</para>

            <section>
               <title>Shared Input Data</title>

               <para>One approach to implementing clustering for interactive
               graphics applications is to share all data received from input
               devices. This is based on an assumption that the interaction
               with the computer graphics will occur through input devices
               such as 6DOF trackers, pointing devices, etc. Using this
               approach, a distinct copy of the VR application is run on each
               cluster node, but they all see the same input data. Since
               changes to the scene are based on information from the input
               devices, all the nodes will make the same state changes each
               frame and therefore remain synchronized.</para>

               <para>This capability is implemented through the Gadgeteer
               Remote Input Manager and the <literal>RIMPlugin</literal> used
               by the Cluster Manager. The basic goal of these components is
               to provide a distributed shared memory system for VR input
               device data. Through shared input data, applications can
               migrate transparently between shared memory VR systems and PC
               cluster VR systems.</para>

               <para>Shared input data is the easiest VR Juggler clustering
               feature that can be utilized by application object programmers.
               In simple cases, nothing about an application will have to
               change to take advantage of shared input data because the
               details are hidden within the VR Juggler configuration. The
               Cluster Manager simply needs to be configured to load the
               <literal>RIMPlugin</literal> and the Start Barrier Plug-in
               (<literal>StartBarrierPlugin</literal>) to enable applications
               to take advantage of shared input data.</para>
            </section>

            <section id="section.cluster.UserData">
               <title>Application-Specific Shared Data</title>

               <para>When input data sharing is not sufficient to enable a VR
               Juggler application to run on a cluster, the next option is to
               use application-specific shared data. Using this option, VR
               application developers can easily exchange any type of data
               across a cluster of machines. For example, we might have a GUI
               running on a hand-held device that interacts with the VR
               application to control it. We cannot expect this GUI to connect
               to all nodes in the cluster. Instead, the GUI connects to a
               single node that accepts the commands from the GUI and then
               relays them to the rest of the cluster nodes using
               application-specific shared data.</para>

               <para>Application-specific shared data is implemented through
               the generic (templated) container type
               <classname>cluster::UserData&lt;T&gt;</classname><indexterm>
                     <primary>cluster::UserData&lt;T&gt;</primary>
                  </indexterm><indexterm>
                     <primary>classes</primary>

                     <secondary>cluster::UserData&lt;T&gt;</secondary>
                  </indexterm> and the Application Data Manager plug-in
               (<literal>ApplicationDataManager</literal> in the Cluster
               Manager config element plug-in list). As is typically the case
               with generic containers, any sort of data can be stored and
               therefore shared. The only caveat is that the contained type
               must have the following two methods:</para>

               <orderedlist>
                  <listitem>
                     <para><methodsynopsis>
                           <type>vpr::ReturnStatus</type>

                           <methodname>writeObject</methodname>

                           <methodparam>
                              <type>vpr::ObjectWriter*</type>

                              <parameter>writer</parameter>
                           </methodparam>
                        </methodsynopsis></para>
                  </listitem>

                  <listitem>
                     <para><methodsynopsis>
                           <type>vpr::ReturnStatus</type>

                           <methodname>readObject</methodname>

                           <methodparam>
                              <type>vpr::ObjectReader*</type>

                              <parameter>reader</parameter>
                           </methodparam>
                        </methodsynopsis></para>
                  </listitem>
               </orderedlist>

               <para>Respectively, these two methods are used for serializing
               and de-serializing shared data types. The simplest way to
               achieve this is to create a data structure that is a subclass
               of the abstract type
               <classname>vpr::SerializableObject</classname><indexterm>
                     <primary>vpr::SerializableObject</primary>
                  </indexterm><indexterm>
                     <primary>classes</primary>

                     <secondary>vpr::SerializableObject</secondary>
                  </indexterm> and overriding its pure virtual
               <methodname>writeObject()</methodname> and
               <methodname>readObject()</methodname> methods.</para>

               <para>Deriving from
               <classname>vpr::SerializableObject</classname> is not viable in
               all cases, however. If the data that must be shared is of a
               type defined in a third-party library, it cannot be modified to
               derive from <classname>vpr::SerializableObject</classname>. In
               that case, the type
               <classname>vpr::SerializableObjectMixin&lt;T&gt;</classname><indexterm>
                     <primary>vpr::SerializableObjectMixin&lt;T&gt;</primary>
                  </indexterm><indexterm>
                     <primary>classes</primary>

                     <secondary>vpr::SerializableObjectMixin&lt;T&gt;</secondary>
                  </indexterm> can be used. The methods
               <classname>vpr::SerializableObjectMixin&lt;T&gt;::writeObject()</classname>
               and
               <classname>vpr::SerializableObjectMixin&lt;T&gt;::readObject()</classname>
               must be specialized for the desired type <type>T</type>.</para>

               <para>In either case, the end result is a means to serialize
               the data to be shared across the cluster, and application
               object programmers will implement methods named
               <methodname>writeObject()</methodname> and
               <methodname>readObject()</methodname>. When
               <methodname>writeObject()</methodname> is invoked, it is passed
               a pointer to a
               <classname>vpr::ObjectWriter</classname><indexterm>
                     <primary>vpr::ObjectWriter</primary>
                  </indexterm><indexterm>
                     <primary>classes</primary>

                     <secondary>vpr::ObjectWriter</secondary>
                  </indexterm> object. An object writer is a simple wrapper
               around an expandable block of memory. Each write operation
               appends some number of bytes to the memory block based on the
               size of the data written. The type
               <classname>vpr::ObjectWriter</classname> provides methods for
               writing all the basic C++ data types (<type>int</type>,
               <type>float</type>, <type>bool</type>, <type>char</type>,
               etc.), though they are named based on the cross-platform type
               identifiers provided by the VR Juggler Portable Runtime
               (<type>vpr::Int32</type>, <type>vpr::Uint8</type>, etc.). Byte
               ordering (endian) issues are handled internally by the object
               writer. The implementation of
               <methodname>writeObject()</methodname> for any shared data type
               simply copies the data members of the shared data structure
               into the object writer.</para>

               <para>Inversely, the implementation of
               <methodname>readObject()</methodname> reads data from an object
               reader (an instance of
               <classname>vpr::ObjectReader</classname><indexterm>
                     <primary>vpr::ObjectReader</primary>
                  </indexterm><indexterm>
                     <primary>classes</primary>

                     <secondary>vpr::ObjectReader</secondary>
                  </indexterm>) into the local copy of the data structure. The
               object reader contains a fixed-size block of memory and a
               pointer to the current location in that memory block. Each read
               operation moves the pointer some number of bytes in the memory
               block based on the size of the data read.</para>

               <important>
                  <para>Due to the symmetric nature of
                  <methodname>writeObject()</methodname> and
                  <methodname>readObject()</methodname>, the reading and
                  writing of data must occur in the same order. That is, the
                  implementation of <methodname>writeObject()</methodname>
                  will write the shared data in some order, and
                  <methodname>readObject()</methodname> must read the shared
                  data back out in the same order.</para>
               </important>

               <para>We now present two examples of using the serializable
               object concept. The first demonstrates the case when a new data
               structure can be created; the second is the case when a
               third-party type must be made serializable. When we make a new
               data structure, it is quite easy to enable serialization.
               Consider the basic type shown in <xref
               linkend="example.declare.serializable.type" />. It derives from
               <classname>vpr::SerializableObject</classname> and overrides
               <methodname>writeObject()</methodname> and
               <methodname>readObject()</methodname> just as it must. It has
               three data members of different types that define the state of
               an instance of our type. The serialization and de-serialization
               implementation, which is quite straightforward, is shown in
               <xref linkend="example.implement.serialization" />.</para>

               <example id="example.declare.serializable.type">
                  <title>Declaration of a Serializable Type</title>

                  <programlisting>#include &lt;vpr/IO/SerializableObject.h&gt;

class MyType : public vpr::SerializableObject
{
public:
   vpr::ReturnStatus writeObject(vpr::ObjectWriter* writer);
   vpr::ReturnStatus readObject(vpr::ObjectReader* reader);
   // Other public methods ...

private:
   unsigned int mIntData;
   char         mByteData;
   float        mFloatData;
};</programlisting>
               </example>

               <example id="example.implement.serialization">
                  <title>Serializing an Application-Specific Type</title>

                  <programlisting>vpr::ReturnStatus MyType::writeObject(vpr::ObjectWriter* writer)
{
   writer-&gt;writeUint32(mIntData);
   writer-&gt;writeInt8(mByteData);
   writer-&gt;writeFloat(mFloatData);
   return vpr::ReturnStatus();
}

vpr::ReturnStatus MyType::readObject(vpr::ObjectReader* reader)
{
   mIntData   = reader-&gt;readUint32();
   mByteData  = reader-&gt;readInt8();
   mFloatData = reader-&gt;readFloat();
   return vpr::ReturnStatus();
}</programlisting>
               </example>

               <para>Now we consider the case when we need to serialize a
               third-party type. First, let us assume that we have a type,
               called <classname>SomeType</classname>, defined in a header
               file from a third-party C++ library. This is shown in <xref
               linkend="example.type.SomeData" />. The type has three accessor
               methods for reading its data and three for writing. We can then
               specialize the methods of
               <classname>vpr::SerializableObjectMixin&lt;T&gt;</classname> as
               shown in <xref linkend="example.serialize.SomeData" />.</para>

               <example id="example.type.SomeData">
                  <title>Sample Third-Party Type</title>

                  <programlisting>class SomeType
{
public:
   unsigned int getIntData();
   void setIntData(unsigned int v);

   char getByteData();
   void setByteData(char v);

   float getFloatDat();
   void setFloatData(float v);

private:
   // Private data ...
};</programlisting>
               </example>

               <example id="example.serialize.SomeData">
                  <title>Serializing a Third-Party Type Using
                  <classname>vpr::SerializableObjectMixin&lt;T&gt;</classname></title>

                  <programlisting>#include &lt;vpr/IO/SerializableObject.h&gt;

template&lt;&gt;
vpr::ReturnStatus
vpr::SerializableObjectMixin&lt;SomeType&gt;::
   writeObject(vpr::ObjectWriter* writer)
{
   writer-&gt;writeUint32(getIntData());
   writer-&gt;writeInt8(getByteData());
   write-&gt;writeFloat(getFloatData());
   return vpr::ReturnStatus();
}

template&lt;&gt;
vpr::ReturnStatus
vpr::SerializableObjectMixin&lt;SomeType&gt;::
   readObject(vpr::ObjectReader* reader)
{
   setIntData(reader-&gt;readUint32());
   setByteData(reader-&gt;readInt8());
   setFloatData(reader-&gt;readFloat());
   return vpr::ReturnStatus();
}</programlisting>
               </example>

               <para>The magic of
               <classname>vpr::SerializableObjectMixin&lt;T&gt;</classname>
               allows the specialized methods to behave as member functions in
               <classname>SomeType</classname>. This means that the
               specialized members have easy access to all public and
               protected members of <classname>SomeType</classname>.</para>

               <para>Now that we have data serialization out of the way, we
               can turn our attention to the use of
               <classname>cluster::UserData&lt;T&gt;</classname>, the special
               type that automates application-specific data sharing. For each
               type of shared data, the application object will have at least
               one instance of
               <classname>cluster::UserData&lt;T&gt;</classname>. Example
               instantiations of
               <classname>cluster::UserData&lt;T&gt;</classname> are shown in
               <xref linkend="example.using.cluster.UserData" />.</para>

               <example id="example.using.cluster.UserData">
                  <title>Declaring Instances of
                  <classname>cluster::UserData&lt;T&gt;</classname></title>

                  <programlisting>#include &lt;vrj/Draw/OGL/GlApp.h&gt;
#include &lt;plugins/ApplicationDataManager/UserData.h&gt;
#include &lt;SomeType.h&gt;
#include "MyType.h"

class AppObject : public vrj::GlApp
{
public:
   void init();
   void preFrame();
   void latePreFrame();
   void draw();

   // Other public member functions ...

private:
   cluster::UserData&lt;MyType&gt; mMyTypeObj;
   cluster::UserData&lt; vpr::SerializableObjectMixin&lt;SomeType&gt; &gt; mSomeTypeObj;
};</programlisting>
               </example>

               <para>Next, we must initialize the
               <classname>cluster::UserData&lt;T&gt;</classname> instances so
               that the Application Data Manager plug-in can identify the
               shared data types and so that the application can determine
               which cluster node will be allowed to write to the shared data.
               While there are two ways to do this, we will show only the
               recommended approach here. First, a globally unique identifier
               (GUID) must be defined for each and every shared data type
               instance. The command-line utility <command>uuidgen</command>
               is available on most operating systems for generating new GUIDs
               (also known as universally unique identifiers or UUIDs). These
               will be used in the application object
               <methodname>init()</methodname> method, as shown in <xref
               linkend="example.init.cluster.UserData" />.</para>

               <example id="example.init.cluster.UserData">
                  <title>Initializing Application-Specific Shared Data</title>

                  <programlisting>void AppObject::init()
{
   vpr::GUID mytype_guid("99CFD306-32AB-11D9-A963-000D933B5E6A");
   mMyTypeObj.init(mytype_guid);

   vpr::GUID sometype_guid("A154B8E8-32AB-11D9-B4C9-000D933B5E6A");
   mSomeTypeObj.init(sometype_guid);
}</programlisting>
               </example>

               <important>
                  <para>Do not use the member function
                  <methodname>vpr::GUID::generate()</methodname> to initialize
                  the type-specific GUID objects. This will result in every
                  cluster node always having a different GUID value every time
                  the application is run (because GUIDs are unique by
                  definition). If this happens, the Application Data Manager
                  plug-in will never be able to complete its initialization,
                  and the application frame loop will not be able to start on
                  all the cluster nodes.</para>
               </important>

               <para>In conjunction with this, two config elements need to be
               created. These will be used by the Application Data Manager
               plug-in to identify which cluster node will be the writer node.
               The <quote>guid</quote> properties must match the string values
               used to initialize the
               <classname>vpr::GUID</classname><indexterm>
                     <primary>vpr::GUID</primary>
                  </indexterm><indexterm>
                     <primary>classes</primary>

                     <secondary>vpr::GUID</secondary>
                  </indexterm> objects in <xref
               linkend="example.init.cluster.UserData" />. The
               <quote>hostname</quote> properties set the name of the cluster
               node that will be the shared data writer. An example of this is
               shown in <xref
               linkend="example.config.cluster.UserData" />.</para>

               <example id="example.config.cluster.UserData">
                  <title>Application-Specific Shared Data
                  Configuration</title>

                  <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings configuration.version="3.0"?&gt;
&lt;configuration
   xmlns="http://www.vrjuggler.org/jccl/xsd/3.0/configuration"
   name="Example Shared Application Data Configuration"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.0/configuration http://www.vrjuggler.org/jccl/xsd/3.0/configuration.xsd"&gt;

   &lt;elements&gt;
      &lt;application_data name="MyType Shared Data" version="1"&gt;
         &lt;guid&gt;99CFD306-32AB-11D9-A963-000D933B5E6A&lt;/guid&gt;
         &lt;hostname&gt;machine1&lt;/hostname&gt;
      &lt;/application_data&gt;
      &lt;application_data name="SomeType Shared Data" version="1"&gt;
         &lt;guid&gt;A154B8E8-32AB-11D9-B4C9-000D933B5E6A&lt;/guid&gt;
         &lt;hostname&gt;machine1&lt;/hostname&gt;
      &lt;/application_data&gt;
   &lt;/elements&gt;
&lt;/configuration&gt;</programlisting>
               </example>

               <caution>
                  <para>Be very careful to ensure that the GUID strings match
                  correctly. This means matching the strings in the
                  <literal>application_data</literal> config element
                  <quote>guid</quote> property with the use in the application
                  code. If the GUID strings are not matched correctly, the
                  Application Data Manager will not be able to match the
                  objects initialized in the application object
                  <methodname>init()</methodname> method.</para>
               </caution>

               <para>Now that the shared data is initialized and ready to use,
               we can write to and read from it—the Application Data Manager
               plug-in will take care of the rest. Only one node can be
               allowed to write to the data. This is determined through the
               use of the method
               <methodname>cluster::UserData&lt;T&gt;::isLocal()</methodname>.
               This method returns a Boolean value that indicates whether the
               data is <quote>local.</quote> The local node is the one named
               in the configuration element, as shown earlier. Writes to
               shared data should only occur in
               <methodname>preFrame()</methodname> or
               <methodname>postFrame()</methodname> after testing the result
               of
               <methodname>cluster::UserData&lt;T&gt;::isLocal()</methodname>.
               This is shown in <xref
               linkend="example.write.cluster.UserData" />.</para>

               <important>
                  <para>The <classname>cluster::UserData&lt;T&gt;</classname>
                  instances introduce a level of indirection (using the Smart
                  Pointer design pattern) for accessing the shared data that
                  works in both the cluster and the non-cluster case. No
                  direct access to shared data is allowed when using
                  <classname>cluster::UserData&lt;T&gt;</classname>. This is
                  true both for reading and for writing, demonstrated in <xref
                  linkend="example.write.cluster.UserData" />, in <xref
                  linkend="example.read.cluster.UserData.latePreFrame" />, and
                  in <xref
                  linkend="example.read.cluster.UserData.draw" />.</para>
               </important>

               <example id="example.write.cluster.UserData">
                  <title>Writing to Application-Specific Shared Data</title>

                  <programlisting>void AppObject::preFrame()
{
   if ( mMyTypeObj.isLocal() )
   {
      // Computations ...
      mMyTypeObj-&gt;setIntData(...);
      mMyTypeObj-&gt;setByteData(...);
      mMyTypeObj-&gt;setFloatData(...);
   }

   if ( mSomeTypeObj.isLocal() )
   {
      // Computations ...
      mSomeTypeObj-&gt;setIntData(...);
      mSomeTypeObj-&gt;setByteData(...);
      mSomeTypeObj-&gt;setFloatData(...);
   }
}</programlisting>
               </example>

               <para>After the snapshot of the application-specific shared
               data for the current frame has been distributed to the cluster
               nodes, it is time to read the shared data and set up the
               application state for rendering the current frame. This should
               be done in the application object method
               <methodname>latePreFrame()</methodname> or in
               <methodname>draw()</methodname>. This is demonstrated in <xref
               linkend="example.read.cluster.UserData.latePreFrame" /> and in
               <xref linkend="example.read.cluster.UserData.draw" />. All the
               nodes in the cluster will read the results of the computations
               made in <methodname>preFrame()</methodname> and set up the
               application state before rendering. In general, there should be
               no need to use
               <methodname>cluster::UserData&lt;T&gt;::isLocal()</methodname>
               at this point.</para>

               <example id="example.read.cluster.UserData.latePreFrame">
                  <title>Reading from Application-Specific Shared Data in
                  <methodname>latePreFrame()</methodname></title>

                  <programlisting>void AppObject::latePreFrame()
{
   mStateVar1 = mMyTypeObj-&gt;getIntData();
   mStateVar2 = mMyTypeObj-&gt;getByteData();
   // And so on ...
}</programlisting>
               </example>

               <example id="example.read.cluster.UserData.draw">
                  <title>Reading from Application-Specific Shared Data in
                  <methodname>draw()</methodname></title>

                  <programlisting>void AppObject::draw()
{
   int  state_var1 = mMyTypeObj-&gt;getIntData();
   char state_var2 = mMyTypeObj-&gt;getByteData();
   // And so on ...
   // Render the scene ...
}</programlisting>
               </example>

               <para>The choice of which method to use depends on the
               application type and on the data flow of the application
               object. Scene graph-based application objects will not have a
               <methodname>draw()</methodname> method, so
               <methodname>latePreFrame()</methodname> must be used. For
               application object types not based on a scene graph (currently
               only <classname>vrj::GlApp</classname>), there is a trade off
               to consider. If <methodname>latePreFrame()</methodname> is
               used, then the rendering state information must be stored in
               member variables of the application class. If
               <methodname>draw()</methodname> is used, then the state can be
               defined using stack variables within the method, but the
               additional function call overhead and pointer derference
               (resulting from the use of the Smart Pointer pattern) could
               impact the application frame rate. Remember that
               <methodname>draw()</methodname> is invoked for every window and
               every viewport within each window. The number of calls to
               <methodname>draw()</methodname> increases further when
               stereoscopic rendering is enabled. If
               <methodname>latePreFrame()</methodname> is used instead, the
               Smart Pointer overhead will only be exhibited once per
               frame.</para>
            </section>

            <section>
               <title>General Cluster Programming Issues</title>

               <para>With the tools for VR Juggler cluster programming in
               hand, we can turn our attention to specific, higher level areas
               that must be handled carefully when writing applications that
               may run on a graphics cluster.</para>

               <section id="section.cluster.time.deltas">
                  <title>Time-Based Computations</title>

                  <indexterm zone="section.cluster.time.deltas">
                     <primary>application programming</primary>

                     <secondary>clustering</secondary>

                     <tertiary>time deltas</tertiary>
                  </indexterm>

                  <para>Using time as input to algorithms is a very common
                  occurrence in VR applications. On a cluster, however, each
                  node has its own clock, and each node may start its frame
                  loop at a slightly different time than the other cluster
                  nodes. Differences such as these would result in
                  inconsistencies among the time-based computations across the
                  cluster nodes.</para>

                  <para>These problems can be avoided through a feature of the
                  input data sharing feature of VR Juggler's cluster support.
                  Every time a Gadgeteer device driver takes a sample from the
                  input device, a time stamp is applied to the sample. This
                  time stamp is included with the shared device data and can
                  be accessed through the device interfaces used by the
                  application objects. A time delta since the last frame can
                  then be calculated. Use of this is demonstrated in <xref
                  linkend="example.getTimeStamp" />.</para>

                  <example id="example.getTimeStamp">
                     <title>Calculating Frame Deltas Using
                     <classname>vpr::Interval</classname></title>

                     <programlisting>static vpr::Interval last_frame; 
vpr::Interval current_frame = mHead-&gt;getTimeStamp();
vpr::Interval diff(current_frame - last_frame);
last_frame = current_frame; // You can get the delta in microseconds from 
                            // vpr::Uint64 delta = diff.usecs();</programlisting>
                  </example>

                  <important>
                     <para>This technique implies that the Remote Input
                     Manager plug-in (<literal>RIMPlugin</literal>) and the
                     Start Barrier plug-in
                     (<literal>StartBarrierPlugin</literal>) must be used by
                     the Cluster Manager.</para>
                  </important>
               </section>

               <section id="section.cluster.random.numbers">
                  <title>Random Numbers</title>

                  <indexterm zone="section.cluster.random.numbers">
                     <primary>application programming</primary>

                     <secondary>clustering</secondary>

                     <tertiary>random numbers</tertiary>
                  </indexterm>

                  <para>Random numbers are, by definition, random. When two
                  computers generate a random number, there is a high
                  likelihood that they will generate different numbers.
                  However, the algorithms used to generate random numbers on
                  computers generate <emphasis>pseudo-random</emphasis>
                  numbers. Pseudo-random numbers are generated by algorithms
                  that have a predictable nature. Given a known starting point
                  (called a <firstterm>seed</firstterm>), the sequence of
                  numbers generated can be predicted. If the same algorithm is
                  seeded identically on two separate computers, the two
                  sequences of generated random numbers will be identical.
                  Varying the seed allows the algorithms to generate different
                  random sequences</para>

                  <para>This is a very important issue for VR application
                  programming in a cluster configuration. When an application
                  object uses random numbers, each application instance across
                  the cluster must generate the same sequence of random
                  numbers. With VR Juggler, there are two options for making
                  this happen. The first is to seed the random number
                  generator algorithm identically on all the cluster nodes.
                  This is an easy solution as long as all the nodes use the
                  same algorithm to generate random numbers. If the seed is
                  hard coded into the application object initialization, the
                  random number sequence will always be the same for every run
                  of the application. While the numbers will still be random,
                  the predictable nature of pseudo-random number generators
                  could become a detriment.</para>

                  <para>The second option is to use application-specific
                  shared data, as described above in <xref
                  linkend="section.cluster.UserData" />. In this case, only
                  one node will generate the random numbers, and the
                  Application Data Manager will take care of sharing the most
                  recently generated number(s) with the other nodes. Using
                  this approach allows for better algorithm seeding and thus
                  better random number generation. It also avoids the issue of
                  different computers having different random number generator
                  algorithms.</para>
               </section>
            </section>

            <section>
               <title>Troubleshooting Cluster Problems</title>

               <para>In this final section, we present some frequently asked
               questions regarding VR Juggler application programming and
               clustering.</para>

               <qandaset>
                  <qandadiv>
                     <qandaentry>
                        <question>
                           <para>Why doesn't swap lock work with OpenGL
                           Performer-based applications?</para>
                        </question>

                        <answer>
                           <para>OpenGL Performer can make use of multiple
                           processes to separate the App, Cull, and Draw
                           actions. This allows Performer to spread its work
                           out across three processors. Unfortunately, this
                           interferes with cluster synchronization, so
                           Performer multi-processing cannot be used in
                           conjunction with the cluster capabilities in VR
                           Juggler. The VR Juggler Performer Draw Manager is
                           already written to disable multi-processing when the
                           Cluster Manager is active.</para>
                        </answer>
                     </qandaentry>

                     <qandaentry>
                        <question>
                           <para>Why is my application navigating differently
                           on every screen?</para>
                        </question>

                        <answer>
                           <para>All navigation must be based on time stamps
                           returned from input devices. These time stamps, of
                           type <classname>vpr::Interval</classname><indexterm>
                                 <primary>vpr::Interval</primary>
                              </indexterm><indexterm>
                                 <primary>classes</primary>

                                 <secondary>vpr::Interval</secondary>
                              </indexterm>, can be acquired from any device
                           interface that refers to a device being shared
                           across the cluster, and they can be used to compute
                           the time deltas between frames. More details can be
                           found in <xref
                           linkend="section.cluster.time.deltas" />.</para>
                        </answer>
                     </qandaentry>

                     <qandaentry>
                        <question>
                           <para>Why does my application hang at startup on all
                           the nodes?</para>
                        </question>

                        <answer>
                           <para>When using the Start Barrier Plug-in, the
                           application object frame loop methods
                           (<methodname>preFrame()</methodname>,
                           <methodname>postFrame()</methodname>,
                           <methodname>draw()</methodname>,
                           <methodname>getScene()</methodname>, etc.) will not
                           be invoked until all the cluster nodes are ready to
                           run. The <quote>ready to run</quote> determination
                           is made by waiting for all the cluster nodes to be
                           connected and for all the cluster plug-ins to
                           complete their initialization. If all of the cluster
                           nodes are running and connected, then there is
                           probably a problem with a cluster plug-in.</para>

                           <para>For example, the Application Data Manager will
                           not initialize correctly on all nodes if the
                           type-specific GUIDs do not match on all nodes. In
                           this case, disabling the Start Barrier Plug-in will
                           result in the data-local cluster node being the only
                           one that starts correctly. All the others will fail
                           to open any display windows. See <xref
                           linkend="section.cluster.UserData" /> for more
                           information on this topic.</para>
                        </answer>
                     </qandaentry>
                  </qandadiv>
               </qandaset>
            </section>
         </section>

         <section id="section.adding.audio">
            <title>Adding Audio</title>

            <para>Immersive applications often take advantage of sound to
            enhance suspension of disbelief. VR Juggler application
            programmers have many options available to them for adding sound
            to their virtual environments. In this section, we describe the
            library Sonix that ships with VR Juggler. Sonix provides a layer
            of abstraction for third-party audio libraries including <ulink
            url="http://www.openal.org/">OpenAL</ulink>, <ulink
            url="http://audiere.sourceforge.net/">Audiere</ulink>, and <ulink
            url="http://www.multigen-paradigm.com/products/runtime/vega/modules/audioworks.shtml">AudioWorks</ulink>.
            In VR Juggler 2.0, there is one Sound Manager implemented using
            Sonix. As such, Sonix is the easiest tool to use for adding sound
            to VR Juggler applications, but it is not the only option.</para>

            <para>Sonix provides simple audio sound objects on top of several
            audio APIs. The interface to Sonix is kept very simple in order to
            get people up and running with sound as fast as possible. Sonix
            has the following features:</para>

            <itemizedlist>
               <listitem>
                  <para>Simple access to spatialized sound triggering.</para>
               </listitem>

               <listitem>
                  <para>Small learning curve withsimple interface and
                  usage.</para>
               </listitem>

               <listitem>
                  <para>Abstracts several well-known audio systems to provide
                  enhanced applicatin portability.</para>
               </listitem>

               <listitem>
                  <para>Supports reconfigurability at runtime.</para>
               </listitem>

               <listitem>
                  <para>Changing a sound resource reflects properly in all
                  other handles to the same resource (resources allow multiple
                  users).</para>
               </listitem>

               <listitem>
                  <para>Reconfigurations of sound resources are protected
                  (i.e. reconfiguration does not break application).</para>
               </listitem>

               <listitem>
                  <para>Supports features needed by 3D virtual environments
                  including spatialized audio, ambient audio, one-shot sounds,
                  and looping sounds.</para>
               </listitem>
            </itemizedlist>

            <para>VR Juggler application programmers can use the full Sonix
            API directly, or they can take advantage of the VR Juggler Sound
            Manager to reduce the amount of coding required. We will present
            both approaches. Example applications can be found in the
            directory
            <filename>$VJ_BASE_DIR/share/vrjuggler/samples/sound/simple</filename>.</para>

            <section id="section.using.sonix.directly">
               <title>Using Sonix Directly</title>

               <para>We begin our explanation of adding sound to a VR Juggler
               application by presenting the direct use of the Sonix API. This
               requires more programming than using the VR Juggler Sound
               Manager, but it will be useful to understand how Sonix operates
               in order to take full advantage of the Sound Manager. In
               particular, reading this section is a necessary part of
               understanding general Sonix usage, and readers are encouraged
               to read both this section and the next before deciding on which
               approach to use in their VR Juggler applications.</para>

               <section id="section.basic.sonix.usage">
                  <title>Basic Sonix Usage</title>

                  <para>In <xref linkend="figure.sonix.interface" />, we see
                  the API for Sonix (see <xref
                  linkend="figure.complete.sonix.design" /> for the complete
                  software architecture). The main parts that a sound
                  programmer will use are the classes
                  <classname>snx::SoundHandle</classname> and
                  <classname>snx::sonix</classname> (a singleton). The
                  <classname>snx::SoundHandle</classname> class is used to
                  manipulate individual sounds. The
                  <classname>snx::sonix</classname> singleton class is used to
                  start, stop, and reconfigure the sound system. Both classes
                  must be used for any sound to be heard.</para>

                  <figure id="figure.sonix.interface">
                     <title>Basic Sonix Interface</title>

                     <mediaobject>
                        <imageobject>
                           <imagedata align="center"
                                      fileref="figures/sonix_interface.png"
                                      format="PNG" />
                        </imageobject>
                     </mediaobject>
                  </figure>

                  <para>Starting the Sonix system is easy. Basically, the only
                  call needed to start the system is
                  <methodname>snx::sonix::changeAPI()</methodname>. The
                  backend audio software is loaded into Sonix through a
                  plug-in system. The plug-in to use is identified by a string
                  name, one of <quote>OpenAL</quote>,
                  <quote>AudioWorks</quote>, or <quote>Audiere</quote>, as
                  shown in <xref linkend="example.sonix.OpenAL" />. The choice
                  of which to use depends on availability and compatibility.
                  For example, AudioWorks is available on the IRIX operating
                  system, but it can only be used with a build of VR Juggler
                  that uses SPROC threads. On the other hand, OpenAL and
                  Audiere on IRIX can only be used with a pthreads build of VR
                  Juggler.</para>

                  <example id="example.sonix.OpenAL">
                     <title>Initializing the Sonix Sound APi</title>

                     <programlisting>snx::sonix::instance()-&gt;changeAPI("OpenAL");</programlisting>
                  </example>

                  <para>Setting up a sound is designed to be simple, and an
                  example of doing so is shown in <xref
                  linkend="example.sonix.soundhandle" />. Here, we use an
                  instance of <classname>snx::SoundInfo</classname> to
                  configure the sound object, which is in turn accessed by an
                  instance of <classname>snx::SoundHandle</classname>.</para>

                  <example id="example.sonix.soundhandle">
                     <title>Setting Up a Sonix Sound Handle</title>

                     <programlisting>snx::SoundInfo info;
info.filename = "crack.wav";
info.datasource = snx::SoundInfo::FILESYTEM;

snx::SoundHandle crack_sound("crack");
crack_sound.configure(info);</programlisting>
                  </example>

                  <para>Periodically, an update function must be called to
                  keep Sonix running. The method is snx::sonix::step(), and it
                  takes a single argument of type <type>float</type>
                  representing the time since the last time it was called. In
                  general, this should be invoked in the frame function of an
                  application. In the context of VR Juggler, this would be
                  either <methodname>preFrame()</methodname> or
                  <methodname>postFrame()</methodname> in the application
                  object interface. An example of using this function is shown
                  in <xref linkend="example.sonix.frame" />.</para>

                  <example id="example.sonix.frame">
                     <title>Sonix Frame Update</title>

                     <programlisting>void MyApp::preFrame()
{
   // Update application state for the current frame
   // ...

   float time_delta = getTimeChangeInSeconds(); // use a system call or other API
                                                // to get the time delta
   snx::sonix::instance()-&gt;step(time_delta);
}</programlisting>
                  </example>

                  <example id="example.complete.sonix.app">
                     <title>Complete Sonix Program Using OpenAL</title>

                     <programlisting linenumbering="numbered">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;snx/sonix.h&gt;

int main(int argc, char* argv[])
{
   std::string filename(:808kick.wav"), api("OpenAL");

   if ( ! snx::FileIO::fileExists(filename.c_str()) )
   {
      std::cout &lt;&lt; "File not found: " &lt;&lt; filename &lt;&lt; "\n" &lt;&lt; std::flush;
      return 1;
   }

   // start sonix using OpenAL
   snx::sonix::instance()-&gt;changeAPI(api);

   // fill out a description for the sound we want to play
   snx::SoundInfo sound_info;
   sound_info.filename = filename;
   sound_info.datasource = snx::SoundInfo::FILESYSTEM;

   // create the sound object
   snx::SoundHandle sound_handle;
   sound_handle.init("my simple sound");
   sound_handle.configure(sound_info);

   // trigger the sound
   sound_handle.trigger();
   sleep(1);

   // trigger the sound from a different position in 3D space
   sound_handle.setPosition(10.0f, 0.0f, 0.0f);
   sound_handle.trigger();
   sleep(1);

   // this simulates a running application
   while ( 1 )
   {
      snx::sonix::instance()-&gt;step(time_delta);
   }

   return 0;
}</programlisting>
                  </example>
               </section>

               <section id="section.sonix.reconfiguration">
                  <title>Reconfiguration</title>

                  <para>Sonix is reconfigurable, allowing audio APIs to be
                  swapped out at run time safely without the dependent systems
                  noticing. Applications using Sonix expect to be completely
                  portable. Changing sound APIs at run time can be useful so
                  that the user can experiment with quality and latency
                  differences of different hardware and sound APIs. If no
                  audio API is available on a given platform, calls to Sonix
                  simply are ignored. This means that applications do not have
                  to have special code to enable or disable sounds based on
                  the availability of the backend sound software. These
                  details are handled transparently by Sonix.</para>

                  <para>Everything in Sonix can be reconfigured behind the
                  scenes during application execution. See <xref
                  linkend="example.sonix.reconfigure" /> for a trivial example
                  of how to reconfigure Sonix in C++. In a more complex
                  context, this feature of Sonix has powerful implications.
                  Sounds can be changed on the fly, as well as the API being
                  used to render the sound. Such details are hidden behind
                  sound handles and the <classname>snx::sonix</classname>
                  singleton.</para>

                  <example id="example.sonix.reconfigure">
                     <title>Reconfiguring Sonix at Run Time</title>

                     <programlisting linenumbering="numbered">// start sonix using OpenAL
snx::sonix::instance()-&gt;changeAPI("OpenAL");

// fill out a description for the sound we want to play
snx::SoundInfo sound_info;
sound_info.filename = "808kick.wav";
sound_info.datasource = snx::SoundInfo::FILESYSTEM;

// create the sound object
snx::SoundHandle sound_handle;
sound_handle.init("my sound for testing");
sound_handle.configure(sound_info);

// trigger the sound
sound_handle.trigger();
sleep(1);

// trigger the sound using a different audio system
snx::sonix::instance()-&gt;changeAPI("AudioWorks");
sound_handle.trigger();
sleep(1);

// trigger our sound object using different source data
sound_info.filename = "303riff.wav";
sound_handle.configure(sound_info);
sound_handle.trigger();
sleep(1);
</programlisting>
                  </example>
               </section>

               <section>
                  <title>Design and Implementation of Sonix</title>

                  <para>Before we conclude this section on using Sonix
                  directly in applications, we examine the design details of
                  Sonix. These details are beyond the scope of what needs to
                  be understood in order for Sonix to be utilized by VR
                  Juggler applications, so readers not interested in these
                  details can skip ahead to <xref
                  linkend="section.using.sound.manager" />.</para>

                  <para>Sonix was designed using modern software design
                  principles including design patterns and object oriented
                  design. The complete design of Sonix is depicted in UML in
                  <xref linkend="figure.complete.sonix.design" />. As
                  evidenced by the diagram, the design of Sonix is quite
                  simple, though the classes tend to have relatively large
                  interfaces. Refer to the Sonix <emphasis>Programmer
                  Reference</emphasis>, found on the <ulink
                  url="http://www.vrjuggler.org/sonix/docs.php">Sonix
                  documentaiton web page</ulink>, for complete documentation
                  of these interfaces.</para>

                  <figure id="figure.complete.sonix.design">
                     <title>The Sonix Design</title>

                     <mediaobject>
                        <imageobject>
                           <imagedata align="center"
                                      fileref="figures/sonix_system_view.png"
                                      format="PNG" />
                        </imageobject>
                     </mediaobject>
                  </figure>

                  <section>
                     <title>Design Patterns Overview</title>

                     <para>Design patterns describe simple and elegant
                     solutions to specific problems in object oriented
                     software design. When designing Sonix, we used many
                     design patterns appropriate for a simple audio
                     system.</para>

                     <itemizedlist>
                        <listitem>
                           <para>Adapter
                           (<classname>snx::SoundImplementation</classname>).
                           This adapter provides a common interface to the
                           underlying sound API.</para>
                        </listitem>

                        <listitem>
                           <para>Prototype
                           (<classname>snx::SoundImplementation</classname>).
                           Making
                           <classname>snx::SoundImplementation</classname> a
                           Prototype allows a new cloned object to be created
                           from it that has duplicate state.</para>
                        </listitem>

                        <listitem>
                           <para>Store/plugin-method
                           (<classname>snx::SoundFactory</classname>). Each
                           sound implementation is registered with a Store
                           called <classname>snx::SoundFactory</classname>.
                           This Store allows users to select items from its
                           inventory. Another name for Store is <quote>Abstract
                           Factory.</quote></para>
                        </listitem>

                        <listitem>
                           <para>Abstract Factory
                           (<classname>snx::SoundFactory</classname>). The
                           Store can create new instances of the requested
                           sound implementation. The Abstract Factory consults
                           its Store of registered objects, and if found, makes
                           a clone of that object (Prototype pattern). The
                           Abstract Factory is used in Sonix to configure the
                           Bridge.</para>
                        </listitem>

                        <listitem>
                           <para>Bridge (<classname>snx::sonix</classname>
                           interface class and
                           <classname>snx::SoundImplementation</classname>).
                           The <classname>snx::sonix</classname> class is the
                           audio system abstraction which is decoupled from its
                           implementation
                           <classname>snx::SoundImplementation</classname>.
                           This way the two can vary independently. Bridge also
                           facilitates run-time configuration of the sound
                           API.</para>
                        </listitem>

                        <listitem>
                           <para>Proxy (<classname>std::string</classname> and
                           <classname>snx::SoundHandle</classname>).
                           <classname>snx::SoundHandle</classname> is how users
                           manipulate their sound object.
                           <classname>snx::SoundHandle</classname> is actually
                           a proxy to a <classname>std::string</classname>
                           proxy. The <classname>std::string</classname> Proxy
                           is what allows Sonix reconfiguration of resources.
                           Rather than using pointers which can easily be left
                           to dangle, the <classname>std::string</classname>
                           serves as a lookup for a protected sound resource
                           located internally to the Sonix run-time memory
                           space. The <classname>snx::SoundHandle</classname>
                           wraps this <classname>std::string</classname> to
                           provide a simple and familiar C++ object to use as
                           the sound handle. The Sonix class acts as Mediator
                           between every Proxy method and the actual audio
                           system Adapter.</para>
                        </listitem>
                     </itemizedlist>
                  </section>

                  <section>
                     <title>Pluggable Audio Subsystems</title>

                     <para>Sonix supports the selection of several audio
                     subsystems by the application through implementation
                     plug-ins (see <xref linkend="figure.sonix.plugins" />).
                     Each plug-in implements an adapter to an underlying audio
                     subsystem. The adapter supports a common interface that
                     Sonix knows how talk to. Each adapter is then registered
                     with a factory object, which may ask that adapter to
                     clone itself for use by whomever called the
                     factory.</para>

                     <figure id="figure.sonix.plugins">
                        <title>Use of Plug-ins in Sonix</title>

                        <mediaobject>
                           <imageobject>
                              <imagedata align="center"
                                         fileref="figures/how_sonix_plugins_work.png"
                                         format="PNG" />
                           </imageobject>
                        </mediaobject>
                     </figure>
                  </section>
               </section>
            </section>

            <section id="section.using.sound.manager">
               <title>Using the VR Juggler Sound Manager</title>

               <para>Now that we understand how Sonix works and how to use its
               simple API, we can go one step further and simplify the usage
               even more. Similar to the graphics API-specific VR Juggler Draw
               Managers, there exists the concept of a Sound Manager. There is
               a Sonix-specific Sound Manager implementation that handles many
               of the details of Sonix usage.</para>

               <para>The Sonix Sound Manager is configured using a config
               element of type <literal>sound_manager_sonix</literal>. The
               config element sets the sound API to use, defines the llistener
               position, and sets up all the sound objects that will be used
               by the application. All of this would normally have to be done
               by the application programmer using the
               <classname>snx::sonix</classname> singleton, as presented above
               in <xref linkend="section.basic.sonix.usage" />. In <xref
               linkend="example.config.sonix.sound.manager" />, we show a
               small example of configuring the Sonix Sound Manager. Note that
               some parts of the config file are removed for brevity. Aspects
               of this will be referenced in the code examples shown
               below.</para>

               <example id="example.config.sonix.sound.manager">
                  <title>Example Sonix Sound Manager Conifguration</title>

                  <programlisting>&lt;sound_manager_sonix version="1"&gt;
   &lt;api&gt;OpenAL&lt;/api&gt;
   &lt;listener_position&gt;0.0&lt;/listener_position&gt;
   &lt;listener_position&gt;0.0&lt;/listener_position&gt;
   &lt;listener_position&gt;0.0&lt;/listener_position&gt;
   &lt;sound&gt;
      &lt;sound name="bump" version="1"&gt;
         &lt;filename&gt;${VJ_BASE_DIR}/share/vrjuggler/data/sounds/bump.wav&lt;/filename&gt;
         &lt;ambient&gt;false&lt;/ambient&gt;
         &lt;retriggerable&gt;false&lt;/retriggerable&gt;
         &lt;loop&gt;1&lt;/loop&gt;
         &lt;pitch_bend&gt;1.0&lt;/pitch_bend&gt;
         &lt;cutoff&gt;1.0&lt;/cutoff&gt;
         &lt;volume&gt;1.0&lt;/volume&gt;
         &lt;position&gt;0.0&lt;/position&gt;
         &lt;position&gt;0.0&lt;/position&gt;
         &lt;position&gt;0.0&lt;/position&gt;
      &lt;/sound&gt;
   &lt;/sound&gt;
   &lt;sound&gt;
      &lt;sound name="step" version="1"&gt;
         &lt;filename&gt;${VJ_BASE_DIR}/share/vrjuggler/data/sounds/footstep.wav&lt;/filename&gt;
         &lt;ambient&gt;false&lt;/ambient&gt;
         &lt;retriggerable&gt;false&lt;/retriggerable&gt;
         &lt;loop&gt;1&lt;/loop&gt;
         &lt;pitch_bend&gt;1.0&lt;/pitch_bend&gt;
         &lt;cutoff&gt;1.0&lt;/cutoff&gt;
         &lt;volume&gt;1.0&lt;/volume&gt;
         &lt;position&gt;0.0&lt;/position&gt;
         &lt;position&gt;0.0&lt;/position&gt;
         &lt;position&gt;0.0&lt;/position&gt;
      &lt;/sound&gt;
   &lt;/sound&gt;
   &lt;!-- Other sound objects ... --&gt;
&lt;/sound_manager_sonix&gt;</programlisting>
               </example>

               <para>All sound files named in the config element are
               automatically loaded by the Sonix Sound Manager. User
               applications simply declare sound handles that refer to the
               loaded sound objects. The VR Juggler application class will
               then include one <classname>snx::SoundHandle</classname>
               instance for each sound object declared in the Sonix Sound
               Manager config element, as shown in <xref
               linkend="example.app.declaring.sound.handles" />. This is very
               similar to the use of Gadgeteer device interfaces that provide
               access to device input.</para>

               <example id="example.app.declaring.sound.handles">
                  <title>Declaring Sound Handles in Application Object
                  Class</title>

                  <programlisting>class MySoundApp : public vrj::GlApp
{
public:
   void init();
   void preFrame();
   // Other application object interface methods ...

private:
   // Determines if the "bump" sound should be triggered.
   bool shouldTriggerBump();

   // Determines if the "step" sound should be triggered.
   bool shouldTriggerStep();

   snx::SoundHandle mBumpSound;
   snx::SoundHandle mStepSound;
   // And so on ...
};</programlisting>
               </example>

               <para>To get access to the sounds through the
               <classname>snx::SoundHandle</classname> objects, the sound
               handles must be initialized. This is done in the same way as
               described earlier in the explanation of direct use of the Sonix
               API. The sound handle initialization should be performed in the
               <methodname>init()</methodname> method of the VR Juggler
               application object, as shown in <xref
               linkend="example.app.init.sound.handles" />. The string value
               passed to <methodname>snx::SoundHandle::init()</methodname> is
               the name given in the Sonix Sound Manager config element.
               Again, we see similarity with the usage of Gadgeteer device
               interfaces.</para>

               <example id="example.app.init.sound.handles">
                  <title>Initializing Sound Handles in an Application
                  Object</title>

                  <programlisting>void MySoundApp::init()
{
   mBumpSound.init("bump");
   mStepSound.init("step");
   // And so on ...
}</programlisting>
               </example>

               <para>Finally, the sounds can be triggered in the application
               object <methodname>preFrame()</methodname> method, shown below
               in <xref linkend="example.app.trigger.sound" />. They should
               not be triggered in the <methodname>draw()</methodname> method
               because, as we have seen in earlier sections,
               <methodname>draw()</methodname> can be invoked multiple times
               per frame. There is no need to call the function
               <methodname>snx::sonix::step()</methodname> in
               <methodname>preFrame()</methodname> or in
               <methodname>postFrame()</methodname>. This is done
               automatically within the Sonix Sound Manager each time through
               the kernel control loop.</para>

               <example id="example.app.trigger.sound">
                  <title>Triggering Sounds in an Application Object</title>

                  <programlisting>void MySoundApp::preFrame()
{
   if ( shouldTriggerBump() )
   {
      mBumpSound.trigger();
   }

   if ( shouldTriggerStep() )
   {
      mStepSound.trigger();
   }
}</programlisting>
               </example>

               <para>Other methods in the
               <classname>snx::SoundHandle</classname> class interface can be
               invoked on the sound handle objects. We have focused on simple
               rendering of sounds here. Refer to the Sonix
               <emphasis>Programmer Reference</emphasis>, found on the <ulink
               url="http://www.vrjuggler.org/sonix/docs.php">Sonix
               documentation web page</ulink>, for complete documentation on
               the interface of
               <classname>snx::SoundHandle</classname>.</para>
            </section>
         </section>
      </chapter>

      <chapter id="chapter.porting.CAVElibs">
         <title>Porting to VR Juggler from the
         <productname>CAVElibs</productname></title>

         <indexterm>
            <primary>porting applications from</primary>

            <secondary><productname>CAVElibs</productname></secondary>
         </indexterm>

         <indexterm>
            <primary><productname>CAVElibs</productname></primary>

            <secondary>porting to VR Juggler</secondary>
         </indexterm>

         <para>In this chapter, we give some methods for porting an
         application written with the <productname>CAVElibs</productname>
         software to VR Juggler. We explain the process for an OpenGL
         application. Throughout, we compare and contrast the techniques used
         by VR Juggler and the <productname>CAVElibs</productname> software,
         and we translate concepts familiar to
         <productname>CAVElibs</productname> programmers into VR Juggler
         terms.</para>

         <section>
            <title>The Initialize, Draw, and Frame Routines</title>

            <para>In the <productname>CAVElibs</productname>, the initialize,
            draw, and frame routines are known as <glossterm
            linkend="gloss.callback">callbacks</glossterm> implemented with C
            function pointers. In VR juggler, the equivalent routines are
            <quote>called back</quote> using an application object. An
            application object is a C++ class that defines methods to
            encapsulate the functionality of the application within a single
            C++ object.</para>

            <bridgehead>In <productname>CAVElibs</productname></bridgehead>

            <para>The following lists the draw, frame, and initialize routines
            used in the <productname>CAVElibs</productname> software.</para>

            <itemizedlist>
               <listitem>
                  <para>Draw: An application's display callback function is
                  defined by passing a function pointer to
                  <function>CAVEDisplay()</function></para>
               </listitem>

               <listitem>
                  <para>Frame: The frame function is defined with
                  <function>CAVEFrameFunction()</function></para>
               </listitem>

               <listitem>
                  <para>Init: The initialization callback is defined using
                  <function>CAVEInitApplication()</function></para>
               </listitem>
            </itemizedlist>

            <bridgehead>In VR Juggler</bridgehead>

            <para>With VR Juggler, no C function pointers are necessary, but a
            pointer to an application object must be given to the VR Juggler
            kernel. As described in earlier sections of this chapter, the
            first step is to derive a new application class from
            <classname>vrj::GlApp</classname>. For more information on
            application objects, it may be helpful to review <xref
            linkend="chapter.app.basics" />. Briefly, the application class
            definition would appear similar to the following:</para>

            <programlisting>class MyApplication : public vrj::GlApp
{
   ...
};</programlisting>

            <para>The draw, frame, and initialize routine concepts in VR
            Juggler are presented in the following list.</para>

            <itemizedlist>
               <listitem>
                  <para>Draw: An application's display <quote>callback</quote>
                  function is defined by a member function called
                  <methodname>draw()</methodname> in the derived class. This
                  is where OpenGL rendering commands such as
                  <function>glBegin()</function>,
                  <function>glVertex()</function>, etc. are placed.</para>
               </listitem>

               <listitem>
                  <para>Frame: Calculations such as navigation, collision,
                  physics, artificial intelligence, etc. are often placed in
                  the frame function. The frame function is split across three
                  member functions:</para>

                  <orderedlist>
                     <listitem>
                        <para><methodname>MyApplication::preFrame()</methodname>,
                        called before <methodname>draw()</methodname></para>
                     </listitem>

                     <listitem>
                        <para><methodname>MyApplication::intraFrame()</methodname>,
                        called during <methodname>draw()</methodname></para>
                     </listitem>

                     <listitem>
                        <para><methodname>MyApplication::postFrame()</methodname>,
                        called after <methodname>draw()</methodname></para>
                     </listitem>
                  </orderedlist>
               </listitem>

               <listitem>
                  <para>Init: There is an initialization member function for
                  data and an initialization member function for creating
                  context-specific data (display lists, texture objects). The
                  latter is called for each <glossterm
                  linkend="gloss.display.context">display context</glossterm>
                  in the system. These two member functions are:</para>

                  <orderedlist>
                     <listitem>
                        <para><methodname>MyApplication::init()</methodname>,
                        called once per application startup</para>
                     </listitem>

                     <listitem>
                        <para><methodname>MyApplication::contextInit()</methodname>,
                        called once per display context
                        <emphasis>creation</emphasis></para>
                     </listitem>
                  </orderedlist>
               </listitem>
            </itemizedlist>

            <para>Readers who find some of these concepts unfamiliar are
            encouraged to read <xref linkend="section.opengl.apps" />. For
            information about context-specific data, refer to <xref
            linkend="section.csdata.intro" />.</para>
         </section>

         <section>
            <title>Getting Input from Devices</title>

            <para>Getting input from the hardware devices is conceptually the
            same, but the implementations are quite different between the
            <productname>CAVElibs</productname> software and VR
            Juggler.</para>

            <bridgehead>In <productname>CAVElibs</productname></bridgehead>

            <para>To get tracking information, the following functions are
            used:</para>

            <itemizedlist>
               <listitem>
                  <para><function>CAVEGetPosition(id, pos)</function></para>
               </listitem>

               <listitem>
                  <para><function>CAVEGetOrientation(id,
                  orient)</function></para>
               </listitem>

               <listitem>
                  <para><function>CAVEGetVector(id, vec)</function></para>
               </listitem>

               <listitem>
                  <para><function>CAVEGetSensorPosition(sensor, coords,
                  pos)</function></para>
               </listitem>

               <listitem>
                  <para><function>CAVEGetSensorOrientation(sensor, coords,
                  orient)</function></para>
               </listitem>

               <listitem>
                  <para><function>CAVEGetSensorVector(sensor, id,
                  vec)</function></para>
               </listitem>
            </itemizedlist>

            <para>For button input, the following macros are used:</para>

            <itemizedlist>
               <listitem>
                  <para><constant>CAVEBUTTON1</constant>,
                  <constant>CAVEBUTTON2</constant>,
                  <constant>CAVEBUTTON3</constant>,
                  <constant>CAVEBUTTON4</constant>,
                  <constant>CAVE_JOYSTICK_X</constant>, and
                  <constant>CAVE_JOYSTICK_Y</constant></para>
               </listitem>

               <listitem>
                  <para><function>CAVEButtonChange()</function></para>
               </listitem>
            </itemizedlist>

            <bridgehead>In VR Juggler</bridgehead>

            <para>To get device input, use the type-specific instantiations of
            <classname>gadget::DeviceInterface&lt;T&gt;</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::DeviceInterface&lt;T&gt;</secondary>
               </indexterm>. They include the following:</para>

            <itemizedlist>
               <listitem>
                  <para><classname>gadget::PositionInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::PositionInterface</secondary>
                     </indexterm> for trackers and other positional
                  devices</para>
               </listitem>

               <listitem>
                  <para><classname>gadget::DigitalInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::DigitalInterface</secondary>
                     </indexterm> for buttons and other on/off devices</para>
               </listitem>

               <listitem>
                  <para><classname>gadget::AnalogInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::AnalogInterface</secondary>
                     </indexterm> for potentiometers and other multi-range
                  data devices</para>
               </listitem>

               <listitem>
                  <para><classname>gadget::KeyboardMouseInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::KeyboardMouseInterface</secondary>
                     </indexterm> for keyboard and mouse input</para>
               </listitem>
            </itemizedlist>

            <para>For more information about the VR Juggler device interfaces,
            refer to <xref linkend="section.gadget.proxies.devif" />. A
            tutorial on getting device input in VR Juggler applications can be
            found in <xref linkend="section.get.input" />.</para>
         </section>

         <section>
            <title>Configuration</title>

            <para>Configuration of VR Juggler and the
            <productname>CAVElibs</productname> software is very different.
            The differences are too numerous to list here, but we give a brief
            overview and a pointer to the documentation that explains
            configuration of VR Juggler.</para>

            <bridgehead>In <productname>CAVElibs</productname></bridgehead>

            <para>All configurable parameters go in a single file called
            <filename>.caverc</filename>. The configuration mechanism is
            proprietary and not usable by external VR system software. In
            particular, VR Juggler cannot get its configuration information
            from an existing <filename>.caverc</filename> file.</para>

            <bridgehead>In VR Juggler</bridgehead>

            <para>Configuration of VR Juggler is much more powerful and
            flexible than what is used by the
            <productname>CAVElibs</productname> software. As a result, it is
            also more complex. All configurable parameters could be in one or
            more files with any names desired. VR Juggler comes with example
            configuration files that may be found in the directory
            <filename>$VJ_BASE_DIR/share/vrjuggler/data/configFiles</filename>.</para>

            <para>The VR Juggler configuration system is completely extensible
            and could be used outside of VR Juggler. Indeed, it could be used
            outside of any VR paradigm altogether. Refer to the Configuration
            Guide for more information on configuring VR Juggler.</para>
         </section>

         <section>
            <title>Important Notes</title>

            <para>Finally, before we get to the source code, there are some
            important notes about programming VR Juggler applications in
            general. Please read these carefully and refer to the indicated
            chapters for more information as necessary.</para>

            <section>
               <title>Shared Memory</title>

               <para>Unlike the <productname>CAVElibs</productname> software,
               VR Juggler does not have to manage shared memory with other VR
               Juggler instances. Thus, when writing a VR Juggler application,
               memory can be created as in a normal, single-threaded C or C++
               application.</para>
            </section>

            <section>
               <title>OpenGL Context-Specific Data</title>

               <para>As a result of the shared memory model described above,
               VR Juggler has different requirements for context-specific data
               than the <productname>CAVElibs</productname> software.
               Information such as display lists and texture objects must be
               managed using context-specific data. A <glossterm
               linkend="gloss.display.context">display context</glossterm> is
               the location to which OpenGL rendering commands draw. Compiled
               OpenGL commands such as display lists do not get shared across
               multiple contexts (or windows), and thus, they must be
               initialized once per display context. In a VR Juggler
               application, these OpenGL initializations must be placed in
               <methodname>vrj::GlApp::contextInit()</methodname>. It is
               called once per display context after each context has become
               active. For a more detailed description of these concepts and a
               tutorial on how to use them, please refer to <xref
               linkend="section.csdata.intro" />.</para>
            </section>
         </section>

         <section>
            <title>Source Code</title>

            <para>This final section is the heart of the porting discussion.
            We present some source code as a means to illustrate how
            <productname>CAVElibs</productname> concepts map to VR
            Juggler.</para>

            <section>
               <title>The Form of a Basic <productname>CAVElibs</productname>
               Program</title>

               <programlisting linenumbering="numbered">void app_shared_init();
void app_compute_init();
void app_init_gl();
void app_draw();
void app_compute();

void main(int argc, char **argv)
{
   CAVEConfigure(&amp;argc,argv,NULL);
   app_shared_init(argc,argv);
   CAVEInit();
   CAVEInitApplication(app_init_gl,0);
   CAVEDisplay(app_draw,0);
   app_compute_init(argc,argv);
   while (!getbutton(ESCKEY))
   {
       app_compute();
   }
   CAVEExit();
}</programlisting>
            </section>

            <section>
               <title>The Form of a Basic VR Juggler Program</title>

               <programlisting linenumbering="numbered">class MyApplication : public vrj::GlApp
{
public:
// Data callbacks  (Do not put OpenGL code here)
   virtual void init();
   virtual void preFrame();
   virtual void intraFrame();
   virtual void postFrame();
      
// OpenGL callbacks (put only OpenGL code here)
   virtual void contextInit();
   virtual void draw();
};

int main(int argc, char* argv[]) 
{
   // configure kernel with *.config files
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   for(int i=1; i&lt;argc; i++)
   {
      // loading config file passed on command line...
      kernel-&gt;loadConfigFile(argv[i]);
   }

   // start the kernel
   kernel-&gt;start();

   // set the application for the kernel to run
   MyApplication* application = new MyApplication();
   kernel-&gt;setApplication(application);

   // Block until the kernel exits.
   kernel-&gt;waitForKernelStop();

   return 0;
}</programlisting>
            </section>
         </section>
      </chapter>

      <chapter>
         <title>Porting to VR Juggler from GLUT</title>

         <indexterm>
            <primary>porting applications from</primary>

            <secondary>GLUT</secondary>
         </indexterm>

         <indexterm>
            <primary>GLUT</primary>

            <secondary>porting to VR Juggler</secondary>
         </indexterm>

         <para>In this chapter, we give some methods for porting an
         application written with GLUT to VR Juggler. Throughout, we compare
         and contrast the techniques used by VR Juggler and GLUT, and we
         translate concepts familiar to GLUT programmers into VR Juggler
         terms.</para>

         <section>
            <title>Window Creation and Management</title>

            <para>In VR Juggler, window creation is done behind the scenes
            based on configuration file settings. There are two display types:
            Surface and Simulator. A Surface Display can be put into three
            modes: stereo, right eye, or left eye. Most interesting is the
            stereo mode. Stereo mode requires special hardware to display
            stereo, and it creates the most immersive experience. A Simulator
            Display is special because it emulates an active VR system. It can
            show the all active user head positions and orientation, any
            active devices such as gloves or wands, and any Surface Displays.
            The simulator window is nice for debugging tracking systems and
            for visualizing configured Surface Displays.</para>
         </section>

         <section>
            <title>The Initialize, Draw, and Frame Routines</title>

            <bridgehead>In GLUT</bridgehead>

            <para>In GLUT, the initialize, draw, and frame routines are known
            as <glossterm linkend="gloss.callback">callbacks</glossterm>
            implemented with C function pointers. In VR juggler, the
            equivalent routines are <firstterm>called back</firstterm> using
            an application object. An application object is a C++ class that
            defines methods to encapsulate the functionality of the
            application within a single C++ object.</para>

            <itemizedlist>
               <listitem>
                  <para>Draw: OpenGL commands are placed in the draw routine.
                  The callback function is defined by passing a function
                  pointer to <function>glutDisplayFunc()</function>.</para>
               </listitem>

               <listitem>
                  <para>Frame: Operations on application data are done within
                  the frame routine. No OpenGL commands are allowed here
                  because the display window is undefined at this point. The
                  frame function is defined with
                  <function>glutIdleFunc()</function>. This function generally
                  does a <function>glutPostRedisplay()</function> to cause the
                  display callback to be executed.</para>
               </listitem>

               <listitem>
                  <para>Init: There is no callback for initialization. Data
                  initialization is done usually before the application
                  starts. Context initialization is done during the first run
                  of the function set with
                  <function>glutDisplayFunc()</function> (once for each window
                  opened).</para>
               </listitem>
            </itemizedlist>

            <bridgehead>In VR Juggler</bridgehead>

            <para>With VR Juggler, no C function pointers are necessary, but a
            pointer to an application object must be given to the VR Juggler
            kernel. As described in earlier sections of this chapter, the
            first step is to derive a new application class from
            <classname>vrj::GlApp</classname>. For more information on
            application objects, it may be helpful to review <xref
            linkend="chapter.app.basics" />. Briefly, the application class
            definition would appear similar to the following:</para>

            <programlisting>class MyApplication : public vrj::GlApp
{
   ...
};</programlisting>

            <para>The draw, frame, and initialize routine concepts in VR
            Juggler are presented in the following list.</para>

            <itemizedlist>
               <listitem>
                  <para>Draw: An application's display <quote>callback</quote>
                  function is defined by a new member function called
                  <methodname>draw()</methodname> in the derived class. This
                  is where OpenGL rendering commands such as
                  <function>glBegin()</function>,
                  <function>glVertex()</function>, etc. are placed.</para>
               </listitem>

               <listitem>
                  <para>Frame: Calculations such as navigation, collision,
                  physics, artificial intelligence, etc. are often placed in
                  the frame function. The frame function is split across three
                  member functions:</para>

                  <orderedlist>
                     <listitem>
                        <para><methodname>MyApplication::preFrame()</methodname>,
                        called before <methodname>draw()</methodname></para>
                     </listitem>

                     <listitem>
                        <para><methodname>MyApplication::intraFrame()</methodname>,
                        called during <methodname>draw()</methodname></para>
                     </listitem>

                     <listitem>
                        <para><methodname>MyApplication::postFrame()</methodname>,
                        called after <methodname>draw()</methodname></para>
                     </listitem>
                  </orderedlist>
               </listitem>

               <listitem>
                  <para>Init: There is an initialization member function for
                  data and an initialization member function for creating
                  context-specific data (display lists, texture objects). The
                  latter is called for each display context in the system.
                  These two member functions are:</para>

                  <orderedlist>
                     <listitem>
                        <para><methodname>MyApplication::init()</methodname>,
                        called once per application startup</para>
                     </listitem>

                     <listitem>
                        <para><methodname>MyApplication::contextInit()</methodname>,
                        called once per display context creation</para>
                     </listitem>
                  </orderedlist>
               </listitem>
            </itemizedlist>

            <para>Readers who find some of these concepts unfamiliar are
            encouraged to read <xref linkend="section.opengl.apps" />. For
            information about context-specific data, refer to <xref
            linkend="section.csdata.intro" />.</para>
         </section>

         <section>
            <title>Getting Input from Devices</title>

            <bridgehead>In GLUT</bridgehead>

            <para>For keyboard input, the following functions are used:</para>

            <itemizedlist>
               <listitem>
                  <para><function>glutKeyboardFunc(OnKeyboardDown)</function></para>
               </listitem>

               <listitem>
                  <para><function>glutKeyboardUpFunc(OnKeyboardUp)</function></para>
               </listitem>

               <listitem>
                  <para><function>glutSpecialFunc(OnSpecialKeyboardDown)</function></para>
               </listitem>

               <listitem>
                  <para><function>glutSpecialUpFunc(OnSpecialKeyboardUp)</function></para>
               </listitem>
            </itemizedlist>

            <para>For mouse input, the following functions are used:</para>

            <itemizedlist>
               <listitem>
                  <para><function>glutMouseFunc(OnMouseButton)</function></para>
               </listitem>

               <listitem>
                  <para><function>glutMotionFunc(OnMousePosition)</function></para>
               </listitem>

               <listitem>
                  <para><function>glutPassiveMotionFunc(OnMousePosition)</function></para>
               </listitem>
            </itemizedlist>

            <bridgehead>In VR Juggler</bridgehead>

            <para>To get device input, use the type-specific instantiations of
            <classname>gadget::DeviceInterface&lt;T&gt;</classname><indexterm>
                  <primary>classes</primary>

                  <secondary>gadget::DeviceInterface&lt;T&gt;</secondary>
               </indexterm>. They include the following:</para>

            <itemizedlist>
               <listitem>
                  <para><classname>gadget::PositionInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::PositionInterface</secondary>
                     </indexterm> for trackers and other positional
                  devices</para>
               </listitem>

               <listitem>
                  <para><classname>gadget::DigitalInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::DigitalInterface</secondary>
                     </indexterm> for buttons and other on/off devices</para>
               </listitem>

               <listitem>
                  <para><classname>gadget::AnalogInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::AnalogInterface</secondary>
                     </indexterm> for potentiometers and other multi-range
                  data devices</para>
               </listitem>

               <listitem>
                  <para><classname>gadget::KeyboardMouseInterface</classname><indexterm>
                        <primary>classes</primary>

                        <secondary>gadget::KeyboardMouseInterface</secondary>
                     </indexterm> for keyboard and mouse input</para>
               </listitem>
            </itemizedlist>

            <para>For more information about the VR Juggler device interfaces,
            refer to <xref linkend="section.gadget.proxies.devif" />. A
            tutorial on getting device input in VR Juggler applications can be
            found in <xref linkend="section.get.input" />.</para>
         </section>

         <section>
            <title>Configuration</title>

            <para>Configuration of GLUT applications is quite different than
            configuration of VR Juggler applications. In particular, VR
            Juggler is much more dynamic because configurations are maintained
            as files separate from the application. In GLUT, the configuration
            must be written into the application somehow. This can lead to
            very static, hard-coded configurations.</para>

            <bridgehead>In GLUT</bridgehead>

            <para>There is no built-in configuration system. All system
            settings are coded using the GLUT API.</para>

            <bridgehead>In VR Juggler</bridgehead>

            <para>VR Juggler has a powerful and flexible configuration system.
            As a result, it is also complex. All configurable parameters could
            be in one or more files with any names desired. VR Juggler comes
            with example configuration files that may be found in the
            directory
            <filename>$VJ_BASE_DIR/share/vrjuggler/data/configFiles</filename>.</para>

            <para>The VR Juggler configuration system is completely extensible
            and could be used outside of VR Juggler. Indeed, it could be used
            outside of any VR paradigm altogether. Refer to the VR Juggler
            <emphasis>Configuration Guide</emphasis> for more information on
            configuring VR Juggler.</para>
         </section>

         <section>
            <title>Important Notes</title>

            <para>Finally, before we get to the source code, there are some
            important notes about programming VR Juggler applications in
            general. Please read these carefully and refer to the indicated
            chapters for more information as necessary.</para>

            <section>
               <title>Shared Memory</title>

               <para>VR Juggler is multi-threaded, and it uses a shared memory
               model across all threads. Thus, when writing a VR Juggler
               application, memory can be created as in a normal,
               single-threaded C or C++ application. VR Juggler is written
               entirely in C++, and as such, new and delete must be used
               instead of <function>malloc()</function> and
               <function>free()</function>.</para>
            </section>

            <section>
               <title>OpenGL Context-Specific Data</title>

               <para>As a result of the shared memory model described above,
               VR Juggler has different requirements for context-specific data
               than GLUT. Information such as display lists and texture
               objects must be managed using context-specific data. A
               <glossterm linkend="gloss.callback">display context</glossterm>
               is the location to which OpenGL rendering commands draw.
               Compiled OpenGL commands such as display lists do not get
               shared across multiple contexts (or windows), and thus, they
               must be initialized once per display context. In a VR Juggler
               application, these OpenGL initializations must be placed in
               <methodname>vrj::GlApp::contextInit()</methodname>. It is
               called once per display context after each context has become
               active. For a more detailed description of these concepts and a
               tutorial on how to use them, please refer to <xref
               linkend="section.csdata.intro" />.</para>
            </section>
         </section>

         <section>
            <title>Source Code</title>

            <para>This final section is the heart of the porting discussion.
            We present some source code as a means to illustrate how GLUT
            concepts map to VR Juggler.</para>

            <section>
               <title>The Form of a Basic GLUT Program</title>

               <programlisting linenumbering="numbered">void main(int argc, char* argv[])
{
   /* initialize the application data here */
   OnApplicationInit();

   /* create a window to render graphics in
    * In VR Juggler, window creation is done for you based on your configuration file
    * settings.
    */
   glutInitWindowSize( 640, 480 );
   glutInit( &amp;argc, argv );
   glutInitDisplayMode( GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE );
   glutCreateWindow( "GLUT application" );

   /* display callbacks.
    * NOTE: the first time OnIdle is called is when you should 
    *       initialize the display context for each window
    *       (doing this is analogous to VR Juggler's 
    *       vrj::GlApp::contextInit() function)
    */
   glutReshapeFunc( OnReshape );
   glutIdleFunc( OnIdle );
   glutDisplayFunc( OnIdle );

   /* tell glut to not call the keyboard callback repeatedly 
    * when holding down a key. (uses edge triggering, like the mouse does)
    */
   glutIgnoreKeyRepeat( 1 );

   /* keyboard callback functions. */
   glutKeyboardFunc( OnKeyboardDown );
   glutKeyboardUpFunc( OnKeyboardUp );
   glutSpecialFunc( OnSpecialKeyboardDown );
   glutSpecialUpFunc( OnSpecialKeyboardUp );

   /* mouse callback functions... */
   glutMouseFunc( OnMouseClick );
   glutMotionFunc( OnMousePos );
   glutPassiveMotionFunc( OnMousePos );

   /* start the application loop, your callbacks will now be called
    * time for glut to sit and spin.  In Juggler this is the same as the while(1)
    * (see below)
    */
   glutMainLoop();
}</programlisting>
            </section>

            <section>
               <title>The Form of a Basic VR Juggler Program</title>

               <programlisting linenumbering="numbered">class MyApplication : public vrj::GlApp
{
public:
// Data callbacks  (Do not put OpenGL code here)
   virtual void init();
   virtual void preFrame();
   virtual void intraFrame();
   virtual void postFrame();
      
// OpenGL callbacks (put only OpenGL code here)
   virtual void contextInit();
   virtual void draw();
};

int main(int argc, char* argv[]) 
{
   // configure kernel with *.config files
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   for(int i=1; i&lt;argc; i++)
   {
      // loading config file passed on command line...
      kernel-&gt;loadConfigFile(argv[i]);
   }

   // start the kernel
   kernel-&gt;start();

   // set the application for the kernel to run
   MyApplication* application = new MyApplication();
   kernel-&gt;setApplication(application);

   // Block until the kernel exits.
   kernel-&gt;waitForKernelStop();

   return 0;
}</programlisting>
            </section>
         </section>
      </chapter>
   </part>

   <part id="part.advanced.topics">
      <title>Advanced Topics</title>

      <chapter id="chapter.system.interaction">
         <title>System Interaction</title>

         <para>In this part of the book, we present information for advanced
         users who want to create applications that take advantage of VR
         Juggler features such as threading and run-time reconfiguration.
         While we do recommend that all programmers be familiar with these
         topics, readers who are not familiar with the basic concepts of
         multi-threaded programming, for example, may find these chapters
         difficult to understand.</para>
      </chapter>

      <chapter id="chapter.multi-threading">
         <title>Multi-threading</title>

         <indexterm>
            <primary>multi-threading</primary>
         </indexterm>

         <para>In this chapter, we present how to use multi-threading within
         VR Juggler applications. Readers who are not familiar with the basic
         concepts of multi-threaded programming may find the following
         sections difficult to understand. This chapter is written with the
         assumption that readers already know the necessary background
         material and want to learn about how VR Juggler implements the
         concepts.</para>

         <section id="section.multi-threading">
            <title>Techniques</title>

            <indexterm>
               <primary>multi-threading</primary>

               <secondary>techniques</secondary>
            </indexterm>

            <para>VR Juggler is a multi-threaded software system. We have
            built up a cross-platform abstraction for threads and
            synchronization primitives as part of making VR Juggler more
            portable. This abstraction is available to application developers.
            In addition, the basic VR Juggler application object interface
            provides a mechanism for inherent parallel programming in
            applications. In this section, we provide a more detailed
            description of these techniques and how to put them into
            use.</para>

            <para>To begin the discussion on multi-threaded programming with
            VR Juggler, we describe the techniques available to application
            programmers. There are three options from which programmers may
            choose:</para>

            <orderedlist>
               <listitem>
                  <para>Use the
                  <methodname>vrj::App::intraFrame()</methodname> application
                  object member function</para>
               </listitem>

               <listitem>
                  <para>Use triple-buffered data with
                  <methodname>vrj::App::intraFrame()</methodname></para>
               </listitem>

               <listitem>
                  <para>Use triple-buffered data with separate threads</para>
               </listitem>
            </orderedlist>
         </section>

         <section id="section.tutorial.intraFrame">
            <title>Tutorial: Perform Computations Asynchronously to Rendering
            with <methodname>intraFrame()</methodname></title>

            <indexterm>
               <primary>tutorial</primary>

               <secondary>rendering and computing asynchronously using
               intraFrame()</secondary>
            </indexterm>

            <highlights>
               <para>In this section, we present a tutorial demonstrating the
               use of asynchronous processing and rendering. The tutorial
               overview is as follows:</para>

               <itemizedlist>
                  <listitem>
                     <para>Description: Performing the computations to animate
                     a mesh asynchronously to rendering the mesh.</para>
                  </listitem>

                  <listitem>
                     <para>Objectives: Understand how to use multi-threading
                     techniques in an application.</para>
                  </listitem>

                  <listitem>
                     <para>Member functions:
                     <methodname>vrj::App::init()</methodname>,
                     <methodname>vrj::App::preFrame()</methodname>,
                     <methodname>vrj::App::intraFrame()</methodname>,
                     <methodname>vrj::GlApp::draw()</methodname></para>
                  </listitem>

                  <listitem>
                     <para>Directory:
                     <filename>$VJ_BASE_DIR/share/samples/OGL/simple/MPApp</filename></para>
                  </listitem>

                  <listitem>
                     <para>Files: <filename>MPApp.h</filename>,
                     <filename>MPApp.cpp</filename>,
                     <filename>Mesh.h</filename></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <section>
               <title>Class Declaration and Data Members</title>

               <para>The following code example shows the basics of declaring
               the class interface and data members for an application that
               will use context-specific data. This is an extension of the
               simple OpenGL application presented in <xref
               linkend="section.simple.opengl.app" />. Note the addition of
               the <methodname>contextInit()</methodname> declaration and the
               use of the context-specific data member
               <varname>mCubeDlId</varname>.</para>

               <programlisting linenumbering="numbered">using namespace vrj;

class MPApp : public GlApp
{
public:
   MPApp() {;}
   virtual void init();
   virtual void preFrame();
   virtual void draw();
   virtual void intraFrame();
    ...
public:
   // The Mesh object used for computing and rendering.
   Mesh mMesh;
   ...
};</programlisting>
            </section>

            <section>
               <title>The <methodname>preFrame()</methodname> Member
               Function</title>

               <para>We now show the implementation of
               <methodname>MPApp::preFrame()</methodname>. In the initial
               version of the application, the computation for the mesh
               animation is done here.</para>

               <programlisting linenumbering="numbered">void MPApp::preFrame()
{
   mCurTime += 0.005;
   mMesh.compute(mCurTime);

   // Other once-per-frame operations follow ...
}</programlisting>

               <note>
                  <para>Note that in this example, the animation is based on
                  the frame rate. It is much better to use a time-based
                  animation scheme. For this example, however, we will keep
                  things simple.</para>
               </note>
            </section>

            <section>
               <title>The <methodname>draw()</methodname> Member
               Function</title>

               <para>When we enter <methodname>draw()</methodname>, the
               computations for this frame's animation are complete. Thus, we
               can call the <methodname>render()</methodname> method to
               display the new calculations.</para>

               <programlisting linenumbering="numbered">using namespace gmtl;

void MPApp::draw()
{
   glClear(GL_DEPTH_BUFFER_BIT);

   // --- Setup for drawing --- //
   glMatrixMode(GL_MODELVIEW);

   glColor3f(0.0f, 0.5f, 0.75f);
   glPushMatrix();
      glScalef(15.0f,15.0f,15.0f);
      glRotatef(-90.0f,1.0,0.0,0.0);
      mMesh.render();                // Render the mesh
   glPopMatrix();
}</programlisting>
            </section>

            <section>
               <title>Exercise</title>

               <para>In the tutorial application code, perform the
               computations asynchronously to the rendering process by using
               <methodname>intraFrame()</methodname>. Recall from <xref
               linkend="section.app.intraFrame" /> (in <xref
               linkend="section.app.frame.functions" />) that
               <methodname>intraFrame()</methodname> is invoked in parallel to
               the execution of <methodname>draw()</methodname>.</para>
            </section>
         </section>

         <section id="section.multi-threading.classes">
            <title>Helper Classes</title>

            <indexterm zone="section.multi-threading.classes">
               <primary>multi-threading</primary>

               <secondary>helper classes</secondary>
            </indexterm>

            <para>All the techniques presented in the previous section require
            some form of synchronization to protect the data accessed by
            multiple threads. Developers who choose the third option and use
            separate threads must learn the VR Juggler Portable Runtime (VPR)
            thread API. A full description of this API is beyond the scope of
            this book. In this section, we will describe at a high level the
            important classes. For more detailed information, refer to the
            <emphasis>VR Juggler Portable Runtime Programmer's
            Guide</emphasis>.</para>

            <section id="section.using.vprThread">
               <title><classname>vpr::Thread</classname></title>

               <indexterm zone="section.using.vprThread">
                  <primary>multi-threading</primary>

                  <secondary>vpr::Thread</secondary>
               </indexterm>

               <indexterm zone="section.using.vprThread">
                  <primary>vpr::Thread</primary>
               </indexterm>

               <para>When considering multi-threaded programming, it is
               important to know that with great power comes great
               responsibility. The power is being able to provide multiple
               threads of control in a single application. The responsibility
               is making sure those threads get along with each other and do
               not step on each other's data. VR Juggler is a multi-threaded
               library which makes it very powerful and very complex.</para>

               <para>As a cross-platform framework, VR Juggler uses an
               internal threading abstraction that provides a uniform
               interface to platform-specific threading implementations. That
               cross-platform interface is available to programmers to make
               applications multi-threaded without tying them to a specific
               operating system's threading implementation.</para>

               <para>The threading interface in VPR is modeled after the POSIX
               thread specification of POSIX.1b (formerly POSIX.4). The main
               difference is that VPR's interface is object-oriented while
               POSIX threads (pthreads) are procedural. The basic principles
               are exactly the same, however. A function (or class method) is
               provided to the <classname>vpr::Thread</classname> class, and
               that function is executed in a thread of control that is
               independent of the creating thread.</para>

               <para>Threads are spawned (initialized and begin execution)
               when the <classname>vpr::Thread</classname> constructor is
               called. That is, when instantiating a
               <classname>vpr::Thread</classname> object, a new thread of
               execution is created. The semantics of threads says that a
               thread can begin execution at any time after being created, and
               this is true with <classname>vpr::Thread</classname>s. Do not
               make any assumptions about when the thread will begin running.
               It may happen before or after the constructor returns the
               <classname>vpr::Thread</classname> object.</para>

               <para>To pass arguments to threads, the common mechanism of
               encapsulating them in a C++ <type>struct</type> must be used.
               The function executed by the thread takes only a single
               argument of type <type>void*</type>. An argument is not
               required, of course, but to pass more than one argument to a
               thread, the best way to do this is to create a structure and
               pass a pointer to it to the <classname>vpr::Thread</classname>
               constructor.</para>

               <para>Once a <classname>vpr::Thread</classname> object is
               created, it acts as an interface into controlling the thread it
               encapsulates. Thread signals can be sent, priority changes can
               be made, execution can be suspended, etc. This interface is the
               focus of this section.</para>
            </section>

            <section>
               <title><classname>vpr::BaseThreadFunctor</classname></title>

               <indexterm>
                  <primary>vpr::BaseThreadFunctor</primary>

                  <seealso>vpr::ThreadMemberFunctor,
                  vpr::ThreadNonMemberFunctor</seealso>
               </indexterm>

               <para>In this section, we explain the concept and use of
               functors. As with much of VR Juggler, a functor is a high-level
               concept that encapsulates something quite simple. A functor is
               defined as <quote>something that performs an operation or a
               function.</quote> While this is not very detailed, it is clear
               and concise. In VPR, functors can be used as the code executed
               by a thread.</para>

               <para>In VPR, a functor is simply another object type that
               happens to encapsulate a user-defined function. The details on
               how this is done are not important here, but they are provided
               later for those who are interested. What is important to know
               is that a functor can be thought of as a normal function. When
               using them, programmers simply implement a function and then
               pass the function pointer (and the function's optional
               argument) to the functor's constructor. The object does the
               rest.</para>

               <para>Observant readers may have noticed the parenthetical
               phrase in the previous paragraph mentioning a function's
               optional argument. Note that <quote>argument</quote> is
               singular meaning that only one parameter can be passed to the
               function that will be run by the created thread. The type of
               that argument is the wonderfully vague <type>void*</type>, an
               artifact of basing the threading subsystem on C libraries. As
               discussed in the section on using
               <classname>vpr::Thread</classname>s, if there is a need to pass
               multiple arguments, they must be encapsulated in a struct or a
               comparable object.</para>

               <para>Once a functor object exists, it is passed to the
               <classname>vpr::Thread</classname> constructor, and the new
               thread will execute the functor (which knows about the
               function). The end result is the same as using a normal C/C++
               function or a static class member function, but there is one
               special benefit: with functors, non-static class member
               functions can be passed. In many cases, there arises a need to
               run a member function in a separate thread, but making it
               static is infeasible or awkward. Thus, it would be best to pass
               a non-static member function to the created thread. To get
               access to the non-static data members, however, the C++
               <varname>this</varname> pointer must be available to the
               thread. By using a VPR functor, that is all handled behind the
               scenes so that passing a non-static member function is
               straightforward.</para>
            </section>

            <section>
               <title>Using the <classname>vpr::Semaphore</classname>
               Interface</title>

               <indexterm>
                  <primary>vpr::Semaphore</primary>
               </indexterm>

               <para>The most important part of multi-threaded programming is
               proper thread synchronization so that access to shared data is
               controlled. Doing so results in consistency among all threads.
               Semaphores are a very common synchronization mechanism and have
               been used widely in concurrent systems. This short section
               describes the cross-platform semaphore interface provided with
               and used by VPR. It does not explain what semaphores are or how
               to use them—it is assumed that readers are already familiar
               with the topic lest they probably would not be reading this
               chapter on advanced classes at all.</para>

               <para>As with threads, a cross-platform abstraction layer has
               been written into VPR to provide a consistent way to use
               semaphores on all supported platforms. The primary goal behind
               the interface design is to provide the common
               <emphasis>P</emphasis> (acquire) and <emphasis>V</emphasis>
               (release) operations. A given semaphore controls access to
               <emphasis>n</emphasis> resources. Thus, n threads can acquire a
               semaphore without blocking, but the <emphasis>n</emphasis> + 1
               attempt to acquire the semaphore will block until a resource
               release occurs. The interface does include methods for
               read/write semaphores, but as of this writing, that part of the
               interface is not complete.</para>
            </section>

            <section id="section.using.vprMutex">
               <title>Using the <classname>vpr::Mutex</classname>
               Interface</title>

               <indexterm>
                  <primary>vpr::Mutex</primary>
               </indexterm>

               <para>In addition to cross-platform semaphores, VPR provides an
               abstraction for cross-platform mutexes. Mutexes are a special
               type of semaphore known as a binary semaphore. Exactly one
               thread can hold the lock at any time. This very short section,
               however, is not about mutexes but rather about the
               <classname>vpr::Mutex</classname> interface provided with VPR
               and used by VR Juggler.</para>

               <para>The cross-platform mutex abstraction in VPR is critical
               for synchronizing access to shared data. Those who have read
               the section on <classname>vpr::Semaphore</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>vpr::Semaphore</secondary>
                  </indexterm> will find this section very, very familiar. The
               interface for <classname>vpr::Mutex</classname> is a subset of
               that for <classname>vpr::Semaphore</classname> since mutexes
               are binary semaphores. In other words, they control access to
               exactly one resource. They can be locked and unlocked. That is
               all there is to know. The <classname>vpr::Mutex</classname>
               interface does include some methods for read/write mutexes, but
               this implementation is incomplete and is not documented here
               for that reason. When the implementation is finished, this
               documentation will be expanded.</para>
            </section>
         </section>

         <section>
            <title>Using Data Buffering</title>

            <para>In the reader exercise from <xref
            linkend="section.tutorial.intraFrame" />, we do not suggest the
            use of mutexes to protect access to the data modified in
            <methodname>intraFrame()</methodname> and rendered in
            <methodname>draw()</methodname>. When the mesh is rendered, some
            tearing will almost certainly be seen. This happens as a result of
            data changing during the rendering of the data. In other words,
            access to a <glossterm linkend="gloss.critical.section">critical
            section</glossterm> of code not being controlled. To prevent
            tearing, we need to protect the internal mesh data. However, using
            a mutex to control access to the mesh will result in the
            computation and rendering being serialized. In so doing, we lose
            the value of parallelizing the computation and rendering.</para>

            <section id="section.triple.buffering">
               <title>Triple Buffering</title>

               <indexterm zone="section.triple.buffering">
                  <primary>triple buffering</primary>

                  <secondary>definition</secondary>
               </indexterm>

               <para>To work around this, we can use multiple buffers. More
               specifically, we will use three buffers: one for reading, one
               for writing, and one as temporary storage of the most recently
               completed write(s). This is called <glossterm
               linkend="gloss.triple.buffering">triple buffering</glossterm>,
               and it allows us to perform computation and rendering in
               parallel without causing one process to wait on the other. The
               rendering buffer can be accessed without locking, as can the
               computation buffer. The only time a lock must be held is when
               the latest computations are copied into the temporary storage
               buffer or when the contents of the temporary storage buffer are
               copied into the rendering buffer. Thus, the key to triple
               buffering is the temporary storage buffer.</para>

               <para>Implementing triple buffering is relatively
               straightforward, once the basic idea is understood. For this
               discussion we will refer to the buffers as follows:</para>

               <orderedlist>
                  <listitem>
                     <para><firstterm>Stable</firstterm>: The buffer from
                     which the most recent data will be read</para>
                  </listitem>

                  <listitem>
                     <para><firstterm>Working</firstterm>: The buffer into
                     which the current data will be written</para>
                  </listitem>

                  <listitem>
                     <para><firstterm>Working Copy</firstterm>: The buffer
                     used to store the last completed write results
                     temporarily</para>
                  </listitem>
               </orderedlist>

               <para>Of the three, Working Copy is the only one that is shared
               between the threads, and thus, only one mutex must be used. The
               mutex must be locked when swapping the contents of Stable and
               Working Copy and when swapping the contents of Working and
               Working Copy. No lock must be held when reading from Stable or
               when writing to Working. This is where the major benefit of
               triple buffering is realized.</para>

               <para>In the thread that will write to Working, the
               implementation will follow this basic structure:</para>

               <programlisting>while ( KeepWriting )
{
   Write to Working

   Lock Working Copy mutex
      Swap Working and Working Copy
   Unlock Working Copy mutex
}</programlisting>

               <para>In the thread that will read from Stable, the
               implementation is (roughly) the reverse:</para>

               <programlisting>while ( KeepReading )
{
   Lock Working Copy mutex
      Swap Stable and Working Copy
   Unlock Working Copy mutex

   Read from Stable
}</programlisting>
            </section>

            <section id="section.optimize.tribuffer">
               <title>Optimizing Triple Buffering</title>

               <indexterm zone="section.optimize.tribuffer">
                  <primary>triple buffering</primary>

                  <secondary>optimization of</secondary>
               </indexterm>

               <para>It is possible to optimize triple buffering to reduce the
               amount of time spent in the locked section. Instead of swapping
               the buffers, we can swap the pointers to the buffers. The
               result is that we only have to swap (up to) eight bytes of
               memory, regardless of the size of the actual data.</para>

               <para>A very simple way to implement this is to use a
               three-element array to hold the buffers and three variables to
               use as the indices into the array. The variables can be named
               <varname>stable</varname>, <varname>working</varname>, and
               <varname>working_copy</varname>, for example. All accesses into
               the array of buffers use one of those three values. In other
               words, the thread reading from Stable will use
               <varname>buffer[stable]</varname> to get its buffer. Similarly,
               the thread writing to Working will use
               <varname>buffer[working]</varname>. Swapping the buffers simply
               involves changing the values of <varname>stable</varname> and
               <varname>working_copy</varname> or <varname>working</varname>
               and <varname>working_copy</varname>.</para>

               <para>In the thread that will perform the writing, the
               pseudo-code for swapping is as follows:</para>

               <programlisting>Lock Working Copy mutex
   temp = working
   working = working_copy
   working_copy = working
Unlock Working Copy Mutex</programlisting>

               <para>Similarly, in the thread that will perform the reading,
               the pseudo-code for swapping is as follows:</para>

               <programlisting>Lock Working Copy mutex
   temp = stable
   stable = working_copy
   working_copy = stable
Unlock Working Copy Mutex</programlisting>

               <para>In these examples, it takes three memory copies to swap
               the two values. Use of the temporary storage is required (at
               the C/C++ level), and thus, swapping the memory cannot be done
               any faster, regardless of the size of the data buffers.</para>
            </section>

            <section id="section.app.tribuffer">
               <title>Using Triple Buffering in an Application</title>

               <indexterm zone="section.app.tribuffer">
                  <primary>triple buffering</primary>

                  <secondary>using in an application</secondary>
               </indexterm>

               <para>Triple buffering can be used in VR Juggler applications
               in two ways: in <methodname>intraFrame()</methodname> or in a
               separate thread. In both cases, the operations will happen
               asynchronously to the <methodname>draw()</methodname> thread,
               so the uses are <emphasis>roughly</emphasis> equivalent. Using
               <methodname>intraFrame()</methodname> is easier than creating a
               separate thread because the parallel processing comes
               <quote>for free</quote> with
               <methodname>intraFrame()</methodname>. No special actions must
               be taken on the part of the application developer. Programmers
               must keep in mind, however, that if the computations will take
               longer than the rendering, the application frame rate will
               drop. This is because the next frame cannot start until after
               <methodname>intraFrame()</methodname> completes. Thus, using a
               thread will increase the complexity of the application code
               somewhat, but it will ensure that the frame rate will not be
               adversely affected.</para>
            </section>

            <section>
               <title>Tutorial: Perform Computations Using Triple
               Buffering</title>

               <indexterm>
                  <primary>tutorial</primary>

                  <secondary>rendering and computing using triple
                  buffering</secondary>
               </indexterm>

               <para>In this tutorial, we will use MPApp again to do parallel
               computation and rendering. This time, however, we will use
               triple-buffered, protected data instead of simply writing in
               <methodname>intraFrame()</methodname> and reading
               (simultaneously) in <methodname>draw()</methodname>. It will be
               best to begin with an unmodified version of MPApp to ensure
               that no changes made for the previous tutorial affect this
               exercise.</para>

               <para>Using the information presented earlier in this section,
               the exercise is to extend the <classname>Mesh</classname> class
               (found in <filename>Mesh.h</filename>) so that it uses triple
               buffering for computation and rendering. It is up to the reader
               to decide whether to use threads (refer to the documentation
               for <classname>vpr::Thread</classname> in <xref
               linkend="section.using.vprThread" /> and in the online
               <emphasis>Programmer Reference</emphasis>) or to use
               <methodname>intraFrame()</methodname>. Either way, a single
               <classname>vpr::Mutex</classname> instance will be needed, so
               it may be helpful to review <xref
               linkend="section.using.vprMutex" /> as well.</para>
            </section>
         </section>
      </chapter>

      <chapter id="chapter.runtime.reconfig">
         <title>Run-Time Reconfiguration</title>

         <indexterm>
            <primary>run-time reconfiguration</primary>
         </indexterm>

         <para>In this chapter, we introduce run-time reconfiguration, one of
         the most powerful features of VR Juggler. We will give an overview of
         how it works before proceeding into how to use it. The idea here is
         to introduce the concepts, justify the value of run-time
         reconfiguration, and then present its use so that developers can take
         full advantage of this feature.</para>

         <section>
            <title>How Run-Time Reconfiguration Works</title>

            <para></para>
         </section>

         <section>
            <title>Reasons to Use Run-Time Reconfiguration</title>

            <para></para>
         </section>

         <section>
            <title>Using Run-Time Reconfiguration in an Application</title>

            <indexterm>
               <primary>run-time reconfiguration</primary>

               <secondary>use in application</secondary>
            </indexterm>

            <para>There are four steps involved in adding run-time
            reconfiguration to a VR Juggler application. We describe each of
            them in detail here in the following subsections.</para>

            <section>
               <title>Create Application-Specific Configuration
               Definitions</title>

               <para>The first step in adding dynamic reconfiguration
               capabilities to an application is to decide what aspects of the
               application should be configurable. Naturally, this is very
               application-specific, but some of the following choices are
               common:</para>

               <itemizedlist>
                  <listitem>
                     <para>Initial parameters (position, color, etc.) of
                     objects in the environment</para>
                  </listitem>

                  <listitem>
                     <para>Navigational position</para>
                  </listitem>

                  <listitem>
                     <para>Global settings such as difficulty level of a game,
                     or network settings for a distributed application</para>
                  </listitem>
               </itemizedlist>

               <para>Once decisions are made regarding configuration
               information, it is time to define the kinds of configuration
               elements that will contain it. This essentially means creating
               a file containing one or more configuration definitions. To
               understand this better, consider the following example. One
               might define an <quote>Object</quote> definition in an
               application. The definition would have properties that include
               the name and type of an object, its color and size, and so
               forth.</para>

               <para>There are several ways to ensure that custom
               configuration definitions are read by the application. One way
               is to load the definition file explicitly (described below),
               but the simplest way is to include the custom definition file
               from one of the configuration files the application loads at
               startup. Instructions for editing configuration definition
               files and creating new kinds of definitions are included in the
               <emphasis>VRJConfig User's Guide</emphasis>.</para>
            </section>

            <section>
               <title>Implement the Dynamic Reconfiguration Interface</title>

               <para>The next step is to implement the dynamic reconfiguration
               interface for the application object. This interface is defined
               by the
               <classname>jccl::ConfigElementHandler</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>jccl::ConfigElementHandler</secondary>
                  </indexterm> class and consists of three methods:</para>

               <orderedlist>
                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>

                        <type>bool</type>

                        <methodname>configCanHandle</methodname>

                        <methodparam>
                           <type>jccl::ConfigElementPtr</type>

                           <parameter>element</parameter>
                        </methodparam>
                     </methodsynopsis>

                     <indexterm>
                        <primary>vrj::App</primary>

                        <secondary>configCanHandle() method</secondary>
                     </indexterm>

                     <para>This function should simply return a Boolean (true
                     or false) depending on whether this object knows how to
                     deal with the configuration element passed to it. If this
                     element uses an application-custom definition, this
                     should return <constant>true</constant>. For
                     example:</para>

                     <programlisting>std::string s = element-&gt;getType();

if ( !jccl::strcasecmp(s, "my_custom_element_type") )
{
   return true;
}</programlisting>
                  </listitem>

                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>

                        <type>bool</type>

                        <methodname>configAdd</methodname>

                        <methodparam>
                           <type>jccl::ConfigElementPtr</type>

                           <parameter>element</parameter>
                        </methodparam>
                     </methodsynopsis>

                     <indexterm>
                        <primary>vrj::App</primary>

                        <secondary>configAdd() method</secondary>
                     </indexterm>

                     <para>This method is called whenever an element is added
                     to the application, whether by loading a configuration
                     file or through a dynamic reconfiguration event. Prior to
                     this, the element will have been passed through the
                     application object's
                     <methodname>configCanHandle()</methodname> method. Thus,
                     when <methodname>configAdd()</methodname> is called, the
                     element is destined for the application object.</para>

                     <para>When <methodname>configAdd()</methodname> is
                     called, the application should look at the element passed
                     to it and decide what to do. This might involve creating
                     a new object, changing the configuration of an extant
                     object, changing the values of certain variables, or any
                     number of other possibilities. This flexibility is part
                     of the power of dynamic reconfiguration with VR
                     Juggler.</para>
                  </listitem>

                  <listitem>
                     <methodsynopsis>
                        <modifier>virtual</modifier>

                        <type>bool</type>

                        <methodname>configRemove</methodname>

                        <methodparam>
                           <type>jccl::ConfigElementPtr</type>

                           <parameter>element</parameter>
                        </methodparam>
                     </methodsynopsis>

                     <indexterm>
                        <primary>vrj::App</primary>

                        <secondary>configRemove() method</secondary>
                     </indexterm>

                     <para>This method is analogous to
                     <methodname>configAdd()</methodname>. It is called when
                     VR Juggler receives a command to remove a particular
                     configuration element. If the element refers to a
                     specific object in the application, the most obvious
                     behavior would be to remove that particular object. If
                     the element refers to some other properties of the
                     application, there are several choices for the correct
                     behavior. For example, one might choose to reset those
                     properties to their default values. In some cases, it may
                     be desirable or necessary to ignore the remove
                     request.</para>
                  </listitem>
               </orderedlist>
            </section>

            <section>
               <title>Procesing Configuration Elements</title>

               <para>When an application receives a configuration element to
               process via <methodname>configAdd()</methodname> or
               <methodname>configRemove()</methodname>, it needs to retrieve
               the data in that element in order to decide what to do.
               Configuration elements can be very complex, but the interface
               has been designed to be as simple as possible. We now describe
               a few of the most important methods in the
               <classname>jccl::ConfigElement</classname> API.</para>

               <itemizedlist>
                  <listitem>
                     <methodsynopsis>
                        <type>std::string</type>

                        <methodname>jccl::ConfigElement::getID</methodname>

                        <void />

                        <modifier>const</modifier>
                     </methodsynopsis>

                     <indexterm>
                        <primary>jccl::ConfigElement</primary>

                        <secondary>getID() method</secondary>
                     </indexterm>

                     <para>This method returns the token of the configuration
                     definition which describes this element. This is useful
                     if an application uses several kinds of custom element
                     types. With this method, it is possible to distinguish
                     one from another.</para>
                  </listitem>

                  <listitem>
                     <methodsynopsis>
                        <type>T</type>

                        <methodname>jccl::ConfigElement::getProperty&lt;T&gt;</methodname>

                        <methodparam>
                           <type>std::string&amp;</type>

                           <parameter>propertyToken</parameter>
                        </methodparam>

                        <methodparam>
                           <type>int</type>

                           <parameter>num</parameter>
                        </methodparam>
                     </methodsynopsis>

                     <indexterm>
                        <primary>jccl::ConfigElement</primary>

                        <secondary>getProperty&lt;T&gt;() method</secondary>
                     </indexterm>

                     <para>This is the key method for getting the information
                     contained in a configuration element. Its arguments are
                     the token associated with a property and a numeric index.
                     For example, a property might store a coordinate with
                     three values, each of which can be accessed separately by
                     using the numbers 0, 1, or 2 for the
                     <varname>num</varname> parameter.</para>

                     <para>The return value and the template parameter for
                     this method need some explanation. Basically, the return
                     value of <methodname>getProperty()</methodname> is cast
                     to whichever type the caller expects to receive. This
                     type is named using the template paramter. (It is assumed
                     that the caller knows the types of values stored in a
                     given property.) The use of the template paramter allows
                     any type to be used through the type-specific
                     specialization performed by the C++ compiler. The
                     following code fragment gives a few examples of this
                     usage:</para>

                     <programlisting>std::string s1 = element-&gt;getProperty&lt;std::string&gt;("name", 0);

bool b = element-&gt;getProperty&lt;bool&gt;("enabled");
std::string s3 = element-&gt;getProperty&lt;std::string&gt;("enabled");
// s3 will be one of the strings "0" or "1"

jccl::ConfigElementPtr elt = element-&gt;getProperty&lt;jccl::ConfigElementPtr&gt;("child_element", 2);</programlisting>
                  </listitem>

                  <listitem>
                     <methodsynopsis>
                        <type>int</type>

                        <methodname>jccl::ConfigElement::getNum</methodname>

                        <methodparam>
                           <modifier>const</modifier>

                           <type>std::string&amp;</type>

                           <parameter>propertyToken</parameter>
                        </methodparam>

                        <modifier>const</modifier>
                     </methodsynopsis>

                     <indexterm>
                        <primary>jccl::ConfigElement</primary>

                        <secondary>getNum() method</secondary>
                     </indexterm>

                     <para>Sometimes properties of a configuration element can
                     have a variable number of values. A good example is a
                     property that lists a set of files to be loaded. The
                     <methodname>getNum()</methodname> method returns the
                     actual number of values of the named property.</para>
                  </listitem>
               </itemizedlist>

               <para>For definitive information about the
               <classname>jccl::ConfigElement</classname> API, refer to the
               JCCL <emphasis>Programmer's Reference</emphasis>.</para>
            </section>

            <section>
               <title>Loading and Saving Configurations</title>

               <para></para>
            </section>
         </section>

         <section id="section.app.specific.config">
            <title>Tutorial: Using Application-Specific Configurations</title>

            <indexterm>
               <primary>tutorial</primary>

               <secondary>using application-specific
               configurations</secondary>
            </indexterm>

            <highlights>
               <para>In this section, we present a tutorial covering the use
               of application-specific configurations. The tutorial overview
               is as follows:</para>

               <itemizedlist>
                  <listitem>
                     <para>Description: Simple OpenGL application that draws a
                     cube in the environment.</para>
                  </listitem>

                  <listitem>
                     <para>Objectives: Understand how the
                     <methodname>configCanHandle()</methodname> and
                     <methodname>configAdd()</methodname> member functions in
                     <classname>jccl::ConfigElementHandler</classname> work;
                     create application-specific configurations using
                     JCCL</para>
                  </listitem>

                  <listitem>
                     <para>Member functions:
                     <methodname>jccl::ConfigElementHandler::configCanHandle()</methodname>,
                     <methodname>jccl::ConfigElementHandler::configAdd()</methodname>,
                     <methodname>vrj::GlApp::draw()</methodname></para>
                  </listitem>

                  <listitem>
                     <para>Directory:
                     <filename>$VJ_BASE_DIR/share/samples/OGL/simple/ConfigApp</filename></para>
                  </listitem>

                  <listitem>
                     <para>Files: <filename>config_app.jdef</filename>,
                     <filename>ConfigApp.jconf</filename>,
                     <filename>ConfigApp.h</filename>,
                     <filename>ConfigApp.cpp</filename></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <section>
               <title>Class Declaration</title>

               <para>The following application class is called
               <classname>ConfigApp</classname>. It is derived from
               <classname>vrj::GlApp</classname> and has custom
               <methodname>configCanHandle()</methodname>,
               <methodname>configAdd()</methodname>,
               <methodname>init()</methodname>, and
               <methodname>draw()</methodname> methods declared. Note that the
               application declares several device interface members that are
               used by the application for getting device data.</para>

               <programlisting linenumbering="numbered">using namespace vrj;
using namespace gadget;

class simpleApp : public GlApp
{
public:
   simpleApp();
   virtual bool configCanHandle(jccl::ConfigElementPtr element);
   virtual bool configAdd(jccl::ConfigElementPtr element);
   virtual void init();
   virtual void draw();

public:
   PositionInterface mWand;
   DigitalInterface mButtons[3];

   GLfloat mSurfaceColor_ll[3];
   GLfloat mSurfaceColor_lr[3];
   GLfloat mSurfaceColor_ur[3];
   GLfloat mSurfaceColor_ul[3];
};</programlisting>
            </section>

            <section>
               <title>Application Configuration</title>

               <note>
                  <para>Readers unfamiliar with the JCCL terminology should
                  refer to the JCCL documentation. We will not attempt to give
                  a full explanation of how JCCL works here.</para>
               </note>

               <para>In the example application ConfigApp, we will see how to
               configure the color of the ground in the 3D scene using JCCL.
               The configuration is based on a configuration element
               definition that defines four properties, each with three
               values. The ground is defined as a rectangular polygon, and
               each property corresponds to one of the corners of the
               rectangle. The values of the property are the red, green, and
               blue values for the color of the corresponding corner
               vertex.</para>

               <para>In <xref linkend="example.config_app.jdef" />, we show
               all of <filename>config_app.jdef</filename>. This contains many
               key pieces of information. The <quote>name</quote> attribute
               defines the type of the configuration element(s) that will
               appear in a configuration file. In our case, our config element
               type is <quote>config_app.</quote> Under the
               <sgmltag>definition_version</sgmltag> tag, the category for our
               configuration element is defined to be
               <quote>Application.</quote> This is done to indicate that this
               is an application-specific configuration definition. Finally,
               we see the property description for the corner colors, each of
               which has three floating-point values. The values have defaults
               of 1.0 for red, 0.0 for green, and 0.0 for blue. As such, the
               lower left corner vertex color defaults to red. The property
               definitions for the other three corners are similar.</para>

               <example id="example.config_app.jdef">
                  <title>Complete listing of
                  <filename>config_app.jdef</filename></title>

                  <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings definition.version="3.1"?&gt;
&lt;definition xmlns="http://www.vrjuggler.org/jccl/xsd/3.1/definition"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.1/definition http://www.vrjuggler.org/jccl/xsd/3.1/definition.xsd"
            name="config_app"&gt;
   &lt;definition_version version="1" label="ConfigApp configuration"&gt;
      &lt;help&gt;This is an application-specific configuration definition for use with the ConfigApp OpenGL sample application.&lt;/help&gt;
      &lt;parent/&gt;
      &lt;category&gt;/Application&lt;/category&gt;
      &lt;property valuetype="float" variable="false" name="lower_left_color"&gt;
         &lt;help&gt;Specifies the RGB values for the lower left corner color.&lt;/help&gt;
         &lt;value label="Red value" defaultvalue="1.0"/&gt;
         &lt;value label="Green value" defaultvalue="0.0"/&gt;
         &lt;value label="Blue value" defaultvalue="0.0"/&gt;
      &lt;/property&gt;
      &lt;property valuetype="float" variable="false" name="lower_right_color"&gt;
         &lt;help&gt;Specifies the RGB values for the lower right corner color.&lt;/help&gt;
         &lt;value label="Red value" defaultvalue="1.0"/&gt;
         &lt;value label="Green value" defaultvalue="0.0"/&gt;
         &lt;value label="Blue value" defaultvalue="0.0"/&gt;
      &lt;/property&gt;
      &lt;property valuetype="float" variable="false" name="upper_right_color"&gt;
         &lt;help&gt;Specifies the RGB values for the upper right corner color.&lt;/help&gt;
         &lt;value label="Red value" defaultvalue="1.0"/&gt;
         &lt;value label="Green value" defaultvalue="0.0 "/&gt;
         &lt;value label="Blue value" defaultvalue="0.0"/&gt;
      &lt;/property&gt;
      &lt;property valuetype="float" variable="false" name="upper_left_color"&gt;
         &lt;help&gt;Specifies the RGB values for the upper left corner color.&lt;/help&gt;
         &lt;value label="Red value" defaultvalue="1.0"/&gt;
         &lt;value label="Green value" defaultvalue="0.0 "/&gt;
         &lt;value label="Blue value" defaultvalue="0.0"/&gt;
      &lt;/property&gt;
      &lt;upgrade_transform/&gt;
   &lt;/definition_version&gt;
&lt;/definition&gt;
</programlisting>
               </example>

               <para>Using this configuration definition, we can create an
               instance of our configuration type in a configuration file. An
               example instance is shown in <xref
               linkend="example.ConfigApp.jconf" />. Here, we see the
               configuration for all four corners of the rectangular ground
               polygon. Note also that no special steps have to be taken in
               the configuration file to load the definition file. This is
               handled automatically by the JCCL Configuration Manager as long
               as the environment variable
               <envar>$JCCL_DEFINITION_PATH</envar> includes the directory
               where <filename>config_app.jdef</filename> sits. A typical way
               of setting this environment variable for this application would
               be the following:</para>

               <screen>% JCCL_DEFINITION_PATH = $VJ_BASE_DIR/share/data/definitions:$VJ_BASE_DIR/share/samples/OGL/simple/ConfigApp</screen>

               <tip>
                  <para>If the syntax above for setting an environment
                  variable does not seem familiar, refer to the chapter titled
                  <quote>Environment Variables</quote> in the VR Juggler
                  <emphasis>Getting Started Guide</emphasis> for a description
                  of this shell-agnostic form.</para>
               </tip>

               <caution>
                  <para>It is critical that
                  $VJ_BASE_DIR/share/data/definitions be included or else all
                  the <quote>core</quote> <filename>.jdef</filename> files
                  will not be found by the Configuration Manager at run
                  time.</para>
               </caution>

               <example id="example.ConfigApp.jconf">
                  <title><filename>ConfigApp.jconf</filename></title>

                  <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings configuration.version="3.0"?&gt;
&lt;configuration xmlns="http://www.vrjuggler.org/jccl/xsd/3.0/configuration"
               name="ConfigApp Example Configuration"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.0/configuration http://www.vrjuggler.org/jccl/xsd/3.0/configuration.xsd"&gt;
   &lt;elements&gt;
      &lt;config_app name="Config App Example" version="1"&gt;
         &lt;lower_left_color&gt;1.0&lt;/lower_left_color&gt;
         &lt;lower_left_color&gt;0.0&lt;/lower_left_color&gt;
         &lt;lower_left_color&gt;0.0&lt;/lower_left_color&gt;
         &lt;lower_right_color&gt;1.0&lt;/lower_right_color&gt;
         &lt;lower_right_color&gt;1.0&lt;/lower_right_color&gt;
         &lt;lower_right_color&gt;0.0&lt;/lower_right_color&gt;
         &lt;upper_right_color&gt;0.0&lt;/upper_right_color&gt;
         &lt;upper_right_color&gt;1.0&lt;/upper_right_color&gt;
         &lt;upper_right_color&gt;0.0&lt;/upper_right_color&gt;
         &lt;upper_left_color&gt;0.0&lt;/upper_left_color&gt;
         &lt;upper_left_color&gt;0.0&lt;/upper_left_color&gt;
         &lt;upper_left_color&gt;1.0&lt;/upper_left_color&gt;
      &lt;/config_app&gt;
   &lt;/elements&gt;
&lt;/configuration&gt;
</programlisting>
               </example>
            </section>

            <section>
               <title>The <methodname>configCanHandle()</methodname> Member
               Function</title>

               <para>The implementation of
               <methodname>configCanHandle()</methodname> is located in
               <filename>ConfigApp.cpp</filename>. It will be invoked whenever
               a new configuration element is found, and its job is to tell
               the JCCL Configuration Manager if it can be handled or not. The
               full implementation is as follows:</para>

               <programlisting>bool ConfigApp::configCanHandle(jccl::ConfigElementPtr element)
{
   const std::string my_type("config_app");

   return (my_type == element-&gt;getID());
}
</programlisting>

               <para>We define the element type that the application knows how
               to handle (named <quote>ConfigApp</quote>, as shown above), and
               we return <constant>true</constant> if that type matches the
               type of the newly loaded configuration element.</para>
            </section>

            <section>
               <title>The <methodname>configAdd()</methodname> Member
               Function</title>

               <para>When a configuration element matching our type is loaded,
               the method <methodname>configAdd()</methodname> is invoked. The
               parameter passed in is the full configuration element that was
               loaded. The job of <methodname>configAdd()</methodname> is to
               read the information from the configuration element and
               configure the application based on what is read. In this
               specific case, we will read color information used for coloring
               the ground polygon in the scene. A partial implementation of
               <methodname>ConfigApp::configAdd()</methodname> follows:</para>

               <programlisting>bool ConfigApp::configAdd(jccl::ConfigElementPtr element)
{
   const std::string ll_color("lower_left_color");

   // Get the color settings for the lower left corner (ll).
   for ( int i = 0; i &lt; element-&gt;getNum(ll_color); ++i )
   {
      mSurfaceColor_ll[i] = element-&gt;getProperty&lt;float&gt;(ll_color, i);
   }

   // Get the color settings for the other three corners ...
}</programlisting>

               <para>Note that we are reading the values from the property
               named <quote>lower_left_color.</quote> While we know that there
               are three (3) values to read, we ask the configuration how many
               values it has just to be safe.</para>
            </section>

            <section>
               <title>The <methodname>draw()</methodname> Member
               Function</title>

               <para>For this application, the draw() member function is not
               terribly interesting. It renders the ground, and the colors for
               the four vertices are set using the member variables. Of
               course, the values for these member variables are set using the
               configuration file, and that is the interesting aspect.</para>
            </section>

            <section>
               <title>Exercise</title>

               <para></para>
            </section>
         </section>
      </chapter>

      <chapter id="chapter.extend.vrjuggler">
         <title>Extending VR Juggler</title>

         <indexterm zone="chapter.extend.vrjuggler">
            <primary>VR Juggler</primary>

            <secondary>extension of</secondary>
         </indexterm>

         <indexterm zone="chapter.extend.vrjuggler">
            <primary>extending VR Juggler</primary>
         </indexterm>

         <para>VR Juggler can be extended in ways beyond the application
         object. In this chapter, we review points of extensibility briefly
         and provide pointers to more complete information for interested
         readers.</para>

         <section id="section.device.driver.ext">
            <title>Device Drivers</title>

            <indexterm zone="section.device.driver.ext">
               <primary>device drivers</primary>

               <secondary>adding</secondary>
            </indexterm>

            <indexterm zone="section.device.driver.ext">
               <primary>extending VR Juggler</primary>

               <secondary>device drivers</secondary>
            </indexterm>

            <para>Please refer to the <ulink
            url="http://www.vrjuggler.org/gadgeteer/docs.php">Gadgeteer</ulink>
            <emphasis>Device Driver Authoring Guide</emphasis> for a
            comprehensive description of how to write device drivers for use
            with VR Juggler applications.</para>
         </section>

         <section id="section.custom.simulator.ext">
            <title>Custom Simulators</title>

            <indexterm zone="section.custom.simulator.ext">
               <primary>custom simulators</primary>

               <secondary>adding</secondary>
            </indexterm>

            <indexterm zone="section.custom.simulator.ext">
               <primary>extending VR Juggler</primary>

               <secondary>custom simulators</secondary>
            </indexterm>

            <para>To learn about how to add custom simulators to VR Juggler,
            please refer to the VR Juggler <emphasis>Extension
            Guide</emphasis>.</para>
         </section>

         <section id="section.simulator.draw.functors.ext">
            <title>Simulator Components</title>

            <indexterm zone="section.simulator.draw.functors.ext">
               <primary>simulator components</primary>

               <secondary>customizing</secondary>
            </indexterm>

            <indexterm zone="section.simulator.draw.functors.ext">
               <primary>extending VR Juggler</primary>

               <secondary>simulator components</secondary>
            </indexterm>

            <para>The basic simulator for the OpenGL Draw Manager uses draw
            functors to render the simulator components including the head and
            the wand. Users can provide their own draw functors to customize
            the look of the basic simulator without going to the trouble of
            writing a custom simulator.</para>
         </section>
      </chapter>

      <chapter>
         <title>Advanced Topics</title>

         <para>In this chapter, we address topics that are considered to be
         for advanced uses of VR Juggler. This is not to say that they are
         difficult concepts or hard-to-use features. Rather, they are not
         things that the average VR Juggler application programmer will do or
         even need to be aware of when writing VR software. These are
         important, interesting, and worthwhile topics nonetheless.</para>

         <section>
            <title>Customizing Render Thread Processor Affinity</title>

            <para>VR Juggler 2.2.1 introduced the feature of adjustable render
            thread processor affinity for Linux and IRIX users of the OpenGL
            Draw Manager. The default mechanism for defining processor
            affinity is based on an environment variable and the use of a
            simple round-robin scheme for the case of having more graphics
            pipes than processors. More tailored uses of render thread
            processor affinity can be achieved by giving the OpenGL Draw
            Manager a custom affinity assignment algorithm. That will be the
            topic of this section.</para>

            <para>The OpenGL Draw Manager class
            <classname>vrj::GlDrawManager</classname> has a method named
            <methodname>setCpuAffinityStrategy()</methodname> that takes as
            its argument a callable object. This is encapsulated using a
            Boost.Function object of type <type>boost::function&lt;int (const
            unsigned int)&gt;</type>, which in English is a function that
            takes a single constant unsigned integer (the pipe identifier) and
            returns a signed integer (the processor identifier). Anything that
            can be encapsulated by a Boost.Function object can be used. That
            includes a pointer to a C function, a pointer to a static C++
            class member function, a value returned by
            <function>boost::bind()</function>, or an instance of a class that
            overloads <methodname>operator()</methodname>. This usage
            implements the Strategy Pattern where functionality is plugged in
            at run time. The default behavior is to use an instance of
            <classname>vrj::CpuAffinityFromEnv</classname>, assigned in the
            <classname>vrj::GlDrawManager</classname> constructor.</para>

            <para>The job of this callable object is to map the pipe
            identifier to the processor to which affinity will be assigned for
            the render thread of the pipe. The processor identifier is a
            signed integer so that a negative value can be used to indicate
            that no affinity should be assigned for the render thread of the
            pipe. The exact means by which it accomplishes this can vary, and
            that is the power of the Strategy Pattern in this context.</para>

            <para>To provide a customized processor affinity assignment
            algorithm,
            <methodname>vrj::GlDrawManager::setCpuAffinityStrategy()</methodname>
            must be invoked at the correct time. The OpenGL Draw Manager uses
            whatever affinity assignment algorithm it has as soon as it
            determines that vrj::GlPipe objects need to be created. This is
            done as part of the VR Juggler run-time reconfiguration process.
            Therefore, to guarantee that all pipes use the customized
            algorithm,
            <methodname>vrj::GlDrawManager::setCpuAffinityStrategy()</methodname>
            must be called before calling
            <methodname>vrj::Kernel::start()</methodname>, the method that
            starts the VR Juggler kernel control loop. Since the kernel
            control loop is normally started in the application
            <function>main()</function> function, the most likely place for a
            call to
            <methodname>vrj::GlDrawManager::setCpuAffinityStrategy()</methodname>
            is also in <function>main()</function>. Of course, this can vary
            depending on how VR Juggler is being used, so the most important
            thing to understand is that it must happen
            <emphasis>before</emphasis>
            <methodname>vrj::Kernel::start()</methodname> is called.</para>
         </section>

         <section id="section.custom.delegate">
            <title>Making a Custom <classname>NSApplication</classname>
            Delegate on Mac OS X</title>

            <para>The Cocoa support for VR Juggler is designed to take
            advantage of the flexibility of Cocoa application design and, more
            generally, the flexibility of the Objective-C language.
            Specifically, VR Juggler application programmers targeting Mac OS
            X have a unique opportunity to customize the behavior of VR
            Juggler application behavior. Behind the scenes,
            <classname>vrj::CocoaWrapper</classname> registers a delegate, an
            instance of the Objective-C class
            <classname>VRJBasicDelegate</classname>, with the
            <classname>NSApplication</classname> singleton. Messages from
            <classname>NSApplication</classname> are received and handled by
            this object. VR Juggler application programmers can tailor the
            handling of these messages by creating and using a custom
            <classname>NSApplication</classname> delegate.</para>

            <para>The full details of delegates and customizing the behavior
            of <classname>NSApplication</classname> are well beyond the scope
            of this document. Readers are referred to Apple's documentation
            for <ulink
            url="http://developer.apple.com/referencelibrary/GettingStarted/GS_Cocoa/index.html">Cocoa</ulink>
            and <ulink
            url="http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html"><classname>NSApplication</classname>
            class reference</ulink>. We will proceed from here under the
            assumption that readers are already familiar with the relevant and
            necessary topics including, but not limited to, Objective-C,
            Objective-C++, and <classname>NSApplication</classname>.</para>

            <para>In a typical Cocoa application, the delegate would be given
            to the <classname>NSApplication</classname> singleton instance by
            sending that object the<methodname>-setDelegate:</methodname>
            message. Doing so, however, will interfere with the proper
            functionality of VR Juggler. Thus, the registration mechanism is
            done using the <literal>VRJDelegateClass</literal> property in
            <filename>Contents/Resources/vrjuggler.plist</filename>. The
            default value of this property is
            <classname>VRJBasicDelegate</classname>. By changing this to the
            name of the custom class, <classname>vrj::CocoaWrapper</classname>
            will instantiate, register, and use the custom class instead.
            (Being able to do this is a simple and elegant feature of
            Objective-C.)</para>

            <para>There are two ways to create a custom delegate class. The
            class can either stand on its own as a subclass of
            <classname>NSObject</classname>, or it can derive from
            <classname>VRJBasicDelegate</classname>. The decision about which
            approach to use depends on whether complete or partial
            customization is desired. For this discussion, we will focus on
            complete customization—that is, creating a new delegate type by
            deriving from <classname>NSObject</classname>.</para>

            <sidebar>
               <para>It is worth pointing out that
               <classname>VRJBasicDelegate</classname> is not necessarily
               designed to be extended. It can be customized, but mainly, this
               customization is done by overriding methods to
               <emphasis>replace</emphasis> the behavior of the base class
               rather than to extend it. Refer to the implementation of
               <classname>VRJBasicDelegate</classname> to get a better idea of
               the implications of overriding it for the purposes of
               customization. The code can be found in
               <filename>modules/vrjuggler/vrj/Kernel/VRJBasicDelegate.mm</filename>
               and
               <filename>modules/vrjuggler/vrj/Kernel/VRJBasicDelegate.h</filename>.</para>
            </sidebar>

            <para>As noted, the job of the delegate is to respond to messages
            from <classname>NSApplication</classname>. The messages that are
            delivered to the delegate are documented in the
            <classname>NSApplication</classname> reference, and we will not
            duplicate that information here. Instead, we will concentrate on a
            small subset of these messages related to document loading. The
            purpose is twofold. First, this explanation helps in understanding
            the implementation of <classname>VRJBasicDelegate</classname>,
            thereby clarifying options for customizing the behavior of that
            class. Second, document loading is a prominent topic in Mac OS X
            application development, and it is likely to be of the most
            interest to VR application programmers, too.</para>

            <para>To get things under way, have a glance at <xref
            linkend="example.basic.delegate.impl" />. It is a relatively
            simple class that uses Objective-C++ capabilities to create a
            simple bridge between <filename>NSApplication</filename> and
            <classname>vrj::Kernel</classname>. The documents being loaded in
            this case are VR Juggler configuration files, but it is not much
            of a leap to imagine the use of any other document type (i.e.,
            data file used as input to the application). We will review each
            of the methods of this class.</para>

            <example id="example.basic.delegate.impl">
               <title><filename>MyDelegate.mm</filename>: Basic Delegate
               Implementation</title>

               <programlisting linenumbering="numbered">#import &lt;Foundation/NSArray.h&gt;
#import &lt;Foundation/NSString.h&gt;
#import &lt;AppKit/NSApplication.h&gt;

#include &lt;vrj/Kernel/Kernel.h&gt;


@interface MyDelegate : NSObject
{
   BOOL mLoadConfigs;
}
@end

@implementation MyDelegate
   -(id) init
   {
      mLoadConfigs = YES;
      return [super init];
   }

   -(void) setLoadConfigs:(BOOL) load
   {
      mLoadConfigs = load;
   }

   -(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication*) sender
   {
      // We return NO here because we have a different way of shutting down
      // the application. When vrj::Kernel::stop() is invoked, it will cause
      // the application run loop to stop by invoking
      // vrj::CocoaWrapper::stop().
      return NO;
   }

   -(void) applicationDidFinishLaunching:(NSNotification*) aNotification
   {
      // We're ready to allow windows to open!
      NSConditionLock* lock = gadget::InputAreaCocoa::getWindowLock();
      [lock unlock];
   }

   -(BOOL) application:(NSApplication*) theApplication
              openFile:(NSString*) file
   {
      if ( mLoadConfigs )
      {
         vrj::Kernel::instance()-&gt;loadConfigFile([file UTF8String]);
      }

      return YES;
   }

   -(void) application:(NSApplication*) theApplication
             openFiles:(NSArray*) files
   {
      if ( mLoadConfigs )
      {
         const int count = [files count];
         for ( int i = 0; i &lt; count; ++i )
         {
            NSString* file = [files objectAtIndex:i];
            vrj::Kernel::instance()-&gt;loadConfigFile([file UTF8String]);
         }
      }
   }
@end</programlisting>
            </example>

            <section>
               <title>Data Members</title>

               <para>The class <classname>MyDelegate</classname> has a single
               data member, <varname>mLoadConfigs</varname>, that determines
               how instances of this class will respond to certain messages
               sent by <classname>NSApplication</classname>. The value will be
               changed if <classname>vrj::CocoaWrapper</classname> sends the
               <methodname>-setLoadConfigs:</methodname> message as a result
               of the property <literal>VRJConfigHandling</literal> being set
               in
               <filename>Contents/Resources/vrjuggler.plist</filename>.</para>
            </section>

            <section>
               <title>Designated Initializer</title>

               <para>Every <classname>NSObject</classname> subclass has a
               designated initializer. In the case of the VR Juggler
               <classname>NSApplication</classname> delegate, this is the
               basic <methodname>-init</methodname> method. The current usage
               of the application delegate requires that this method be the
               designated initializer, meaning that it is the only initializer
               that will be invoked upon creating the delegate instance. This
               limitation may be fixed in a future version of
               <classname>vrj::CocoaWrapper</classname>. If the custom
               delegate does not accept the -init message, then the inherited
               <classname>NSObject</classname> version will be used.</para>

               <para>In the meantime, this is where all object initialization
               takes place. What this means exactly is up to the delegate
               author. In this case, we set the data member
               <varname>mLoadConfigs</varname> to <constant>YES</constant>,
               send our base class the <methodname>-init</methodname> message,
               and return the result. This last step (a widely used
               convention) is what must be done by any custom delegate
               implementation of <methodname>-init</methodname>.</para>
            </section>

            <section>
               <title><methodname>-setLoadConfigs:</methodname></title>

               <para>This method is a unique aspect of the delegate as it is
               handled by <classname>vrj::CocoaWrapper</classname>.
               Specifically, <classname>vrj::CocoaWrapper</classname> will
               examine <filename>Contents/Resources/vrjuggler.plist</filename>
               to see if it contains the property
               <literal>VRJConfigHandling</literal>. If it does, it will send
               this message to the delegate instance with the value as it is
               set in the property list. This happens before the delegate
               object is handed off to the
               <classname>NSApplication</classname> singleton. The
               consequences of setting and using the
               <literal>VRJConfigHandling</literal> property were described in
               <xref linkend="section.cocoa.app.execution" />.</para>

               <para>A custom delegate does not have to implement this method.
               If it does not, the Objective-C runtime will print a warning on
               the console stating that the object does not receive this
               message. (A future version of
               <classname>vrj::CocoaWrapper</classname> may examine the
               delegate interface to determine if it receives the message just
               to avoid having that message printed.) It is up to the delegate
               author to determine if implementing this method is necessary
               and, if so, how it should behave. In our example, we set
               <varname>mLoadConfigs</varname> to the value of the parameter,
               just as <classname>VRJBasicDelegate</classname> does.</para>
            </section>

            <section>
               <title><methodname>-applicationShouldTerminateAfterLastWindowClosed:</methodname></title>

               <para>This method is used by
               <classname>NSApplication</classname> to allow customization of
               application shutdown. In the case of an application delegate
               instantiated and used by
               <classname>vrj::CocoaWrapper</classname>, it is critical that
               this method return the value <constant>NO</constant>. The VR
               Juggler kernel knows about
               <classname>vrj::CocoaWrapper</classname> and knows how to shut
               it down when the time is right. Because of that, we want the
               kernel to control the termination process.</para>
            </section>

            <section>
               <title><methodname>-applicationDidFinishLaunching:</methodname></title>

               <para>When the application finishes launching, NSApplication
               sends this message to its delegate. In the case of VR Juggler,
               this is when we know that it is safe to allow threads for
               Gadgeteer input windows and VR Juggler graphics pipes to open
               windows. Until now, any such threads have been blocking on the
               global window lock, acquired when
               <classname>vrj::CocoaWrapper</classname> was instantiated. When
               the delegate receives this message, it is time to release that
               lock. Other operations can be performed in this method
               implementation, but this step is absolutely critical.</para>
            </section>

            <section>
               <title><methodname>-application:openFile:</methodname></title>

               <para>Now, we get to one of the methods used by
               <classname>NSApplication</classname> to tell its delegate when
               to open a single data file. Remember that our simple delegate
               just handles VR Juggler configuration files. Moreover, it is
               assuming (probably unsafely) that the only files that it will
               be given to load are VR Juggler configuration files.</para>

               <para>In any case, <classname>NSApplication</classname> sends
               this message to its delegate at well-defined times. The
               response of our simple delegate is based on the value of
               <varname>mLoadConfigs</varname>. If it is true (set to
               <constant>YES</constant>), that means that our delegate will
               load configuration files as a result of the user
               double-clicking on <filename>.jconf</filename> files in the
               <application>Finder</application> or through the use of the
               <command>open</command> command. Loading of configuration files
               is done through the usual means of passing the file name to the
               <classname>vrj::Kernel</classname> instance. Note that we
               convert the <classname>NSString</classname> Unicode value to a
               UTF8 string because that is what
               <methodname>vrj::Kernel::loadConfigFile()</methodname> knows
               how to handle. A future version of VR Juggler may have proper
               Unicode support so that this step is not necessary.</para>

               <para>Note that this method returns <constant>YES</constant>
               regardless of the value of <varname>mLoadConfigs</varname>.
               This has the effect of making
               <classname>NSApplication</classname> think that the file was
               loaded even if it was ignored. In some cases, it may make more
               sense to return <constant>NO</constant> instead. As with just
               about everything in the custom delegate, the exact response to
               this message is up to the author.</para>
            </section>

            <section>
               <title><methodname>-application:openFiles:</methodname></title>

               <para>This method is the multi-file counterpart to
               <methodname>-application:openFile:</methodname>. The behavior
               is essentially the same except that it iterates over the
               contents of the given NSArray object and calls
               <methodname>vrj::Kernel::loadConfigFile()</methodname> for each
               of the contained <classname>NSString</classname>
               objects.</para>
            </section>
         </section>

         <section>
            <title>Defining Custom Cocoa/VR Juggler Bridging on Mac OS
            X</title>

            <para>More intrepid programmers may find that writing a custom
            NSApplication delegate is not sufficient for customizing VR
            Juggler application behavior on Mac OS X. In that event, the
            customization can be even more extensive by replacing the use of
            <classname>vrj::CocoaWrapper</classname> altogether. For all
            intents and purposes, <classname>vrj::CocoaWrapper</classname> is
            grafted on to <classname>vrj::Kernel</classname> to provide the
            mediator between the competing desires of
            <classname>NSApplication</classname> and
            <classname>vrj::Kernel</classname> to control application
            execution<footnote>
                  <para>This is not a strictly accurate description of the
                  design because <classname>vrj::Kernel</classname> has to
                  know about <classname>vrj::CocoaWrapper</classname> and call
                  its methods at certain times. A true mediator would sit
                  above <classname>vrj::Kernel</classname> and
                  <classname>vrj::CocoaWrapper</classname> and coordinate
                  their interaction to prevent such tight coupling, but
                  introducing that sort of design would complicate things
                  unnecessarily.</para>
               </footnote>. <classname>vrj::Kernel</classname> can be told not
            to use <classname>vrj::CocoaWrapper</classname>, thus providing an
            extension point where a different Cocoa/VR Juggler bridging can be
            used. This is done by calling the static method
            <methodname>vrj::Kernel::setUseCocoaWrapper()</methodname> with
            the parameter <constant>false</constant>
            <emphasis>before</emphasis> the first call to
            <methodname>vrj::Kernel::instance()</methodname>.</para>

            <para>In general, the programmer of this bridging code is free to
            do whatever makes sense, but there are a few caveats. First, every
            thread that is created by any Juggler component needs to have an
            <classname>NSAutoReleasePool</classname> created. This is done by
            registering thread start and thread exit methods with
            <classname>vpr::Thread</classname>.</para>

            <para>Next, AppKit and Cocoa need to know that they are being used
            in a multi-threaded environment. They are made aware of this fact
            when the first <classname>NSThread</classname> object is created.
            VPR uses low-level POSIX threads on Mac OS X rather than using
            <classname>NSThread</classname>. Thus, a dummy thread needs to be
            created using <classname>NSThread</classname>. All it has to do is
            run an empty method and exit. The thread start callback is
            registered using
            <methodname>vpr::Thread::addThreadStartCallback()</methodname>,
            and the thread exit callback is registered using
            <methodname>vpr::Thread::addThreadExitCallback()</methodname>. The
            thread start callback must allocate and initialize a
            thread-specific instance of
            <classname>NSAutoReleasePool</classname>, and the thread exit
            callback must release its reference to the
            <classname>NSAutoReleasePool</classname> instance created by the
            thread start callback. These callbacks have to be registered
            <emphasis>before</emphasis> any <classname>vpr::Thread</classname>
            objects are created.</para>

            <para>Finally, the global window lock must be held until it is
            safe to open input and graphics windows. This is necessary because
            Gadgeteer and VR Juggler open windows in threads other than the
            primordial, and AppKit does not handle that well. This lock (an
            instance of <classname>NSConditionLock</classname>) is retrieved
            using the static method
            <methodname>gadget::InputAreaCocoa::getWindowLock()</methodname>.
            The job of the bridging code is to acquire the lock as soon as it
            can. Specifically, it should do it <emphasis>before</emphasis>
            creating the <classname>NSApplication</classname> singleton object
            by sending the <classname>NSApplication</classname> class the
            <methodname>+sharedApplication</methodname> message. The global
            lock must be released once we know that the application has
            finished launching. If a delegate is used with the
            <classname>NSApplication</classname> singleton, the lock should be
            released when the delegate receives the
            <methodname>-applicationDidFinishLaunching:</methodname>
            message.</para>

            <para>Beyond that, the programmer is free to do as s/he wishes in
            the implementation of the Cocoa/VR Juggler bridging code.
            Referring to the implementation of
            <classname>vrj::CocoaWrapper</classname> is highly recommended
            (see
            <filename>modules/vrjuggler/vrj/Kernel/CocoaWrapper.mm</filename>
            and
            <filename>modules/vrjuggler/vrj/Kernel/CocoaWrapper.h</filename>
            in the source tree), but its exact behavior does not have to be
            replicated. The points presented above are the most important
            things that must be done by any implementation of bridging
            code.</para>

            <para>Ultimately, all of this work is done to help VR Juggler get
            along with Cocoa. VR Juggler makes heavy use of multi-threading
            whereas AppKit and Cocoa tend to work best in single-threaded
            environments—or at in least environments where the primordial
            thread is receiving and dispatching all window system events.
            Things are just not that simple with VR Juggler, and thus the
            bridge between these frameworks plays a vital role.</para>
         </section>
      </chapter>
   </part>

   <part id="part.appendices">
      <title>Appendices</title>

      <appendix id="appendix.gfdl">
         <title>GNU Free Documentation License</title>

         <subtitle>Version 1.2, November 2002</subtitle>

         <blockquote id="fsf-copyright">
            <title>FSF Copyright note</title>

            <para>Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
            59 Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is
            permitted to copy and distribute verbatim copies of this license
            document, but changing it is not allowed.</para>
         </blockquote>

         <section id="gfdl-0">
            <title>PREAMBLE</title>

            <para>The purpose of this License is to make a manual, textbook,
            or other functional and useful document "free" in the sense of
            freedom: to assure everyone the effective freedom to copy and
            redistribute it, with or without modifying it, either commercially
            or noncommercially. Secondarily, this License preserves for the
            author and publisher a way to get credit for their work, while not
            being considered responsible for modifications made by
            others.</para>

            <para>This License is a kind of "copyleft", which means that
            derivative works of the document must themselves be free in the
            same sense. It complements the GNU General Public License, which
            is a copyleft license designed for free software.</para>

            <para>We have designed this License in order to use it for manuals
            for free software, because free software needs free documentation:
            a free program should come with manuals providing the same
            freedoms that the software does. But this License is not limited
            to software manuals; it can be used for any textual work,
            regardless of subject matter or whether it is published as a
            printed book. We recommend this License principally for works
            whose purpose is instruction or reference.</para>
         </section>

         <section id="gfdl-1">
            <title>APPLICABILITY AND DEFINITIONS</title>

            <para id="gfdl-doc">This License applies to any manual or other
            work, in any medium, that contains a notice placed by the
            copyright holder saying it can be distributed under the terms of
            this License. Such a notice grants a world-wide, royalty-free
            license, unlimited in duration, to use that work under the
            conditions stated herein. The "Document", below, refers to any
            such manual or work. Any member of the public is a licensee, and
            is addressed as "you". You accept the license if you copy, modify
            or distribute the work in a way requiring permission under
            copyright law.</para>

            <para id="gfdl-mod-ver">A "Modified Version" of the Document means
            any work containing the Document or a portion of it, either copied
            verbatim, or with modifications and/or translated into another
            language.</para>

            <para id="gfdl-secnd-sect">A "Secondary Section" is a named
            appendix or a front-matter section of the Document that deals
            exclusively with the relationship of the publishers or authors of
            the Document to the Document's overall subject (or to related
            matters) and contains nothing that could fall directly within that
            overall subject. (Thus, if the Document is in part a textbook of
            mathematics, a Secondary Section may not explain any mathematics.)
            The relationship could be a matter of historical connection with
            the subject or with related matters, or of legal, commercial,
            philosophical, ethical or political position regarding
            them.</para>

            <para id="gfdl-inv-sect">The "Invariant Sections" are certain
            Secondary Sections whose titles are designated, as being those of
            Invariant Sections, in the notice that says that the Document is
            released under this License. If a section does not fit the above
            definition of Secondary then it is not allowed to be designated as
            Invariant. The Document may contain zero Invariant Sections. If
            the Document does not identify any Invariant Sections then there
            are none.</para>

            <para id="gfdl-cov-text">The "Cover Texts" are certain short
            passages of text that are listed, as Front-Cover Texts or
            Back-Cover Texts, in the notice that says that the Document is
            released under this License. A Front-Cover Text may be at most 5
            words, and a Back-Cover Text may be at most 25 words.</para>

            <para id="gfdl-transparent">A "Transparent" copy of the Document
            means a machine-readable copy, represented in a format whose
            specification is available to the general public, that is suitable
            for revising the document straightforwardly with generic text
            editors or (for images composed of pixels) generic paint programs
            or (for drawings) some widely available drawing editor, and that
            is suitable for input to text formatters or for automatic
            translation to a variety of formats suitable for input to text
            formatters. A copy made in an otherwise Transparent file format
            whose markup, or absence of markup, has been arranged to thwart or
            discourage subsequent modification by readers is not Transparent.
            An image format is not Transparent if used for any substantial
            amount of text. A copy that is not "Transparent" is called
            "Opaque".</para>

            <para>Examples of suitable formats for Transparent copies include
            plain ASCII without markup, Texinfo input format, LaTeX input
            format, SGML or XML using a publicly available DTD, and
            standard-conforming simple HTML, PostScript or PDF designed for
            human modification. Examples of transparent image formats include
            PNG, XCF and JPG. Opaque formats include proprietary formats that
            can be read and edited only by proprietary word processors, SGML
            or XML for which the DTD and/or processing tools are not generally
            available, and the machine-generated HTML, PostScript or PDF
            produced by some word processors for output purposes only.</para>

            <para id="gfdl-title-page">The "Title Page" means, for a printed
            book, the title page itself, plus such following pages as are
            needed to hold, legibly, the material this License requires to
            appear in the title page. For works in formats which do not have
            any title page as such, "Title Page" means the text near the most
            prominent appearance of the work's title, preceding the beginning
            of the body of the text.</para>

            <para id="gfdl-entitled">A section "Entitled XYZ" means a named
            subunit of the Document whose title either is precisely XYZ or
            contains XYZ in parentheses following text that translates XYZ in
            another language. (Here XYZ stands for a specific section name
            mentioned below, such as "Acknowledgements", "Dedications",
            "Endorsements", or "History".) To "Preserve the Title" of such a
            section when you modify the Document means that it remains a
            section "Entitled XYZ" according to this definition.</para>

            <para>The Document may include Warranty Disclaimers next to the
            notice which states that this License applies to the Document.
            These Warranty Disclaimers are considered to be included by
            reference in this License, but only as regards disclaiming
            warranties: any other implication that these Warranty Disclaimers
            may have is void and has no effect on the meaning of this
            License.</para>
         </section>

         <section id="gfdl-2">
            <title>VERBATIM COPYING</title>

            <para>You may copy and distribute the Document in any medium,
            either commercially or noncommercially, provided that this
            License, the copyright notices, and the license notice saying this
            License applies to the Document are reproduced in all copies, and
            that you add no other conditions whatsoever to those of this
            License. You may not use technical measures to obstruct or control
            the reading or further copying of the copies you make or
            distribute. However, you may accept compensation in exchange for
            copies. If you distribute a large enough number of copies you must
            also follow the conditions in section 3.</para>

            <para>You may also lend copies, under the same conditions stated
            above, and you may publicly display copies.</para>
         </section>

         <section id="gfdl-3">
            <title>COPYING IN QUANTITY</title>

            <para>If you publish printed copies (or copies in media that
            commonly have printed covers) of the Document, numbering more than
            100, and the Document's license notice requires Cover Texts, you
            must enclose the copies in covers that carry, clearly and legibly,
            all these Cover Texts: Front-Cover Texts on the front cover, and
            Back-Cover Texts on the back cover. Both covers must also clearly
            and legibly identify you as the publisher of these copies. The
            front cover must present the full title with all words of the
            title equally prominent and visible. You may add other material on
            the covers in addition. Copying with changes limited to the
            covers, as long as they preserve the title of the Document and
            satisfy these conditions, can be treated as verbatim copying in
            other respects.</para>

            <para>If the required texts for either cover are too voluminous to
            fit legibly, you should put the first ones listed (as many as fit
            reasonably) on the actual cover, and continue the rest onto
            adjacent pages.</para>

            <para>If you publish or distribute Opaque copies of the Document
            numbering more than 100, you must either include a
            machine-readable Transparent copy along with each Opaque copy, or
            state in or with each Opaque copy a computer-network location from
            which the general network-using public has access to download
            using public-standard network protocols a complete Transparent
            copy of the Document, free of added material. If you use the
            latter option, you must take reasonably prudent steps, when you
            begin distribution of Opaque copies in quantity, to ensure that
            this Transparent copy will remain thus accessible at the stated
            location until at least one year after the last time you
            distribute an Opaque copy (directly or through your agents or
            retailers) of that edition to the public.</para>

            <para>It is requested, but not required, that you contact the
            authors of the Document well before redistributing any large
            number of copies, to give them a chance to provide you with an
            updated version of the Document.</para>
         </section>

         <section id="gfdl-4">
            <title>MODIFICATIONS</title>

            <para>You may copy and distribute a Modified Version of the
            Document under the conditions of sections 2 and 3 above, provided
            that you release the Modified Version under precisely this
            License, with the Modified Version filling the role of the
            Document, thus licensing distribution and modification of the
            Modified Version to whoever possesses a copy of it. In addition,
            you must do these things in the Modified Version:</para>

            <orderedlist id="gfdl-modif-cond" numeration="upperalpha">
               <title>GNU FDL Modification Conditions</title>

               <listitem>
                  <simpara>Use in the Title Page (and on the covers, if any) a
                  title distinct from that of the Document, and from those of
                  previous versions (which should, if there were any, be
                  listed in the History section of the Document). You may use
                  the same title as a previous version if the original
                  publisher of that version gives permission.</simpara>
               </listitem>

               <listitem>
                  <simpara>List on the Title Page, as authors, one or more
                  persons or entities responsible for authorship of the
                  modifications in the Modified Version, together with at
                  least five of the principal authors of the Document (all of
                  its principal authors, if it has fewer than five), unless
                  they release you from this requirement.</simpara>
               </listitem>

               <listitem>
                  <simpara>State on the Title page the name of the publisher
                  of the Modified Version, as the publisher.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve all the copyright notices of the
                  Document.</simpara>
               </listitem>

               <listitem>
                  <simpara>Add an appropriate copyright notice for your
                  modifications adjacent to the other copyright
                  notices.</simpara>
               </listitem>

               <listitem>
                  <simpara>Include, immediately after the copyright notices, a
                  license notice giving the public permission to use the
                  Modified Version under the terms of this License, in the
                  form shown in the <link
                  linkend="gfdl-addendum">Addendum</link> below.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve in that license notice the full lists of
                  Invariant Sections and required Cover Texts given in the
                  Document's license notice.</simpara>
               </listitem>

               <listitem>
                  <simpara>Include an unaltered copy of this
                  License.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve the section Entitled "History", Preserve
                  its Title, and add to it an item stating at least the title,
                  year, new authors, and publisher of the Modified Version as
                  given on the Title Page. If there is no section Entitled
                  "History" in the Document, create one stating the title,
                  year, authors, and publisher of the Document as given on its
                  Title Page, then add an item describing the Modified Version
                  as stated in the previous sentence.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve the network location, if any, given in the
                  Document for public access to a Transparent copy of the
                  Document, and likewise the network locations given in the
                  Document for previous versions it was based on. These may be
                  placed in the "History" section. You may omit a network
                  location for a work that was published at least four years
                  before the Document itself, or if the original publisher of
                  the version it refers to gives permission.</simpara>
               </listitem>

               <listitem>
                  <simpara>For any section Entitled "Acknowledgements" or
                  "Dedications", Preserve the Title of the section, and
                  preserve in the section all the substance and tone of each
                  of the contributor acknowledgements and/or dedications given
                  therein.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve all the Invariant Sections of the
                  Document, unaltered in their text and in their titles.
                  Section numbers or the equivalent are not considered part of
                  the section titles.</simpara>
               </listitem>

               <listitem>
                  <simpara>Delete any section Entitled "Endorsements". Such a
                  section may not be included in the Modified
                  Version.</simpara>
               </listitem>

               <listitem>
                  <simpara>Do not retitle any existing section to be Entitled
                  "Endorsements" or to conflict in title with any Invariant
                  Section.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve any Warranty Disclaimers.</simpara>
               </listitem>
            </orderedlist>

            <para>If the Modified Version includes new front-matter sections
            or appendices that qualify as Secondary Sections and contain no
            material copied from the Document, you may at your option
            designate some or all of these sections as invariant. To do this,
            add their titles to the list of Invariant Sections in the Modified
            Version's license notice. These titles must be distinct from any
            other section titles.</para>

            <para>You may add a section Entitled "Endorsements", provided it
            contains nothing but endorsements of your Modified Version by
            various parties--for example, statements of peer review or that
            the text has been approved by an organization as the authoritative
            definition of a standard.</para>

            <para>You may add a passage of up to five words as a Front-Cover
            Text, and a passage of up to 25 words as a Back-Cover Text, to the
            end of the list of Cover Texts in the Modified Version. Only one
            passage of Front-Cover Text and one of Back-Cover Text may be
            added by (or through arrangements made by) any one entity. If the
            Document already includes a cover text for the same cover,
            previously added by you or by arrangement made by the same entity
            you are acting on behalf of, you may not add another; but you may
            replace the old one, on explicit permission from the previous
            publisher that added the old one.</para>

            <para>The author(s) and publisher(s) of the Document do not by
            this License give permission to use their names for publicity for
            or to assert or imply endorsement of any Modified Version.</para>
         </section>

         <section id="gfdl-5">
            <title>COMBINING DOCUMENTS</title>

            <para>You may combine the Document with other documents released
            under this License, under the terms defined in <link
            linkend="gfdl-4">section 4</link> above for modified versions,
            provided that you include in the combination all of the Invariant
            Sections of all of the original documents, unmodified, and list
            them all as Invariant Sections of your combined work in its
            license notice, and that you preserve all their Warranty
            Disclaimers.</para>

            <para>The combined work need only contain one copy of this
            License, and multiple identical Invariant Sections may be replaced
            with a single copy. If there are multiple Invariant Sections with
            the same name but different contents, make the title of each such
            section unique by adding at the end of it, in parentheses, the
            name of the original author or publisher of that section if known,
            or else a unique number. Make the same adjustment to the section
            titles in the list of Invariant Sections in the license notice of
            the combined work.</para>

            <para>In the combination, you must combine any sections Entitled
            "History" in the various original documents, forming one section
            Entitled "History"; likewise combine any sections Entitled
            "Acknowledgements", and any sections Entitled "Dedications". You
            must delete all sections Entitled "Endorsements".</para>
         </section>

         <section id="gfdl-6">
            <title>COLLECTIONS OF DOCUMENTS</title>

            <para>You may make a collection consisting of the Document and
            other documents released under this License, and replace the
            individual copies of this License in the various documents with a
            single copy that is included in the collection, provided that you
            follow the rules of this License for verbatim copying of each of
            the documents in all other respects.</para>

            <para>You may extract a single document from such a collection,
            and distribute it individually under this License, provided you
            insert a copy of this License into the extracted document, and
            follow this License in all other respects regarding verbatim
            copying of that document.</para>
         </section>

         <section id="gfdl-7">
            <title>AGGREGATION WITH INDEPENDENT WORKS</title>

            <para>A compilation of the Document or its derivatives with other
            separate and independent documents or works, in or on a volume of
            a storage or distribution medium, is called an "aggregate" if the
            copyright resulting from the compilation is not used to limit the
            legal rights of the compilation's users beyond what the individual
            works permit. When the Document is included in an aggregate, this
            License does not apply to the other works in the aggregate which
            are not themselves derivative works of the Document.</para>

            <para>If the Cover Text requirement of section 3 is applicable to
            these copies of the Document, then if the Document is less than
            one half of the entire aggregate, the Document's Cover Texts may
            be placed on covers that bracket the Document within the
            aggregate, or the electronic equivalent of covers if the Document
            is in electronic form. Otherwise they must appear on printed
            covers that bracket the whole aggregate.</para>
         </section>

         <section id="gfdl-8">
            <title>TRANSLATION</title>

            <para>Translation is considered a kind of modification, so you may
            distribute translations of the Document under the terms of section
            4. Replacing Invariant Sections with translations requires special
            permission from their copyright holders, but you may include
            translations of some or all Invariant Sections in addition to the
            original versions of these Invariant Sections. You may include a
            translation of this License, and all the license notices in the
            Document, and any Warranty Disclaimers, provided that you also
            include the original English version of this License and the
            original versions of those notices and disclaimers. In case of a
            disagreement between the translation and the original version of
            this License or a notice or disclaimer, the original version will
            prevail.</para>

            <para>If a section in the Document is Entitled "Acknowledgements",
            "Dedications", or "History", the requirement (section 4) to
            Preserve its Title (section 1) will typically require changing the
            actual title.</para>
         </section>

         <section id="gfdl-9">
            <title>TERMINATION</title>

            <para>You may not copy, modify, sublicense, or distribute the
            Document except as expressly provided for under this License. Any
            other attempt to copy, modify, sublicense or distribute the
            Document is void, and will automatically terminate your rights
            under this License. However, parties who have received copies, or
            rights, from you under this License will not have their licenses
            terminated so long as such parties remain in full
            compliance.</para>
         </section>

         <section id="gfdl-10">
            <title>FUTURE REVISIONS OF THIS LICENSE</title>

            <para>The Free Software Foundation may publish new, revised
            versions of the GNU Free Documentation License from time to time.
            Such new versions will be similar in spirit to the present
            version, but may differ in detail to address new problems or
            concerns. See http://www.gnu.org/copyleft/.</para>

            <para>Each version of the License is given a distinguishing
            version number. If the Document specifies that a particular
            numbered version of this License "or any later version" applies to
            it, you have the option of following the terms and conditions
            either of that specified version or of any later version that has
            been published (not as a draft) by the Free Software Foundation.
            If the Document does not specify a version number of this License,
            you may choose any version ever published (not as a draft) by the
            Free Software Foundation.</para>
         </section>

         <section id="gfdl-addendum">
            <title>ADDENDUM: How to use this License for your
            documents</title>

            <para>To use this License in a document you have written, include
            a copy of the License in the document and put the following
            copyright and license notices just after the title page:</para>

            <blockquote id="copyright-sample">
               <title>Sample Invariant Sections list</title>

               <para>Copyright (c) YEAR YOUR NAME. Permission is granted to
               copy, distribute and/or modify this document under the terms of
               the GNU Free Documentation License, Version 1.2 or any later
               version published by the Free Software Foundation; with no
               Invariant Sections, no Front-Cover Texts, and no Back-Cover
               Texts. A copy of the license is included in the section
               entitled "GNU Free Documentation License".</para>
            </blockquote>

            <para>If you have Invariant Sections, Front-Cover Texts and
            Back-Cover Texts, replace the "with...Texts." line with
            this:</para>

            <blockquote id="inv-cover-sample">
               <title>Sample Invariant Sections list</title>

               <para>with the Invariant Sections being LIST THEIR TITLES, with
               the Front-Cover Texts being LIST, and with the Back-Cover Texts
               being LIST.</para>
            </blockquote>

            <para>If you have Invariant Sections without Cover Texts, or some
            other combination of the three, merge those two alternatives to
            suit the situation.</para>

            <para>If your document contains nontrivial examples of program
            code, we recommend releasing these examples in parallel under your
            choice of free software license, such as the GNU General Public
            License, to permit their use in free software.</para>
         </section>
      </appendix>
   </part>

   <glossary>
      <title>Glossary of Terms</title>

      <glossdiv>
         <title>A</title>

         <glossentry id="gloss.app.object">
            <glossterm>application object</glossterm>

            <glossdef>
               <para>An instance of a C++ class that is given to the VR
               Juggler kernel for execution. Such objects contain the visuals
               and the interactions that make up a virtual world.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>C</title>

         <glossentry id="gloss.callback">
            <glossterm>callback</glossterm>

            <glossdef>
               <para>In the C programming language, a function pointer that is
               invoked to <quote>call back</quote> to some other code.
               Usually, a function pointer is passed as an argument to some
               function that stores the pointer for later use.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.csdata">
            <glossterm>context-specific data</glossterm>

            <glossdef>
               <para>In OpenGL terms, some information that is associated with
               a specific OpenGL context.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.critical.section">
            <glossterm>critical section</glossterm>

            <glossdef>
               <para>In multi-threaded programming, a block of code that reads
               from or writes to data that is shared across multiple
               threads.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>D</title>

         <glossentry id="gloss.daemon">
            <glossterm>daemon</glossterm>

            <glossdef>
               <para>In UNIX-based operating systems, a background process
               that performs some job continuously while the computer is
               running. For example, a web server runs a daemon (often called
               <command>httpd</command>) that manages incoming HTTP
               requests.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.device.interface">
            <glossterm>device interface</glossterm>

            <glossdef>
               <para>A high-level feature provided by Gadgeteer for getting
               easy access to a type-specific device proxy. For each input
               device type, there is one device proxy type, and for each
               device proxy type, there is one device interface type. For
               example, digital input devices are of type
               <classname>gadget::Digital</classname>. Digital input data is
               accessed by VR Juggler application objects through a
               <classname>gadget::DigitalProxy</classname>. The proxy
               reference is most easily acquired through a
               <classname>gadget::DigitalInterface</classname> object.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.display.context">
            <glossterm>display context</glossterm>

            <glossdef>
               <para>The location to which OpenGL rendering commands
               draw.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>F</title>

         <glossentry id="gloss.frame">
            <glossterm>frame</glossterm>

            <glossdef>
               <para>In computer graphics terms, one iteration of a rendering
               loop. In VR Juggler, a frame is one complete pass through an
               application object's methods, beginning with
               <methodname>vrj::App::preFrame()</methodname> and ending with
               <methodname>vrj::App::postFrame()</methodname>. Methods called
               in between include
               <methodname>vrj::App::intraFrame()</methodname> and methods
               that are specific to a given graphics API.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>G</title>

         <glossentry id="gloss.guid">
            <glossterm>GUID</glossterm>

            <glossdef>
               <para>Globally unique identifier that is generated using
               various properties of a machine and a random number generator.
               It has been proven that it is statistically impossible for the
               same number to be generated twice within the average human
               lifetime.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>I</title>

         <glossentry id="gloss.interface">
            <glossterm>interface</glossterm>

            <glossdef>
               <para>An interface is a collection of operations used to
               specify a service of a class or a component.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>O</title>

         <glossentry id="gloss.opengl.rendering.context">
            <glossterm>OpenGL rendering context</glossterm>

            <glossdef>
               <para>An OpenGL state machine associated with a display
               window.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>P</title>

         <glossentry id="gloss.proxy">
            <glossterm>proxy</glossterm>

            <glossdef>
               <para>An intermediary that passes information between two
               parties.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>S</title>

         <glossentry id="gloss.smart.pointer">
            <glossterm>smart pointer</glossterm>

            <glossdef>
               <para>In C++ terminology, a smart pointer is a pointer-like
               object where the pointer dereference operators (-&gt; and *)
               are overloaded to perform special functionality. This takes
               advantage of C++ operator overloading to hide extra processing
               steps behind a familiar syntax.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.stupefied.proxy">
            <glossterm>stupefied proxy</glossterm>

            <glossdef>
               <para>A device proxy that has no device. Such a proxy always
               returns the same data because it cannot query new data from an
               input device. Proxies become stupefied when there is an error
               in the configuration or when the proxied device is unavailable
               for some reason.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>T</title>

         <glossentry id="gloss.thread.of.control">
            <glossterm>thread of control</glossterm>

            <glossdef>
               <para>In a multi-threaded application, a single sequence of
               execution. Each thread in a multi-threaded application has its
               own thread of control that can execute in parallel with the
               other threads of control.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.triple.buffering">
            <glossterm>triple buffering</glossterm>

            <glossdef>
               <para>An extension to double buffering that uses three data
               buffers instead of two. Triple buffering minimizes the time
               that two threads have to wait to access shared data. At most,
               one thread will wait while another thread copies no more than
               four bytes of data. That is, regardless of the size of a single
               data buffer, the amount of memory copied to swap buffers is no
               more than four bytes (the size of a 32-bit memory
               address).</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>V</title>

         <glossentry id="gloss.virtual.platform">
            <glossterm>virtual platform</glossterm>

            <glossdef>
               <para>An abstraction of the operating system and hardware (both
               the computer architecture and the input devices) that comprise
               a VR system. A virtual platform provides a cross-platform and
               cross-VR system layer upon which portable VR applications can
               be written.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
   </glossary>

   <index></index>
</book>